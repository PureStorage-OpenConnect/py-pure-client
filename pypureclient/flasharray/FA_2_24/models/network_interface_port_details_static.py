# coding: utf-8

"""
    FlashArray REST API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 2.24
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from typing import Set, Dict, Any

from typing import List, Optional
from pydantic import BaseModel, Field, StrictStr, conlist, constr
from pypureclient.flasharray.FA_2_24.models.network_interface_port_details_static_rx_power_thresholds import NetworkInterfacePortDetailsStaticRxPowerThresholds
from pypureclient.flasharray.FA_2_24.models.network_interface_port_details_static_temperature_thresholds import NetworkInterfacePortDetailsStaticTemperatureThresholds
from pypureclient.flasharray.FA_2_24.models.network_interface_port_details_static_tx_bias_thresholds import NetworkInterfacePortDetailsStaticTxBiasThresholds
from pypureclient.flasharray.FA_2_24.models.network_interface_port_details_static_tx_power_thresholds import NetworkInterfacePortDetailsStaticTxPowerThresholds
from pypureclient.flasharray.FA_2_24.models.network_interface_port_details_static_voltage_thresholds import NetworkInterfacePortDetailsStaticVoltageThresholds


class NetworkInterfacePortDetailsStatic(BaseModel):
    """
    Static module identity and capabilities information for the specified network interface or Fibre Channel port.
    """
    cable_technology: Optional[conlist(StrictStr)] = Field(default=None, description="The SFP+ cable technology supported by the transceiver.")
    connector_type: Optional[StrictStr] = Field(default=None, description="The media connector type of the transceiver.")
    encoding: Optional[StrictStr] = Field(default=None, description="The serial encoding algorithm of the transceiver.")
    extended_identifier: Optional[StrictStr] = Field(default=None, description="The extended identifier of the transceiver type.")
    fc_link_lengths: Optional[conlist(StrictStr)] = Field(default=None, description="The Fibre Channel distance capabilities supported by the transceiver.")
    fc_speeds: Optional[StrictStr] = Field(default=None, description="The Fibre Channel speeds supported by the transceiver. Speeds are in units of 100 MBytes/sec, which correspond to GFC (Gb/s).")
    fc_technology: Optional[conlist(StrictStr)] = Field(default=None, description="The Fibre Channel technologies supported by the transceiver.")
    fc_transmission_media: Optional[conlist(StrictStr)] = Field(default=None, description="The Fibre Channel transmission media supported by the transceiver.")
    identifier: Optional[StrictStr] = Field(default=None, description="The transceiver type.")
    link_length: Optional[StrictStr] = Field(default=None, description="Link length and cable attenuation (for active or copper cables) for the specified transceiver. Values are comma-separated lists of fields and values, where each field is separated from its corresponding value by a colon. Valid fields include `Copper Cable Attenuation (12.9 GHz)`, `Copper Cable Attenuation (25.78 GHz)`, `Copper Cable`, `SMF`, `OM2`, `OM1`, `OM4`, and `OM3`. The unit for attenuation is dB, and the units for length are meters or kilometers. Unspecified fields are omitted.")
    rate_identifier: Optional[StrictStr] = Field(default=None, description="The type of rate select functionality of the transceiver.")
    rx_power_thresholds: Optional[NetworkInterfacePortDetailsStaticRxPowerThresholds] = None
    signaling_rate: Optional[StrictStr] = Field(default=None, description="The nominal signaling rate in MBd, rounded off to the nearest 100 MBd, or if greater than 25400 MBd, rounded off to the nearest 250 MBd. The value can be unspecified.")
    signaling_rate_max: Optional[StrictStr] = Field(default=None, description="The upper signaling rate limit at which the transceiver still meets its specifications, specified as a percentage above the nominal signaling rate. The value can be unspecified.")
    signaling_rate_min: Optional[StrictStr] = Field(default=None, description="The lower signaling rate limit at which the transceiver still meets its specifications, specified as a percentage below the nominal signaling rate. The value can be unspecified.")
    specifications: Optional[conlist(StrictStr)] = Field(default=None, description="The Ethernet, 10G Ethernet, ESCON, Infiniband, SONET, and other specifications supported by the transceiver.")
    temperature_thresholds: Optional[NetworkInterfacePortDetailsStaticTemperatureThresholds] = None
    tx_bias_thresholds: Optional[NetworkInterfacePortDetailsStaticTxBiasThresholds] = None
    tx_power_thresholds: Optional[NetworkInterfacePortDetailsStaticTxPowerThresholds] = None
    vendor_date_code: Optional[constr(strict=True, max_length=8)] = Field(default=None, description="The SFP vendor's manufacturing date code. The first six characters are the date in YYMMDD format, and the last two characters are the vendor specific lot code. The last two characters are optional.")
    vendor_name: Optional[constr(strict=True, max_length=16)] = Field(default=None, description="The SFP vendor name.")
    vendor_oui: Optional[constr(strict=True, max_length=8)] = Field(default=None, description="The SFP vendor IEEE company ID.")
    vendor_part_number: Optional[constr(strict=True, max_length=16)] = Field(default=None, description="The part number provided by the SFP vendor.")
    vendor_revision: Optional[constr(strict=True, max_length=4)] = Field(default=None, description="The revision level for the part number provided by the SFP vendor.")
    vendor_serial_number: Optional[constr(strict=True, max_length=16)] = Field(default=None, description="The serial number provided by the SFP vendor.")
    voltage_thresholds: Optional[NetworkInterfacePortDetailsStaticVoltageThresholds] = None
    wavelength: Optional[StrictStr] = Field(default=None, description="Laser wavelength (for optical variants) at room temperature, in units of nm. For passive and active cable variants, the value is unspecified.")
    __properties = ["cable_technology", "connector_type", "encoding", "extended_identifier", "fc_link_lengths", "fc_speeds", "fc_technology", "fc_transmission_media", "identifier", "link_length", "rate_identifier", "rx_power_thresholds", "signaling_rate", "signaling_rate_max", "signaling_rate_min", "specifications", "temperature_thresholds", "tx_bias_thresholds", "tx_power_thresholds", "vendor_date_code", "vendor_name", "vendor_oui", "vendor_part_number", "vendor_revision", "vendor_serial_number", "voltage_thresholds", "wavelength"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.to_dict(include_readonly=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.as_request_dict())

    def as_request_dict(self) -> Dict[str, Any]:
        return self.to_dict(include_readonly=False)

    def to_dict(self, include_readonly: bool=True) -> Dict[str, Any]:

        """Returns the dictionary representation of the model using alias"""
        excluded_fields: Set[str] = set()
        if not include_readonly:
            excluded_fields.update([
            ])
        none_fields: Set[str] = set()
        for _field in self.__fields__.keys():
            if super().__getattribute__(_field) is None:
                none_fields.add(_field)

        _dict = self.dict(by_alias=True, exclude=excluded_fields, exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of rx_power_thresholds
        if _include_in_dict('rx_power_thresholds', include_readonly, excluded_fields, none_fields):
            _dict['rx_power_thresholds'] = self.rx_power_thresholds.to_dict(include_readonly=include_readonly)
        # override the default output from pydantic by calling `to_dict()` of temperature_thresholds
        if _include_in_dict('temperature_thresholds', include_readonly, excluded_fields, none_fields):
            _dict['temperature_thresholds'] = self.temperature_thresholds.to_dict(include_readonly=include_readonly)
        # override the default output from pydantic by calling `to_dict()` of tx_bias_thresholds
        if _include_in_dict('tx_bias_thresholds', include_readonly, excluded_fields, none_fields):
            _dict['tx_bias_thresholds'] = self.tx_bias_thresholds.to_dict(include_readonly=include_readonly)
        # override the default output from pydantic by calling `to_dict()` of tx_power_thresholds
        if _include_in_dict('tx_power_thresholds', include_readonly, excluded_fields, none_fields):
            _dict['tx_power_thresholds'] = self.tx_power_thresholds.to_dict(include_readonly=include_readonly)
        # override the default output from pydantic by calling `to_dict()` of voltage_thresholds
        if _include_in_dict('voltage_thresholds', include_readonly, excluded_fields, none_fields):
            _dict['voltage_thresholds'] = self.voltage_thresholds.to_dict(include_readonly=include_readonly)
        return _dict

    def __getitem__(self, key):
        return super().__getattribute__(key)

    def __setitem__(self, key, value):
        setattr(self, key, value)

    def __delitem__(self, key):
        setattr(self, key, None)

    def __getattribute__(self, name: str) -> Any:
        _value = super().__getattribute__(name)
        if _value is None and name in self.__fields__.keys() and _should_raise_on_none():
            raise AttributeError
        return _value

    def __str__(self) -> str:
        return self.to_str()

    def __repr__(self) -> str:
        return self.to_str()

    @classmethod
    def from_json(cls, json_str: str) -> NetworkInterfacePortDetailsStatic:
        """Create an instance of NetworkInterfacePortDetailsStatic from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    @classmethod
    def from_dict(cls, obj: dict) -> NetworkInterfacePortDetailsStatic:
        """Create an instance of NetworkInterfacePortDetailsStatic from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return NetworkInterfacePortDetailsStatic.parse_obj(obj)

        _obj = NetworkInterfacePortDetailsStatic.construct(_fields_set=None, **{
            "cable_technology": obj.get("cable_technology"),
            "connector_type": obj.get("connector_type"),
            "encoding": obj.get("encoding"),
            "extended_identifier": obj.get("extended_identifier"),
            "fc_link_lengths": obj.get("fc_link_lengths"),
            "fc_speeds": obj.get("fc_speeds"),
            "fc_technology": obj.get("fc_technology"),
            "fc_transmission_media": obj.get("fc_transmission_media"),
            "identifier": obj.get("identifier"),
            "link_length": obj.get("link_length"),
            "rate_identifier": obj.get("rate_identifier"),
            "rx_power_thresholds": NetworkInterfacePortDetailsStaticRxPowerThresholds.from_dict(obj.get("rx_power_thresholds")) if obj.get("rx_power_thresholds") is not None else None,
            "signaling_rate": obj.get("signaling_rate"),
            "signaling_rate_max": obj.get("signaling_rate_max"),
            "signaling_rate_min": obj.get("signaling_rate_min"),
            "specifications": obj.get("specifications"),
            "temperature_thresholds": NetworkInterfacePortDetailsStaticTemperatureThresholds.from_dict(obj.get("temperature_thresholds")) if obj.get("temperature_thresholds") is not None else None,
            "tx_bias_thresholds": NetworkInterfacePortDetailsStaticTxBiasThresholds.from_dict(obj.get("tx_bias_thresholds")) if obj.get("tx_bias_thresholds") is not None else None,
            "tx_power_thresholds": NetworkInterfacePortDetailsStaticTxPowerThresholds.from_dict(obj.get("tx_power_thresholds")) if obj.get("tx_power_thresholds") is not None else None,
            "vendor_date_code": obj.get("vendor_date_code"),
            "vendor_name": obj.get("vendor_name"),
            "vendor_oui": obj.get("vendor_oui"),
            "vendor_part_number": obj.get("vendor_part_number"),
            "vendor_revision": obj.get("vendor_revision"),
            "vendor_serial_number": obj.get("vendor_serial_number"),
            "voltage_thresholds": NetworkInterfacePortDetailsStaticVoltageThresholds.from_dict(obj.get("voltage_thresholds")) if obj.get("voltage_thresholds") is not None else None,
            "wavelength": obj.get("wavelength")
        })
        return _obj

def _should_raise_on_none() -> bool:
    import importlib
    _package = importlib.import_module(__package__)
    return _package._attribute_error_on_none

def _include_in_dict(name: str, include_readonly: bool, excluded_fields: Set[str], none_fields: Set[str]) -> bool:
    if name in none_fields:
        return False
    return (include_readonly or name not in excluded_fields)


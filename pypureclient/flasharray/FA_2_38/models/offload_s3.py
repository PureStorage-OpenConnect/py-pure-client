# coding: utf-8

"""
    FlashArray REST API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 2.38
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class OffloadS3(BaseModel):
    """
    OffloadS3
    """ # noqa: E501
    access_key_id: Optional[StrictStr] = Field(default=None, description="The access key ID of the AWS account used to create a connection between the array and an Amazon S3 offload target. The access key ID is 20 characters in length and is only accepted when creating the connection between the array and the S3 offload target. The `access_key_id`, `secret_access_key`, and `bucket` parameters must be set together.")
    bucket: Optional[StrictStr] = Field(default=None, description="The name of the Amazon S3 bucket to where the data will be offloaded. Grant basic read and write ACL permissions to the bucket, and enable default (server-side) encryption for the bucket. Also verify that the bucket is empty of all objects and does not have any lifecycle policies. The `access_key_id`, `secret_access_key`, and `bucket` parameters must be set together.")
    placement_strategy: Optional[StrictStr] = Field(default=None, description="The storage placement strategy used for the dynamic placement of data in an Amazon S3 offload target. Valid values are `aws-intelligent-tiering`, `aws-standard-class`, and `retention-based`. If set to `aws-intelligent-tiering`, data is stored in the Amazon S3 INTELLIGENT_TIERING storage class regardless of the retention period. If set to `aws-standard-access`, the data is stored in the Amazon S3 STANDARD storage class regardless of the retention period. If set to `retention-based`, the data for protection groups with longer retention periods is placed in the Amazon S3 STANDARD_IA (infrequently accessed, more cost-effective) storage class. All other data is placed in the STANDARD storage class. When the array is initially connected to an S3 offload target, `placement_strategy` is automatically set to `retention-based`. The `placement_strategy` or `uri` parameter is required, but they cannot be set together.")
    secret_access_key: Optional[StrictStr] = Field(default=None, description="The secret access key that goes with the access key ID (`access_key_id`) of the AWS account. The secret access key is 40 characters in length is only accepted when creating the connection between the array and the S3 offload target. The `access_key_id`, `secret_access_key`, and `bucket` parameters must be set together.")
    uri: Optional[StrictStr] = Field(default=None, description="The URI used to create a connection between the array and a non-AWS S3 offload target. Storage placement strategies are not supported for non-AWS S3 offload targets. Both the HTTP and HTTPS protocols are allowed.")
    auth_region: Optional[StrictStr] = Field(default=None, description="The region that will be used for initial authentication request. This parameter is optional and should be used only when region autodetection fails.")
    profile: Optional[StrictStr] = Field(default=None, description="The offload target profile that will be selected for this target. This option allows more granular configuration for the target on top of the `protocol` parameter. Values include `s3-aws`, `s3-flashblade`, `s3-scality-ring`, `s3-wasabi-pay-as-you-go`, `s3-wasabi-rcs`, and `s3-other`.")
    __properties: ClassVar[List[str]] = ["access_key_id", "bucket", "placement_strategy", "secret_access_key", "uri", "auth_region", "profile"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    def to_dict(self, include_readonly: bool = False) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.

        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=set() if include_readonly else excluded_fields,
            exclude_none=True,
        )
        return _dict

    def __getitem__(self, key):
        return getattr(self, key)

    def __setitem__(self, key, value):
        setattr(self, key, value)

    def __delitem__(self, key):
        setattr(self, key, None)

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of OffloadS3 from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of OffloadS3 from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_construct(_fields_set=None, **{
            "access_key_id": obj.get("access_key_id"),
            "bucket": obj.get("bucket"),
            "placement_strategy": obj.get("placement_strategy"),
            "secret_access_key": obj.get("secret_access_key"),
            "uri": obj.get("uri"),
            "auth_region": obj.get("auth_region"),
            "profile": obj.get("profile")
        })
        return _obj



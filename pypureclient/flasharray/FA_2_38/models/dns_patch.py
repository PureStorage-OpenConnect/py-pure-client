# coding: utf-8

"""
    FlashArray REST API

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)

    OpenAPI spec version: 2.38
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re

import six
import typing

from ....properties import Property
if typing.TYPE_CHECKING:
    from pypureclient.flasharray.FA_2_38 import models

class DnsPatch(object):
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'name': 'str',
        'ca_certificate': 'ReferenceWithType',
        'ca_certificate_group': 'ReferenceWithType',
        'domain': 'str',
        'nameservers': 'list[str]',
        'services': 'list[str]',
        'source': 'ReferenceNoId'
    }

    attribute_map = {
        'name': 'name',
        'ca_certificate': 'ca_certificate',
        'ca_certificate_group': 'ca_certificate_group',
        'domain': 'domain',
        'nameservers': 'nameservers',
        'services': 'services',
        'source': 'source'
    }

    required_args = {
    }

    def __init__(
        self,
        name=None,  # type: str
        ca_certificate=None,  # type: models.ReferenceWithType
        ca_certificate_group=None,  # type: models.ReferenceWithType
        domain=None,  # type: str
        nameservers=None,  # type: List[str]
        services=None,  # type: List[str]
        source=None,  # type: models.ReferenceNoId
    ):
        """
        Keyword args:
            name (str): The new name for the resource.
            ca_certificate (ReferenceWithType): A reference to the `certificate` to use for validating nameservers with HTTPS connections. This property is mutually exclusive with `ca_certificate_group` property and may only be configured when nameservers begin with HTTPS.
            ca_certificate_group (ReferenceWithType): A reference to the `certificate group` to use for validating nameservers with HTTPS connections. This property is mutually exclusive with `ca_certificate` property and may only be configured when nameservers begin with HTTPS.
            domain (str): The domain suffix to be appended by the appliance when performing DNS lookups.
            nameservers (list[str]): The list of DNS servers either in the form of IP addresses or HTTPS endpoints. Domain names in HTTPS endpoints are not supported. IP addresses must be used instead. If nameservers begin with `https://`, then DNS queries will be performed over HTTPS. Otherwise, unencrypted DNS queries will be performed. Using a combination of nameservers that begin with `https://` and that do not begin with `https://` is not supported. If servers are specified with `https://` one of `ca_certificate` and `ca_certificate_group` parameters must be set.
            services (list[str]): The list of services utilizing the DNS configuration.
            source (ReferenceNoId): The network interface used for communication with the DNS server.
        """
        if name is not None:
            self.name = name
        if ca_certificate is not None:
            self.ca_certificate = ca_certificate
        if ca_certificate_group is not None:
            self.ca_certificate_group = ca_certificate_group
        if domain is not None:
            self.domain = domain
        if nameservers is not None:
            self.nameservers = nameservers
        if services is not None:
            self.services = services
        if source is not None:
            self.source = source

    def __setattr__(self, key, value):
        if key not in self.attribute_map:
            raise KeyError("Invalid key `{}` for `DnsPatch`".format(key))
        self.__dict__[key] = value

    def __getattribute__(self, item):
        value = object.__getattribute__(self, item)
        if isinstance(value, Property):
            raise AttributeError
        else:
            return value

    def __getitem__(self, key):
        if key not in self.attribute_map:
            raise KeyError("Invalid key `{}` for `DnsPatch`".format(key))
        return object.__getattribute__(self, key)

    def __setitem__(self, key, value):
        if key not in self.attribute_map:
            raise KeyError("Invalid key `{}` for `DnsPatch`".format(key))
        object.__setattr__(self, key, value)

    def __delitem__(self, key):
        if key not in self.attribute_map:
            raise KeyError("Invalid key `{}` for `DnsPatch`".format(key))
        object.__delattr__(self, key)

    def keys(self):
        return self.attribute_map.keys()

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            if hasattr(self, attr):
                value = getattr(self, attr)
                if isinstance(value, list):
                    result[attr] = list(map(
                        lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                        value
                    ))
                elif hasattr(value, "to_dict"):
                    result[attr] = value.to_dict()
                elif isinstance(value, dict):
                    result[attr] = dict(map(
                        lambda item: (item[0], item[1].to_dict())
                        if hasattr(item[1], "to_dict") else item,
                        value.items()
                    ))
                else:
                    result[attr] = value
        if issubclass(DnsPatch, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, DnsPatch):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other

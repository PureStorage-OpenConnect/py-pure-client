import json
import time
import urllib3
import uuid
import warnings

from typing import Any, Dict, List, Optional, Tuple, Union
from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, conint, conlist, constr, validator
from typing_extensions import Annotated

from pypureclient.reference_type import ReferenceType
from pypureclient._version import __default_user_agent__ as DEFAULT_USER_AGENT
from pypureclient.api_token_manager import APITokenManager
from pypureclient.client_settings import resolve_ssl_validation
from pypureclient.exceptions import PureError
from pypureclient.keywords import Headers, Responses
from pypureclient.properties import Property, Filter
from pypureclient.responses import ValidResponse, ErrorResponse, ApiError, ItemIterator
from pypureclient.responses import ValidResponse, ErrorResponse, ApiError, ResponseHeaders
from pypureclient.token_manager import TokenManager

from .api_client import ApiClient
from .api_response import ApiResponse
from .rest import ApiException
from .configuration import Configuration

from . import api
from . import models


class Client(object):
    DEFAULT_RETRIES = 5
    USER_AGENT = DEFAULT_USER_AGENT

    def __init__(self, target, id_token=None, private_key_file=None, private_key_password=None,
                 username=None, client_id=None, key_id=None, issuer=None, api_token=None,
                 retries=DEFAULT_RETRIES, timeout=None, ssl_cert=None,
                 user_agent=None, verify_ssl=None):
        """
        Initialize a FlashArray Client. id_token is generated based on app ID and private
        key info. Either id_token or api_token could be used for authentication. Only one
        authentication option is allowed.

        Keyword args:
            target (str, required):
                The target array's IP or hostname.
            id_token (str, optional):
                The security token that represents the identity of the party on
                behalf of whom the request is being made, issued by an enabled
                API client on the array. Overrides given private key.
            private_key_file (str, optional):
                The path of the private key to use. Defaults to None.
            private_key_password (str, optional):
                The password of the private key. Defaults to None.
            username (str, optional):
                Username of the user the token should be issued for. This must
                be a valid user in the system.
            client_id (str, optional):
                ID of API client that issued the identity token.
            key_id (str, optional):
                Key ID of API client that issued the identity token.
            issuer (str, optional):
                API client's trusted identity issuer on the array.
            api_token (str, optional):
                API token for the user.
            retries (int, optional):
                The number of times to retry an API call if it fails for a
                non-blocking reason. Defaults to 5.
            timeout int or (float, float), optional:
                The timeout duration in seconds, either in total time or
                (connect and read) times. Defaults to None.
            ssl_cert (str, optional):
                SSL certificate to use. Defaults to None.
            user_agent (str, optional):
                User-Agent request header to use.
            verify_ssl (bool | str, optional):
                Controls SSL certificate validation.
                `True` specifies that the server validation uses default trust anchors;
                `False` switches certificate validation off, **not safe!**;
                It also accepts string value for a path to directory with certificates.

        Raises:
            PureError: If it could not create an ID or access token
        """
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        config = Configuration()
        config.verify_ssl = resolve_ssl_validation(verify_ssl)
        config.ssl_ca_cert = ssl_cert
        config.host = self._get_base_url(target)

        effective_user_agent = user_agent or self.USER_AGENT

        if id_token and api_token:
            raise PureError("Only one authentication option is allowed. Please use either id_token or api_token and try again!")
        elif private_key_file and private_key_password and username and \
                key_id and client_id and issuer and api_token:
            raise PureError("id_token is generated based on app ID and private key info. Please use either id_token or api_token and try again!")
        elif api_token:
            api_token_auth_endpoint = self._get_api_token_endpoint(target)
            api_token_dispose_endpoint = self._get_api_token_dispose_endpoint(target)
            self._token_man = APITokenManager(
                api_token_auth_endpoint,
                api_token,
                verify_ssl=config.verify_ssl,
                token_dispose_endpoint=api_token_dispose_endpoint,
                user_agent=effective_user_agent
            )
        else:
            auth_endpoint = 'https://{}/oauth2/1.0/token'.format(target)
            headers = {
                'kid': key_id
            }
            payload = {
                'iss': issuer,
                'aud': client_id,
                'sub': username,
            }
            self._token_man = TokenManager(auth_endpoint, id_token, private_key_file, private_key_password,
                                           payload=payload, headers=headers, verify_ssl=config.verify_ssl)

        self._api_client = ApiClient(configuration=config)
        self._api_client.user_agent = effective_user_agent
        self._set_agent_header()
        self._set_auth_header()

        # Read timeout and retries
        self._retries = retries
        self._timeout = timeout
        self.__apis_instances = {}

    def __del__(self):
        # Cleanup this REST API client resources
        _api_client_attr = getattr(self, '_api_client', None) # using getattr to avoid raising exception, if we failed too early
        if _api_client_attr:
            _api_client_attr.close()

    def get_rest_version(self):
        """Get the REST API version being used by this client.

        Returns:
            str

        """
        return '2.32'

    def get_access_token(self, refresh=False):
        """
        Get the last used access token.

        Args:
            refresh (bool, optional):
                Whether to retrieve a new access token. Defaults to False.

        Returns:
            str

        Raises:
            PureError: If there was an error retrieving an access token.
        """
        return self._token_man.get_access_token(refresh)

    def delete_api_clients(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete an API client  # noqa: E501
        
        Deletes an API client. The `ids` or `names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_api_clients_delete_with_http_info(authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('APIClientsApi', 'api232_api_clients_delete_with_http_info', kwargs)

    def get_api_clients(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List API clients  # noqa: E501
        
        Returns a list of API clients.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_api_clients_get_with_http_info(authorization, x_request_id, filter, ids, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('APIClientsApi', 'api232_api_clients_get_with_http_info', kwargs)

    def patch_api_clients(
        self,
        api_clients: 'models.ApiClientPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Manage an API client  # noqa: E501
        
        Enables or disables an API client. The `ids` or `names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_api_clients_patch_with_http_info(api_clients, authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param api_clients: (required)
        :type api_clients: models.ApiClientPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            api_clients=api_clients,
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('APIClientsApi', 'api232_api_clients_patch_with_http_info', kwargs)

    def post_api_clients(
        self,
        api_clients: 'models.ApiClientPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create an API client  # noqa: E501
        
        Creates an API client. Newly created API clients are disabled by default. Enable an API client through the `PATCH` method. The `names`, `max_role`, `issuer`, and `public_key` parameters are required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_api_clients_post_with_http_info(api_clients, authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param api_clients: (required)
        :type api_clients: models.ApiClientPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            api_clients=api_clients,
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('APIClientsApi', 'api232_api_clients_post_with_http_info', kwargs)

    def delete_active_directory(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="Performs the operation on the unique name specified. For example, `name01`. Enter multiple names in comma-separated format.")],
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        local_only: Annotated[Optional[StrictBool], Field(description="If specified as `true`, only delete the Active Directory configuration on the local array, without deleting the computer account created in the Active Directory domain. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete Active Directory account  # noqa: E501
        
        Deletes one or more specified Active Directory accounts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_active_directory_delete_with_http_info(names, authorization, x_request_id, local_only, async_req=True)
        >>> result = thread.get()
        
        :param names: Performs the operation on the unique name specified. For example, `name01`.
                    Enter multiple names in comma-separated format. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param local_only: If specified as `true`, only delete the Active Directory configuration on the
                        local array, without deleting the computer account created in the Active
                        Directory domain. If not specified, defaults to `false`.
        :type local_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            authorization=authorization,
            x_request_id=x_request_id,
            local_only=local_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('ActiveDirectoryApi', 'api232_active_directory_delete_with_http_info', kwargs)

    def get_active_directory(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List Active Directory accounts  # noqa: E501
        
        Displays configured Active Directory accounts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_active_directory_get_with_http_info(authorization, x_request_id, continuation_token, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('ActiveDirectoryApi', 'api232_active_directory_get_with_http_info', kwargs)

    def patch_active_directory(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="Performs the operation on the unique name specified. For example, `name01`. Enter multiple names in comma-separated format.")],
        active_directory: 'models.ActiveDirectoryPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify Active Directory account  # noqa: E501
        
        Modifies specified Active Directory account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_active_directory_patch_with_http_info(names, active_directory, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param names: Performs the operation on the unique name specified. For example, `name01`.
                    Enter multiple names in comma-separated format. (required)
        :type names: List[str]
        :param active_directory: (required)
        :type active_directory: models.ActiveDirectoryPatch
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            active_directory=active_directory,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('ActiveDirectoryApi', 'api232_active_directory_patch_with_http_info', kwargs)

    def post_active_directory(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="Performs the operation on the unique name specified. For example, `name01`. Enter multiple names in comma-separated format.")],
        active_directory: 'models.ActiveDirectoryPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        join_existing_account: Annotated[Optional[StrictBool], Field(description="If specified as `true`, the domain is searched for a pre-existing computer account to join to, and no new account will be created within the domain. The `user` specified when joining a pre-existing account must have permissions to 'read all properties from' and 'reset the password of' the pre-existing account. `join_ou` will be read from the pre-existing account and cannot be specified when joining to an existing account. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create Active Directory account  # noqa: E501
        
        Creates one or more Active Directory accounts. The `user` and `password` provided are used to join the array to the specified `domain`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_active_directory_post_with_http_info(names, active_directory, authorization, x_request_id, join_existing_account, async_req=True)
        >>> result = thread.get()
        
        :param names: Performs the operation on the unique name specified. For example, `name01`.
                    Enter multiple names in comma-separated format. (required)
        :type names: List[str]
        :param active_directory: (required)
        :type active_directory: models.ActiveDirectoryPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param join_existing_account: If specified as `true`, the domain is searched for a pre-existing computer
                                    account to join to, and no new account will be created within the domain.
                                    The `user` specified when joining a pre-existing account must have
                                    permissions to 'read all properties from' and 'reset the password of' the
                                    pre-existing account. `join_ou` will be read from the pre-existing
                                    account and cannot be specified when joining to an existing account. If
                                    not specified, defaults to `false`.
        :type join_existing_account: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            active_directory=active_directory,
            authorization=authorization,
            x_request_id=x_request_id,
            join_existing_account=join_existing_account,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('ActiveDirectoryApi', 'api232_active_directory_post_with_http_info', kwargs)

    def delete_admins_api_tokens(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete API tokens  # noqa: E501
        
        Deletes the API tokens of the specified administrators.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_admins_api_tokens_delete_with_http_info(authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('AdministratorsApi', 'api232_admins_api_tokens_delete_with_http_info', kwargs)

    def get_admins_api_tokens(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        expose_api_token: Annotated[Optional[StrictBool], Field(description="If `true`, exposes the API token of the current user.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List API tokens  # noqa: E501
        
        Displays API tokens for the specified administrators.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_admins_api_tokens_get_with_http_info(authorization, x_request_id, continuation_token, expose_api_token, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param expose_api_token: If `true`, exposes the API token of the current user.
        :type expose_api_token: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            expose_api_token=expose_api_token,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('AdministratorsApi', 'api232_admins_api_tokens_get_with_http_info', kwargs)

    def post_admins_api_tokens(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        timeout: Annotated[Optional[StrictInt], Field(description="The duration of API token validity, in milliseconds.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create API tokens  # noqa: E501
        
        Creates API tokens for the specified administrators.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_admins_api_tokens_post_with_http_info(authorization, x_request_id, names, timeout, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param timeout: The duration of API token validity, in milliseconds.
        :type timeout: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            timeout=timeout,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('AdministratorsApi', 'api232_admins_api_tokens_post_with_http_info', kwargs)

    def delete_admins_cache(
        self,
        remove_all_entries: Annotated[StrictBool, Field(..., description="If set to `true`, removes all entries from the administrator cache.")],
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete cache entries  # noqa: E501
        
        Deletes all entries from the administrator cache.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_admins_cache_delete_with_http_info(remove_all_entries, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param remove_all_entries: If set to `true`, removes all entries from the administrator cache. (required)
        :type remove_all_entries: bool
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            remove_all_entries=remove_all_entries,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('AdministratorsApi', 'api232_admins_cache_delete_with_http_info', kwargs)

    def get_admins_cache(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List administrator cache entries  # noqa: E501
        
        Displays entries in the administrator cache.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_admins_cache_get_with_http_info(authorization, x_request_id, continuation_token, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('AdministratorsApi', 'api232_admins_cache_get_with_http_info', kwargs)

    def put_admins_cache(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Update or refresh entries in the administrator cache  # noqa: E501
        
        Updates entries in the cache for administrators who currently do not have a cache entry, otherwise refreshes the existing entry.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_admins_cache_put_with_http_info(authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('AdministratorsApi', 'api232_admins_cache_put_with_http_info', kwargs)

    def delete_admins(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete an administrator  # noqa: E501
        
        Deletes the specified administrator.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_admins_delete_with_http_info(authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('AdministratorsApi', 'api232_admins_delete_with_http_info', kwargs)

    def get_admins(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        expose_api_token: Annotated[Optional[StrictBool], Field(description="If `true`, exposes the API token of the current user.")] = None,
        expose_public_key: Annotated[Optional[StrictBool], Field(description="If `true`, exposes the public key of the current user.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List administrators  # noqa: E501
        
        Displays a list of administrators.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_admins_get_with_http_info(authorization, x_request_id, continuation_token, expose_api_token, expose_public_key, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param expose_api_token: If `true`, exposes the API token of the current user.
        :type expose_api_token: bool
        :param expose_public_key: If `true`, exposes the public key of the current user.
        :type expose_public_key: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            expose_api_token=expose_api_token,
            expose_public_key=expose_public_key,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('AdministratorsApi', 'api232_admins_get_with_http_info', kwargs)

    def patch_admins(
        self,
        admin: 'models.AdminPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify an administrator  # noqa: E501
        
        Modifies properties for the specified administrator.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_admins_patch_with_http_info(admin, authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param admin: (required)
        :type admin: models.AdminPatch
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            admin=admin,
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('AdministratorsApi', 'api232_admins_patch_with_http_info', kwargs)

    def post_admins(
        self,
        admin: 'models.AdminPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create an administrator  # noqa: E501
        
        Creates an administrator.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_admins_post_with_http_info(admin, authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param admin: (required)
        :type admin: models.AdminPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            admin=admin,
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('AdministratorsApi', 'api232_admins_post_with_http_info', kwargs)

    def get_admins_settings(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List administrator settings  # noqa: E501
        
        Displays the global administrator settings for the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_admins_settings_get_with_http_info(authorization, x_request_id, filter, limit, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('AdministratorsApi', 'api232_admins_settings_get_with_http_info', kwargs)

    def patch_admins_settings(
        self,
        admin_settings: 'models.AdminSettings',
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify administrator settings  # noqa: E501
        
        Modifies the global administrator settings for the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_admins_settings_patch_with_http_info(admin_settings, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param admin_settings: (required)
        :type admin_settings: models.AdminSettings
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            admin_settings=admin_settings,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('AdministratorsApi', 'api232_admins_settings_patch_with_http_info', kwargs)

    def delete_alert_watchers(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="Performs the operation on the unique name specified. For example, `name01`. Enter multiple names in comma-separated format.")],
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete alert watcher  # noqa: E501
        
        Delete alert watcher email address from the list of alert watchers.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_alert_watchers_delete_with_http_info(names, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param names: Performs the operation on the unique name specified. For example, `name01`.
                    Enter multiple names in comma-separated format. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('AlertWatchersApi', 'api232_alert_watchers_delete_with_http_info', kwargs)

    def get_alert_watchers(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List alert watchers  # noqa: E501
        
        Displays alert watcher email addressess and indicates whether they are `enabled`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_alert_watchers_get_with_http_info(authorization, x_request_id, continuation_token, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('AlertWatchersApi', 'api232_alert_watchers_get_with_http_info', kwargs)

    def patch_alert_watchers(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="Performs the operation on the unique name specified. For example, `name01`. Enter multiple names in comma-separated format.")],
        alert_watcher: 'models.AlertWatcherPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify alert watcher  # noqa: E501
        
        Modify alert watcher email address by enabling or disabling it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_alert_watchers_patch_with_http_info(names, alert_watcher, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param names: Performs the operation on the unique name specified. For example, `name01`.
                    Enter multiple names in comma-separated format. (required)
        :type names: List[str]
        :param alert_watcher: (required)
        :type alert_watcher: models.AlertWatcherPatch
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            alert_watcher=alert_watcher,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('AlertWatchersApi', 'api232_alert_watchers_patch_with_http_info', kwargs)

    def post_alert_watchers(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="Performs the operation on the unique name specified. For example, `name01`. Enter multiple names in comma-separated format.")],
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        alert_watcher: Optional['models.AlertWatcherPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create alert watcher  # noqa: E501
        
        Creates one or more alert watcher email addresses, adding them to the list of alert watchers.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_alert_watchers_post_with_http_info(names, authorization, x_request_id, alert_watcher, async_req=True)
        >>> result = thread.get()
        
        :param names: Performs the operation on the unique name specified. For example, `name01`.
                    Enter multiple names in comma-separated format. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param alert_watcher:
        :type alert_watcher: AlertWatcherPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            authorization=authorization,
            x_request_id=x_request_id,
            alert_watcher=alert_watcher,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('AlertWatchersApi', 'api232_alert_watchers_post_with_http_info', kwargs)

    def get_alert_watchers_test(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List alert watcher test  # noqa: E501
        
        Displays alert watcher email test results.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_alert_watchers_test_get_with_http_info(authorization, x_request_id, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('AlertWatchersApi', 'api232_alert_watchers_test_get_with_http_info', kwargs)

    def get_alerts_events(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        flagged: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only flagged messages. If set to `false`, lists only unflagged messages. if not specified, lists all messages.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. For example, `name01`. Enter multiple names in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List alert events  # noqa: E501
        
        Displays a list of alert events.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_alerts_events_get_with_http_info(authorization, x_request_id, continuation_token, filter, flagged, ids, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param flagged: If set to `true`, lists only flagged messages. If set to `false`, lists only
                        unflagged messages. if not specified, lists all messages.
        :type flagged: bool
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. For example, `name01`.
                    Enter multiple names in comma-separated format. The `ids` or `names`
                    parameter is required, but they cannot be set together.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            flagged=flagged,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('AlertsApi', 'api232_alerts_events_get_with_http_info', kwargs)

    def get_alerts(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        flagged: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only flagged messages. If set to `false`, lists only unflagged messages. if not specified, lists all messages.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List alerts  # noqa: E501
        
        Displays a list of alerts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_alerts_get_with_http_info(authorization, x_request_id, continuation_token, filter, flagged, ids, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param flagged: If set to `true`, lists only flagged messages. If set to `false`, lists only
                        unflagged messages. if not specified, lists all messages.
        :type flagged: bool
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            flagged=flagged,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('AlertsApi', 'api232_alerts_get_with_http_info', kwargs)

    def patch_alerts(
        self,
        alert: 'models.Alert',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify flagged state  # noqa: E501
        
        Modifies one or more alerts and display updated information about these alerts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_alerts_patch_with_http_info(alert, authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param alert: (required)
        :type alert: models.Alert
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            alert=alert,
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('AlertsApi', 'api232_alerts_patch_with_http_info', kwargs)

    def get_alerts_rules_catalog(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        code: Annotated[Optional[StrictInt], Field(description="The alert code to display.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List available customizable alert codes  # noqa: E501
        
        Displays a list of available customizable alert codes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_alerts_rules_catalog_get_with_http_info(authorization, x_request_id, code, filter, limit, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param code: The alert code to display.
        :type code: int
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            code=code,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('AlertsApi', 'api232_alerts_rules_catalog_get_with_http_info', kwargs)

    def delete_alerts_rules(
        self,
        code: Annotated[StrictInt, Field(..., description="The alert code that the rule applies to. Available alert codes for customization can be found in the alert rules catalog.")],
        parameter: Annotated[StrictStr, Field(..., description="The parameter of the custom alert rule to modify. Values include `info` and `warning`. Available parameter values can be found in the alert rules catalog.")],
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a custom alert rule  # noqa: E501
        
        Deletes a custom alert rule.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_alerts_rules_delete_with_http_info(code, parameter, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param code: The alert code that the rule applies to. Available alert codes for customization
                    can be found in the alert rules catalog. (required)
        :type code: int
        :param parameter: The parameter of the custom alert rule to modify. Values include `info` and
                        `warning`. Available parameter values can be found in the alert rules
                        catalog. (required)
        :type parameter: str
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            code=code,
            parameter=parameter,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('AlertsApi', 'api232_alerts_rules_delete_with_http_info', kwargs)

    def get_alerts_rules(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        code: Annotated[Optional[StrictInt], Field(description="The alert code to display.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List custom alert rules  # noqa: E501
        
        Displays a list of custom alert rules.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_alerts_rules_get_with_http_info(authorization, x_request_id, code, filter, limit, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param code: The alert code to display.
        :type code: int
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            code=code,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('AlertsApi', 'api232_alerts_rules_get_with_http_info', kwargs)

    def patch_alerts_rules(
        self,
        code: Annotated[StrictInt, Field(..., description="The alert code that the rule applies to. Available alert codes for customization can be found in the alert rules catalog.")],
        parameter: Annotated[StrictStr, Field(..., description="The parameter of the custom alert rule to modify. Values include `info` and `warning`. Available parameter values can be found in the alert rules catalog.")],
        alert_rule: 'models.AlertRules',
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify a custom alert rule  # noqa: E501
        
        Modifies a custom alert rule to a new value.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_alerts_rules_patch_with_http_info(code, parameter, alert_rule, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param code: The alert code that the rule applies to. Available alert codes for customization
                    can be found in the alert rules catalog. (required)
        :type code: int
        :param parameter: The parameter of the custom alert rule to modify. Values include `info` and
                        `warning`. Available parameter values can be found in the alert rules
                        catalog. (required)
        :type parameter: str
        :param alert_rule: (required)
        :type alert_rule: models.AlertRules
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            code=code,
            parameter=parameter,
            alert_rule=alert_rule,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('AlertsApi', 'api232_alerts_rules_patch_with_http_info', kwargs)

    def post_alerts_rules(
        self,
        code: Annotated[StrictInt, Field(..., description="The alert code that the rule applies to. Available alert codes for customization can be found in the alert rules catalog.")],
        parameter: Annotated[StrictStr, Field(..., description="The parameter of the custom alert rule to modify. Values include `info` and `warning`. Available parameter values can be found in the alert rules catalog.")],
        alert_rule: 'models.AlertRules',
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a custom alert rule  # noqa: E501
        
        Creates an alert rule with a custom value.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_alerts_rules_post_with_http_info(code, parameter, alert_rule, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param code: The alert code that the rule applies to. Available alert codes for customization
                    can be found in the alert rules catalog. (required)
        :type code: int
        :param parameter: The parameter of the custom alert rule to modify. Values include `info` and
                        `warning`. Available parameter values can be found in the alert rules
                        catalog. (required)
        :type parameter: str
        :param alert_rule: (required)
        :type alert_rule: models.AlertRules
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            code=code,
            parameter=parameter,
            alert_rule=alert_rule,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('AlertsApi', 'api232_alerts_rules_post_with_http_info', kwargs)

    def get_apps(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List apps  # noqa: E501
        
        Displays a list of installed apps.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_apps_get_with_http_info(authorization, x_request_id, continuation_token, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('AppsApi', 'api232_apps_get_with_http_info', kwargs)

    def get_apps_nodes(
        self,
        apps: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        app_names: Annotated[Optional[conlist(StrictStr)], Field(description="The name of the installed app. Enter multiple names in comma-separated format.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List app nodes  # noqa: E501
        
        Displays a list of installed apps and their nodes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_apps_nodes_get_with_http_info(authorization, x_request_id, app_names, continuation_token, filter, limit, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param apps: A list of apps to query for. Overrides app_names keyword argument.
        :type apps: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param app_names: The name of the installed app. Enter multiple names in comma-separated format.
        :type app_names: List[str]
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            app_names=app_names,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(apps, ['app_names'], kwargs)
        _fixup_list_type_params(['app_names', 'sort'], kwargs)
        return self._call_api('AppsApi', 'api232_apps_nodes_get_with_http_info', kwargs)

    def patch_apps(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="Performs the operation on the unique name specified. For example, `name01`. Enter multiple names in comma-separated format.")],
        app: 'models.App',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify app  # noqa: E501
        
        Modifies an installed app or modifies Virtual Network Computing (VNC) access for apps that are being patched.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_apps_patch_with_http_info(names, app, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param names: Performs the operation on the unique name specified. For example, `name01`.
                    Enter multiple names in comma-separated format. (required)
        :type names: List[str]
        :param app: (required)
        :type app: models.App
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            app=app,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('AppsApi', 'api232_apps_patch_with_http_info', kwargs)

    def get_array_connections_connection_key(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List connection key  # noqa: E501
        
        Displays the connection key for the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_array_connections_connection_key_get_with_http_info(authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api232_array_connections_connection_key_get_with_http_info', kwargs)

    def delete_array_connections(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete an array connection  # noqa: E501
        
        Deletes the connection to the current array from the specified array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_array_connections_delete_with_http_info(authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api232_array_connections_delete_with_http_info', kwargs)

    def get_array_connections(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List connected arrays  # noqa: E501
        
        Display a list of connected arrays.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_array_connections_get_with_http_info(authorization, x_request_id, continuation_token, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api232_array_connections_get_with_http_info', kwargs)

    def patch_array_connections(
        self,
        array_connection: 'models.Throttle',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify an array connection  # noqa: E501
        
        Modifies the bandwidth throttling attributes for a connected array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_array_connections_patch_with_http_info(array_connection, authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param array_connection: (required)
        :type array_connection: models.Throttle
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            array_connection=array_connection,
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api232_array_connections_patch_with_http_info', kwargs)

    def get_array_connections_path(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List connection path  # noqa: E501
        
        Displays the connection path from the array where the connection was made.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_array_connections_path_get_with_http_info(authorization, x_request_id, continuation_token, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api232_array_connections_path_get_with_http_info', kwargs)

    def post_array_connections(
        self,
        array_connection: 'models.ArrayConnectionPost',
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create an array connection  # noqa: E501
        
        Creates a connection between the current array and the specified array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_array_connections_post_with_http_info(array_connection, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param array_connection: (required)
        :type array_connection: models.ArrayConnectionPost
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            array_connection=array_connection,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api232_array_connections_post_with_http_info', kwargs)

    def get_arrays_cloud_capacity(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List CBS array capacity status  # noqa: E501
        
        Displays the capacity status of the CBS array including the progress of the capacity update. Requests for non-CBS arrays will receive an error response.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_arrays_cloud_capacity_get_with_http_info(authorization, x_request_id, filter, limit, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('ArraysApi', 'api232_arrays_cloud_capacity_get_with_http_info', kwargs)

    def patch_arrays_cloud_capacity(
        self,
        capacity: Annotated['models.CloudCapacityStatus', Field(..., description="The requested capacity of the CBS array.")],
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify CBS array capacity  # noqa: E501
        
        Modifies the raw capacity of the CBS array. This should trigger a backend process that will update the CBS array capacity. The array capacity can be updated only to values defined by the capacity steps endpoint. When an existing capacity update request is in progress, any new request to update of the capacity will receive an error response. For non-CBS arrays, this feature is not supported and requests will receive an error response.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_arrays_cloud_capacity_patch_with_http_info(capacity, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param capacity: The requested capacity of the CBS array. (required)
        :type capacity: models.CloudCapacityStatus
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            capacity=capacity,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api232_arrays_cloud_capacity_patch_with_http_info', kwargs)

    def get_arrays_cloud_capacity_supported_steps(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List CBS array capacity steps  # noqa: E501
        
        Displays the list of supported raw capacity sizes in bytes the CBS array can be upgraded to. Requests for non-CBS arrays will receive an error response.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_arrays_cloud_capacity_supported_steps_get_with_http_info(authorization, x_request_id, continuation_token, filter, limit, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('ArraysApi', 'api232_arrays_cloud_capacity_supported_steps_get_with_http_info', kwargs)

    def put_arrays_cloud_provider_tags_batch(
        self,
        tag: Annotated[conlist('models.CloudProviderTag', max_items=50, min_items=1, unique_items=True), Field(..., description="A list of tags to be created or, if already existing, updated.")],
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Update user tags on the cloud.  # noqa: E501
        
        Updates users tags to deployed cloud resources of a CBS array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_arrays_cloud_provider_tags_batch_put_with_http_info(tag, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param tag: A list of tags to be created or, if already existing, updated. (required)
        :type tag: List[models.CloudProviderTag]
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            tag=tag,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params(['tag'], kwargs)
        return self._call_api('ArraysApi', 'api232_arrays_cloud_provider_tags_batch_put_with_http_info', kwargs)

    def delete_arrays_cloud_provider_tags(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        keys: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of tag keys.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete user tags from the cloud.  # noqa: E501
        
        Deletes user tags from deployed cloud resources of a CBS array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_arrays_cloud_provider_tags_delete_with_http_info(authorization, x_request_id, keys, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param keys: A comma-separated list of tag keys.
        :type keys: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            keys=keys,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params(['keys'], kwargs)
        return self._call_api('ArraysApi', 'api232_arrays_cloud_provider_tags_delete_with_http_info', kwargs)

    def get_arrays_cloud_provider_tags(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List user tags on the cloud.  # noqa: E501
        
        Displays the list of user tags on deployed cloud resources of a CBS array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_arrays_cloud_provider_tags_get_with_http_info(authorization, x_request_id, continuation_token, filter, limit, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('ArraysApi', 'api232_arrays_cloud_provider_tags_get_with_http_info', kwargs)

    def delete_arrays(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        eradicate_all_data: Annotated[Optional[StrictBool], Field(description="Set to `true` to perform a factory reset.")] = None,
        factory_reset_token: Annotated[Optional[StrictInt], Field(description="A token required to perform a factory reset.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete an array  # noqa: E501
        
        Deletes an array. For physical appliances, deleting an array restores the hardware to factory settings. This entails deleting all data, metadata, configuration, and logs. The array returns to the state it was in prior to any configuration changes being made. If the hardware is reused, it must be as a different array with a new ID. For virtual appliances, deleting an array puts it into an unusable state. Virtual resources (e.g., virtual machines) can later be freed, which deletes any remaining data, metadata, configuration, and logs. Prior to factory reset, an array must be manually prepared (e.g., all volumes and snapshots must be eradicated) and a factory reset token must be created.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_arrays_delete_with_http_info(authorization, x_request_id, eradicate_all_data, factory_reset_token, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param eradicate_all_data: Set to `true` to perform a factory reset.
        :type eradicate_all_data: bool
        :param factory_reset_token: A token required to perform a factory reset.
        :type factory_reset_token: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            eradicate_all_data=eradicate_all_data,
            factory_reset_token=factory_reset_token,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api232_arrays_delete_with_http_info', kwargs)

    def get_arrays_eula(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List End User Agreement and signature  # noqa: E501
        
        Displays the End User Agreement and signature.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_arrays_eula_get_with_http_info(authorization, x_request_id, filter, limit, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('ArraysApi', 'api232_arrays_eula_get_with_http_info', kwargs)

    def patch_arrays_eula(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        eula: Optional['models.Eula'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify signature on the End User Agreement  # noqa: E501
        
        Modifies the signature on the End User Agreement.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_arrays_eula_patch_with_http_info(authorization, x_request_id, eula, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param eula:
        :type eula: Eula
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            eula=eula,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api232_arrays_eula_patch_with_http_info', kwargs)

    def delete_arrays_factory_reset_token(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a factory reset token  # noqa: E501
        
        Deletes an existing token that could be used to perform a factory reset on the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_arrays_factory_reset_token_delete_with_http_info(authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api232_arrays_factory_reset_token_delete_with_http_info', kwargs)

    def get_arrays_factory_reset_token(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List factory reset tokens  # noqa: E501
        
        Displays a list of tokens used to perform a factory reset on the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_arrays_factory_reset_token_get_with_http_info(authorization, x_request_id, filter, limit, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('ArraysApi', 'api232_arrays_factory_reset_token_get_with_http_info', kwargs)

    def post_arrays_factory_reset_token(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a factory reset token  # noqa: E501
        
        Creates a token that can be used to perform a factory reset on the array. Factory reset tokens can only be created after the array has been prepared for reset (e.g., all volumes and snapshots must first be eradicated). After a token has been created, operations that would take the array out of the prepared state are disabled (e.g., creating volumes) until all tokens have been deleted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_arrays_factory_reset_token_post_with_http_info(authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api232_arrays_factory_reset_token_post_with_http_info', kwargs)

    def get_arrays(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List arrays  # noqa: E501
        
        Displays general array properties including the array name, login banner, idle timeout for management sessions, and NTP servers.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_arrays_get_with_http_info(authorization, x_request_id, filter, limit, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('ArraysApi', 'api232_arrays_get_with_http_info', kwargs)

    def get_arrays_ntp_test(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List NTP test results  # noqa: E501
        
        Displays test results for configured NTP servers.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_arrays_ntp_test_get_with_http_info(authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api232_arrays_ntp_test_get_with_http_info', kwargs)

    def patch_arrays(
        self,
        array: 'models.Arrays',
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify an array  # noqa: E501
        
        Modifies general array properties such as the array name, login banner, idle timeout for management sessions, and NTP servers.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_arrays_patch_with_http_info(array, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param array: (required)
        :type array: models.Arrays
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            array=array,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api232_arrays_patch_with_http_info', kwargs)

    def get_arrays_performance_by_link(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The number of milliseconds between samples of historical data. For array-wide performance metrics (`/arrays/performance` endpoint), valid values are `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For performance metrics on storage objects (`<object name>/performance` endpoint), such as volumes, valid values are `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For space metrics, (`<object name>/space` endpoint), valid values are `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). Include the `start_time` parameter to display the performance data starting at the specified start time. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. Include the `end_time` parameter to display the performance data until the specified end time. If `end_time`is not specified, the end time will default to the current time. If the `resolution` parameter is not specified but either the `start_time` or `end_time` parameter is, then `resolution` will default to the lowest valid resolution.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List array front-end IO performance data by link  # noqa: E501
        
        Displays real-time and historical front-end performance data at the array level including latency, bandwidth, IOPS, average I/O size, and queue depth. Group output is shown by link. A link represents a set of arrays that an I/O operation depends on. For local-only I/Os, this is a local array. For mirrored I/Os, this is a set of synchronous replication peer arrays.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_arrays_performance_by_link_get_with_http_info(authorization, x_request_id, end_time, filter, limit, offset, resolution, sort, start_time, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param end_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type end_time: int
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param resolution: The number of milliseconds between samples of historical data. For array-wide
                        performance metrics (`/arrays/performance` endpoint), valid values are
                        `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30
                        minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24
                        hours). For performance metrics on storage objects (`<object
                        name>/performance` endpoint), such as volumes, valid values are `30000` (30
                        seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours),
                        `28800000` (8 hours), and `86400000` (24 hours). For space metrics,
                        (`<object name>/space` endpoint), valid values are `300000` (5 minutes),
                        `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and
                        `86400000` (24 hours). Include the `start_time` parameter to display the
                        performance data starting at the specified start time. If `start_time` is
                        not specified, the start time will default to one resolution before the end
                        time, meaning that the most recent sample of performance data will be
                        displayed. Include the `end_time` parameter to display the performance data
                        until the specified end time. If `end_time`is not specified, the end time
                        will default to the current time. If the `resolution` parameter is not
                        specified but either the `start_time` or `end_time` parameter is, then
                        `resolution` will default to the lowest valid resolution.
        :type resolution: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param start_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type start_time: int
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            end_time=end_time,
            filter=filter,
            limit=limit,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('ArraysApi', 'api232_arrays_performance_by_link_get_with_http_info', kwargs)

    def get_arrays_performance(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        protocol: Annotated[Optional[StrictStr], Field(description="Protocol type. Valid values are `nfs`, `smb`, and `all`.")] = None,
        protocol_group: Annotated[Optional[StrictStr], Field(description="Protocol group type. Valid values are `block`, `file`, and `all`.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The number of milliseconds between samples of historical data. For array-wide performance metrics (`/arrays/performance` endpoint), valid values are `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For performance metrics on storage objects (`<object name>/performance` endpoint), such as volumes, valid values are `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For space metrics, (`<object name>/space` endpoint), valid values are `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). Include the `start_time` parameter to display the performance data starting at the specified start time. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. Include the `end_time` parameter to display the performance data until the specified end time. If `end_time`is not specified, the end time will default to the current time. If the `resolution` parameter is not specified but either the `start_time` or `end_time` parameter is, then `resolution` will default to the lowest valid resolution.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List array front-end performance data  # noqa: E501
        
        Displays real-time and historical front-end performance data at the array level including latency, bandwidth, IOPS, average I/O size, and queue depth.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_arrays_performance_get_with_http_info(authorization, x_request_id, end_time, filter, limit, offset, protocol, protocol_group, resolution, sort, start_time, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param end_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type end_time: int
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param protocol: Protocol type. Valid values are `nfs`, `smb`, and `all`.
        :type protocol: str
        :param protocol_group: Protocol group type. Valid values are `block`, `file`, and `all`.
        :type protocol_group: str
        :param resolution: The number of milliseconds between samples of historical data. For array-wide
                        performance metrics (`/arrays/performance` endpoint), valid values are
                        `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30
                        minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24
                        hours). For performance metrics on storage objects (`<object
                        name>/performance` endpoint), such as volumes, valid values are `30000` (30
                        seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours),
                        `28800000` (8 hours), and `86400000` (24 hours). For space metrics,
                        (`<object name>/space` endpoint), valid values are `300000` (5 minutes),
                        `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and
                        `86400000` (24 hours). Include the `start_time` parameter to display the
                        performance data starting at the specified start time. If `start_time` is
                        not specified, the start time will default to one resolution before the end
                        time, meaning that the most recent sample of performance data will be
                        displayed. Include the `end_time` parameter to display the performance data
                        until the specified end time. If `end_time`is not specified, the end time
                        will default to the current time. If the `resolution` parameter is not
                        specified but either the `start_time` or `end_time` parameter is, then
                        `resolution` will default to the lowest valid resolution.
        :type resolution: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param start_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type start_time: int
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            end_time=end_time,
            filter=filter,
            limit=limit,
            offset=offset,
            protocol=protocol,
            protocol_group=protocol_group,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('ArraysApi', 'api232_arrays_performance_get_with_http_info', kwargs)

    def get_arrays_space(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The number of milliseconds between samples of historical data. For array-wide performance metrics (`/arrays/performance` endpoint), valid values are `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For performance metrics on storage objects (`<object name>/performance` endpoint), such as volumes, valid values are `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For space metrics, (`<object name>/space` endpoint), valid values are `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). Include the `start_time` parameter to display the performance data starting at the specified start time. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. Include the `end_time` parameter to display the performance data until the specified end time. If `end_time`is not specified, the end time will default to the current time. If the `resolution` parameter is not specified but either the `start_time` or `end_time` parameter is, then `resolution` will default to the lowest valid resolution.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List array space information  # noqa: E501
        
        Displays real-time and historical array space information including unique volume and snapshot space, shared space, data reduction, provisioned capacity, usable capacity, and parity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_arrays_space_get_with_http_info(authorization, x_request_id, end_time, filter, limit, offset, resolution, sort, start_time, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param end_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type end_time: int
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param resolution: The number of milliseconds between samples of historical data. For array-wide
                        performance metrics (`/arrays/performance` endpoint), valid values are
                        `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30
                        minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24
                        hours). For performance metrics on storage objects (`<object
                        name>/performance` endpoint), such as volumes, valid values are `30000` (30
                        seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours),
                        `28800000` (8 hours), and `86400000` (24 hours). For space metrics,
                        (`<object name>/space` endpoint), valid values are `300000` (5 minutes),
                        `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and
                        `86400000` (24 hours). Include the `start_time` parameter to display the
                        performance data starting at the specified start time. If `start_time` is
                        not specified, the start time will default to one resolution before the end
                        time, meaning that the most recent sample of performance data will be
                        displayed. Include the `end_time` parameter to display the performance data
                        until the specified end time. If `end_time`is not specified, the end time
                        will default to the current time. If the `resolution` parameter is not
                        specified but either the `start_time` or `end_time` parameter is, then
                        `resolution` will default to the lowest valid resolution.
        :type resolution: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param start_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type start_time: int
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            end_time=end_time,
            filter=filter,
            limit=limit,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('ArraysApi', 'api232_arrays_space_get_with_http_info', kwargs)

    def get_audits(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List audits  # noqa: E501
        
        Displays a list of audits.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_audits_get_with_http_info(authorization, x_request_id, continuation_token, filter, ids, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('AuditsApi', 'api232_audits_get_with_http_info', kwargs)

    def post_certificates_certificate_signing_requests(
        self,
        certificate: 'models.CertificateSigningRequestPost',
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create certificate signing request  # noqa: E501
        
        Creates a certificate signing request based on the certificate type and parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_certificates_certificate_signing_requests_post_with_http_info(certificate, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param certificate: (required)
        :type certificate: models.CertificateSigningRequestPost
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            certificate=certificate,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('CertificatesApi', 'api232_certificates_certificate_signing_requests_post_with_http_info', kwargs)

    def delete_certificates(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete certificate  # noqa: E501
        
        Deletes a specific certificate object.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_certificates_delete_with_http_info(authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('CertificatesApi', 'api232_certificates_delete_with_http_info', kwargs)

    def get_certificates(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List certificate attributes  # noqa: E501
        
        Displays certificate attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_certificates_get_with_http_info(authorization, x_request_id, continuation_token, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('CertificatesApi', 'api232_certificates_get_with_http_info', kwargs)

    def patch_certificates(
        self,
        certificate: 'models.CertificatePost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        generate_new_key: Annotated[Optional[StrictBool], Field(description="If set to `true`, a new private key is generated when generating a new certificate with the specified attributes. This may not be set to `true` when importing a certificate and private key, and may not be set to `false` when generating a new self-signed certificate to replace a certificate that was imported. Default setting is `false`.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify certificates  # noqa: E501
        
        Modifies certificate attributes. When you modify the attributes of a self-signed certificate, Purity//FA replaces the existing certificate with a new certificate, which is generated with the specified attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_certificates_patch_with_http_info(certificate, authorization, x_request_id, generate_new_key, names, async_req=True)
        >>> result = thread.get()
        
        :param certificate: (required)
        :type certificate: models.CertificatePost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param generate_new_key: If set to `true`, a new private key is generated when generating a new
                                certificate with the specified attributes. This may not be set to `true`
                                when importing a certificate and private key, and may not be set to
                                `false` when generating a new self-signed certificate to replace a
                                certificate that was imported. Default setting is `false`.
        :type generate_new_key: bool
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            certificate=certificate,
            authorization=authorization,
            x_request_id=x_request_id,
            generate_new_key=generate_new_key,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('CertificatesApi', 'api232_certificates_patch_with_http_info', kwargs)

    def post_certificates(
        self,
        certificate: 'models.CertificatePost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create certificate  # noqa: E501
        
        Creates a certificate object and specifies the valid time period and organization details of the certificate. A certificate can be imported or manually configured.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_certificates_post_with_http_info(certificate, authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param certificate: (required)
        :type certificate: models.CertificatePost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            certificate=certificate,
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('CertificatesApi', 'api232_certificates_post_with_http_info', kwargs)

    def delete_connections(
        self,
        volumes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        hosts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        host_groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        host_group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the host group specified. Enter multiple names in comma-separated format. A request cannot include a mix of multiple objects with multiple names. For example, a request cannot include a mix of multiple host group names and volume names; instead, at least one of the objects (e.g., `host_group_names`) must be set to only one name (e.g., `hgroup01`).")] = None,
        host_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the hosts specified. Enter multiple names in comma-separated format. For example, `host01,host02`. A request cannot include a mix of multiple objects with multiple names. For example, a request cannot include a mix of multiple host names and volume names; instead, at least one of the objects (e.g., `host_names`) must be set to only one name (e.g., `host01`).")] = None,
        volume_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the specified volume. Enter multiple ids in comma-separated format. For example, `vol01id,vol02id`. A request cannot include a mix of multiple objects with multiple IDs. For example, a request cannot include a mix of multiple volume IDs and host names; instead, at least one of the objects (e.g., `volume_ids`) must be set to only one name (e.g., `vol01id`). Only one of the two between `volume_names` and `volume_ids` may be used at a time.")] = None,
        volume_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the volume specified. Enter multiple names in comma-separated format. For example, `vol01,vol02`. A request cannot include a mix of multiple objects with multiple names. For example, a request cannot include a mix of multiple volume names and host names; instead, at least one of the objects (e.g., `volume_names`) must be set to only one name (e.g., `vol01`).")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a connection between a volume and its host or host group  # noqa: E501
        
        Deletes the connection between a volume and its associated host or host group. One of `volume_names` or `volume_ids` and one of `host_names` or `host_group_names` query parameters are required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_connections_delete_with_http_info(authorization, x_request_id, host_group_names, host_names, volume_ids, volume_names, async_req=True)
        >>> result = thread.get()
        
        :param volumes: A list of volumes to query for. Overrides volume_ids and volume_names keyword arguments.
        :type volumes: ReferenceType or List[ReferenceType], optional
        :param hosts: A list of hosts to query for. Overrides host_names keyword argument.
        :type hosts: ReferenceType or List[ReferenceType], optional
        :param host_groups: A list of host_groups to query for. Overrides host_group_names keyword argument.
        :type host_groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param host_group_names: Performs the operation on the host group specified. Enter multiple names in
                                comma-separated format. A request cannot include a mix of multiple objects
                                with multiple names. For example, a request cannot include a mix of
                                multiple host group names and volume names; instead, at least one of the
                                objects (e.g., `host_group_names`) must be set to only one name (e.g.,
                                `hgroup01`).
        :type host_group_names: List[str]
        :param host_names: Performs the operation on the hosts specified. Enter multiple names in comma-
                        separated format. For example, `host01,host02`. A request cannot include a
                        mix of multiple objects with multiple names. For example, a request cannot
                        include a mix of multiple host names and volume names; instead, at least one
                        of the objects (e.g., `host_names`) must be set to only one name (e.g.,
                        `host01`).
        :type host_names: List[str]
        :param volume_ids: Performs the operation on the specified volume. Enter multiple ids in comma-
                        separated format. For example, `vol01id,vol02id`. A request cannot include a
                        mix of multiple objects with multiple IDs. For example, a request cannot
                        include a mix of multiple volume IDs and host names; instead, at least one
                        of the objects (e.g., `volume_ids`) must be set to only one name (e.g.,
                        `vol01id`). Only one of the two between `volume_names` and `volume_ids` may
                        be used at a time.
        :type volume_ids: List[str]
        :param volume_names: Performs the operation on the volume specified. Enter multiple names in comma-
                            separated format. For example, `vol01,vol02`. A request cannot include a
                            mix of multiple objects with multiple names. For example, a request cannot
                            include a mix of multiple volume names and host names; instead, at least
                            one of the objects (e.g., `volume_names`) must be set to only one name
                            (e.g., `vol01`).
        :type volume_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            host_group_names=host_group_names,
            host_names=host_names,
            volume_ids=volume_ids,
            volume_names=volume_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(host_groups, ['host_group_names'], kwargs)
        _process_references(hosts, ['host_names'], kwargs)
        _process_references(volumes, ['volume_ids', 'volume_names'], kwargs)
        _fixup_list_type_params(['host_group_names', 'host_names', 'volume_ids', 'volume_names'], kwargs)
        return self._call_api('ConnectionsApi', 'api232_connections_delete_with_http_info', kwargs)

    def get_connections(
        self,
        volumes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        protocol_endpoints: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        hosts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        host_groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        host_group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the host group specified. Enter multiple names in comma-separated format. A request cannot include a mix of multiple objects with multiple names. For example, a request cannot include a mix of multiple host group names and volume names; instead, at least one of the objects (e.g., `host_group_names`) must be set to only one name (e.g., `hgroup01`).")] = None,
        host_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the hosts specified. Enter multiple names in comma-separated format. For example, `host01,host02`. A request cannot include a mix of multiple objects with multiple names. For example, a request cannot include a mix of multiple host names and volume names; instead, at least one of the objects (e.g., `host_names`) must be set to only one name (e.g., `host01`).")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        protocol_endpoint_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the protocol endpoints specified. Enter multiple IDs in comma-separated format. For example, `peid01,peid02`. A request cannot include a mix of multiple objects with multiple IDs. For example, a request cannot include a mix of multiple protocol endpoint IDs and host names. Instead, at least one of the objects (e.g., `protocol_endpoint_ids`) must be set to one ID (e.g., `peid01`).")] = None,
        protocol_endpoint_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the protocol endpoints specified. Enter multiple names in comma-separated format. For example, `pe01,pe02`. A request cannot include a mix of multiple objects with multiple names. For example, a request cannot include a mix of multiple protocol endpoint names and host names; instead, at least one of the objects (e.g., `protocol_endpoint_names`) must be set to one name (e.g., `pe01`).")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        volume_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the specified volume. Enter multiple ids in comma-separated format. For example, `vol01id,vol02id`. A request cannot include a mix of multiple objects with multiple IDs. For example, a request cannot include a mix of multiple volume IDs and host names; instead, at least one of the objects (e.g., `volume_ids`) must be set to only one name (e.g., `vol01id`). Only one of the two between `volume_names` and `volume_ids` may be used at a time.")] = None,
        volume_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the volume specified. Enter multiple names in comma-separated format. For example, `vol01,vol02`. A request cannot include a mix of multiple objects with multiple names. For example, a request cannot include a mix of multiple volume names and host names; instead, at least one of the objects (e.g., `volume_names`) must be set to only one name (e.g., `vol01`).")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List volume connections  # noqa: E501
        
        Displays a list of connections between a volume and its hosts and host groups, as well as the logical unit numbers (LUNs) or NVMe Namespace IDs (NSIDs) used by the associated hosts to address these volumes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_connections_get_with_http_info(authorization, x_request_id, continuation_token, filter, host_group_names, host_names, limit, offset, protocol_endpoint_ids, protocol_endpoint_names, sort, total_item_count, volume_ids, volume_names, async_req=True)
        >>> result = thread.get()
        
        :param volumes: A list of volumes to query for. Overrides volume_ids and volume_names keyword arguments.
        :type volumes: ReferenceType or List[ReferenceType], optional
        :param protocol_endpoints: A list of protocol_endpoints to query for. Overrides protocol_endpoint_ids and protocol_endpoint_names keyword arguments.
        :type protocol_endpoints: ReferenceType or List[ReferenceType], optional
        :param hosts: A list of hosts to query for. Overrides host_names keyword argument.
        :type hosts: ReferenceType or List[ReferenceType], optional
        :param host_groups: A list of host_groups to query for. Overrides host_group_names keyword argument.
        :type host_groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param host_group_names: Performs the operation on the host group specified. Enter multiple names in
                                comma-separated format. A request cannot include a mix of multiple objects
                                with multiple names. For example, a request cannot include a mix of
                                multiple host group names and volume names; instead, at least one of the
                                objects (e.g., `host_group_names`) must be set to only one name (e.g.,
                                `hgroup01`).
        :type host_group_names: List[str]
        :param host_names: Performs the operation on the hosts specified. Enter multiple names in comma-
                        separated format. For example, `host01,host02`. A request cannot include a
                        mix of multiple objects with multiple names. For example, a request cannot
                        include a mix of multiple host names and volume names; instead, at least one
                        of the objects (e.g., `host_names`) must be set to only one name (e.g.,
                        `host01`).
        :type host_names: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param protocol_endpoint_ids: Performs the operation on the protocol endpoints specified. Enter multiple IDs
                                    in comma-separated format. For example, `peid01,peid02`. A request cannot
                                    include a mix of multiple objects with multiple IDs. For example, a
                                    request cannot include a mix of multiple protocol endpoint IDs and host
                                    names. Instead, at least one of the objects (e.g.,
                                    `protocol_endpoint_ids`) must be set to one ID (e.g., `peid01`).
        :type protocol_endpoint_ids: List[str]
        :param protocol_endpoint_names: Performs the operation on the protocol endpoints specified. Enter multiple names
                                        in comma-separated format. For example, `pe01,pe02`. A request cannot
                                        include a mix of multiple objects with multiple names. For example, a
                                        request cannot include a mix of multiple protocol endpoint names and
                                        host names; instead, at least one of the objects (e.g.,
                                        `protocol_endpoint_names`) must be set to one name (e.g., `pe01`).
        :type protocol_endpoint_names: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param volume_ids: Performs the operation on the specified volume. Enter multiple ids in comma-
                        separated format. For example, `vol01id,vol02id`. A request cannot include a
                        mix of multiple objects with multiple IDs. For example, a request cannot
                        include a mix of multiple volume IDs and host names; instead, at least one
                        of the objects (e.g., `volume_ids`) must be set to only one name (e.g.,
                        `vol01id`). Only one of the two between `volume_names` and `volume_ids` may
                        be used at a time.
        :type volume_ids: List[str]
        :param volume_names: Performs the operation on the volume specified. Enter multiple names in comma-
                            separated format. For example, `vol01,vol02`. A request cannot include a
                            mix of multiple objects with multiple names. For example, a request cannot
                            include a mix of multiple volume names and host names; instead, at least
                            one of the objects (e.g., `volume_names`) must be set to only one name
                            (e.g., `vol01`).
        :type volume_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            host_group_names=host_group_names,
            host_names=host_names,
            limit=limit,
            offset=offset,
            protocol_endpoint_ids=protocol_endpoint_ids,
            protocol_endpoint_names=protocol_endpoint_names,
            sort=sort,
            total_item_count=total_item_count,
            volume_ids=volume_ids,
            volume_names=volume_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(host_groups, ['host_group_names'], kwargs)
        _process_references(hosts, ['host_names'], kwargs)
        _process_references(protocol_endpoints, ['protocol_endpoint_ids', 'protocol_endpoint_names'], kwargs)
        _process_references(volumes, ['volume_ids', 'volume_names'], kwargs)
        _fixup_list_type_params(['host_group_names', 'host_names', 'protocol_endpoint_ids', 'protocol_endpoint_names', 'sort', 'volume_ids', 'volume_names'], kwargs)
        return self._call_api('ConnectionsApi', 'api232_connections_get_with_http_info', kwargs)

    def post_connections(
        self,
        volumes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        hosts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        host_groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        host_group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the host group specified. Enter multiple names in comma-separated format. A request cannot include a mix of multiple objects with multiple names. For example, a request cannot include a mix of multiple host group names and volume names; instead, at least one of the objects (e.g., `host_group_names`) must be set to only one name (e.g., `hgroup01`).")] = None,
        host_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the hosts specified. Enter multiple names in comma-separated format. For example, `host01,host02`. A request cannot include a mix of multiple objects with multiple names. For example, a request cannot include a mix of multiple host names and volume names; instead, at least one of the objects (e.g., `host_names`) must be set to only one name (e.g., `host01`).")] = None,
        volume_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the specified volume. Enter multiple ids in comma-separated format. For example, `vol01id,vol02id`. A request cannot include a mix of multiple objects with multiple IDs. For example, a request cannot include a mix of multiple volume IDs and host names; instead, at least one of the objects (e.g., `volume_ids`) must be set to only one name (e.g., `vol01id`). Only one of the two between `volume_names` and `volume_ids` may be used at a time.")] = None,
        volume_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the volume specified. Enter multiple names in comma-separated format. For example, `vol01,vol02`. A request cannot include a mix of multiple objects with multiple names. For example, a request cannot include a mix of multiple volume names and host names; instead, at least one of the objects (e.g., `volume_names`) must be set to only one name (e.g., `vol01`).")] = None,
        connection: Optional['models.ConnectionPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a connection between a volume and host or host group  # noqa: E501
        
        Creates a connection between a volume and a host or host group. One of `volume_names` or `volume_ids` and one of `host_names` or `host_group_names` query parameters are required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_connections_post_with_http_info(authorization, x_request_id, host_group_names, host_names, volume_ids, volume_names, connection, async_req=True)
        >>> result = thread.get()
        
        :param volumes: A list of volumes to query for. Overrides volume_ids and volume_names keyword arguments.
        :type volumes: ReferenceType or List[ReferenceType], optional
        :param hosts: A list of hosts to query for. Overrides host_names keyword argument.
        :type hosts: ReferenceType or List[ReferenceType], optional
        :param host_groups: A list of host_groups to query for. Overrides host_group_names keyword argument.
        :type host_groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param host_group_names: Performs the operation on the host group specified. Enter multiple names in
                                comma-separated format. A request cannot include a mix of multiple objects
                                with multiple names. For example, a request cannot include a mix of
                                multiple host group names and volume names; instead, at least one of the
                                objects (e.g., `host_group_names`) must be set to only one name (e.g.,
                                `hgroup01`).
        :type host_group_names: List[str]
        :param host_names: Performs the operation on the hosts specified. Enter multiple names in comma-
                        separated format. For example, `host01,host02`. A request cannot include a
                        mix of multiple objects with multiple names. For example, a request cannot
                        include a mix of multiple host names and volume names; instead, at least one
                        of the objects (e.g., `host_names`) must be set to only one name (e.g.,
                        `host01`).
        :type host_names: List[str]
        :param volume_ids: Performs the operation on the specified volume. Enter multiple ids in comma-
                        separated format. For example, `vol01id,vol02id`. A request cannot include a
                        mix of multiple objects with multiple IDs. For example, a request cannot
                        include a mix of multiple volume IDs and host names; instead, at least one
                        of the objects (e.g., `volume_ids`) must be set to only one name (e.g.,
                        `vol01id`). Only one of the two between `volume_names` and `volume_ids` may
                        be used at a time.
        :type volume_ids: List[str]
        :param volume_names: Performs the operation on the volume specified. Enter multiple names in comma-
                            separated format. For example, `vol01,vol02`. A request cannot include a
                            mix of multiple objects with multiple names. For example, a request cannot
                            include a mix of multiple volume names and host names; instead, at least
                            one of the objects (e.g., `volume_names`) must be set to only one name
                            (e.g., `vol01`).
        :type volume_names: List[str]
        :param connection:
        :type connection: ConnectionPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            host_group_names=host_group_names,
            host_names=host_names,
            volume_ids=volume_ids,
            volume_names=volume_names,
            connection=connection,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(host_groups, ['host_group_names'], kwargs)
        _process_references(hosts, ['host_names'], kwargs)
        _process_references(volumes, ['volume_ids', 'volume_names'], kwargs)
        _fixup_list_type_params(['host_group_names', 'host_names', 'volume_ids', 'volume_names'], kwargs)
        return self._call_api('ConnectionsApi', 'api232_connections_post_with_http_info', kwargs)

    def get_container_default_protections(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the container ID specified. Enter multiple source IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together. Specifying `ids` or `names` with no value will perform the operation on local array.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique container name specified. Enter multiple names in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together. Specifying `ids` or `names` with no value will perform the operation on local array.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List container default protections  # noqa: E501
        
        Displays a list of containers with its default protections.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_container_default_protections_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, ids, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the container ID specified. Enter multiple source IDs
                    in comma-separated format. The `ids` or `names` parameter is required, but
                    they cannot be set together. Specifying `ids` or `names` with no value will
                    perform the operation on local array.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique container name specified. Enter multiple
                    names in comma-separated format. The `ids` or `names` parameter is required,
                    but they cannot be set together. Specifying `ids` or `names` with no value
                    will perform the operation on local array.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('ContainerDefaultProtectionsApi', 'api232_container_default_protections_get_with_http_info', kwargs)

    def patch_container_default_protections(
        self,
        container_default_protection: 'models.ContainerDefaultProtection',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the container ID specified. Enter multiple source IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together. Specifying `ids` or `names` with no value will perform the operation on local array.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique container name specified. Enter multiple names in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together. Specifying `ids` or `names` with no value will perform the operation on local array.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify a container's default protections  # noqa: E501
        
        Modifies a container's default protections. To modify, set `default_protections` to the new list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_container_default_protections_patch_with_http_info(container_default_protection, authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param container_default_protection: (required)
        :type container_default_protection: models.ContainerDefaultProtection
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the container ID specified. Enter multiple source IDs
                    in comma-separated format. The `ids` or `names` parameter is required, but
                    they cannot be set together. Specifying `ids` or `names` with no value will
                    perform the operation on local array.
        :type ids: List[str]
        :param names: Performs the operation on the unique container name specified. Enter multiple
                    names in comma-separated format. The `ids` or `names` parameter is required,
                    but they cannot be set together. Specifying `ids` or `names` with no value
                    will perform the operation on local array.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            container_default_protection=container_default_protection,
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('ContainerDefaultProtectionsApi', 'api232_container_default_protections_patch_with_http_info', kwargs)

    def get_controllers(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List controller information and status  # noqa: E501
        
        Displays the name, mode, FlashArray model, Purity//FA software version, and status of each controller in the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_controllers_get_with_http_info(authorization, x_request_id, continuation_token, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('ControllersApi', 'api232_controllers_get_with_http_info', kwargs)

    def delete_dns(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete DNS configuration  # noqa: E501
        
        Deletes DNS configuration identified by configuration name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_dns_delete_with_http_info(authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('DNSApi', 'api232_dns_delete_with_http_info', kwargs)

    def get_dns(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List DNS parameters  # noqa: E501
        
        Displays the current DNS configurations and their parameters including domain suffix, the list of DNS name server IP addresses, and the list of services that DNS parameters apply to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_dns_get_with_http_info(authorization, x_request_id, continuation_token, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('DNSApi', 'api232_dns_get_with_http_info', kwargs)

    def patch_dns(
        self,
        dns: 'models.DnsPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify DNS parameters  # noqa: E501
        
        Modifies the DNS parameters of an array, including the domain suffix, the list of DNS name server IP addresses, and the list of services that DNS parameters apply to. If there is no DNS configuration beforehand new DNS configuration with 'default' name is created. If more than one DNS configuration exists `name` has to be specified to identify the DNS configuration to be modified.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_dns_patch_with_http_info(dns, authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param dns: (required)
        :type dns: models.DnsPatch
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            dns=dns,
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('DNSApi', 'api232_dns_patch_with_http_info', kwargs)

    def post_dns(
        self,
        dns: 'models.DnsPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create DNS configuration  # noqa: E501
        
        Creates new DNS configuration with parameters including the domain suffix, the list of DNS name server IP addresses, and the list of services that DNS parameters apply to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_dns_post_with_http_info(dns, authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param dns: (required)
        :type dns: models.DnsPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            dns=dns,
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('DNSApi', 'api232_dns_post_with_http_info', kwargs)

    def delete_directories(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete managed directories  # noqa: E501
        
        Deletes one or more managed directories. To be deleted, a managed directory must be empty and not attached to any enabled export policies. Deleted managed directories cannot be recovered. The `ids` or `names` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directories_delete_with_http_info(authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('DirectoriesApi', 'api232_directories_delete_with_http_info', kwargs)

    def get_directories(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the file system ID specified. Enter multiple file system IDs in comma-separated format. The `file_system_ids` or `file_system_names` parameter is required, but they cannot be set together.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the file system name specified. Enter multiple file system names in comma-separated format. For example, `filesystem01,filesystem02`.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List directories  # noqa: E501
        
        Displays a list of directories, including those pending eradication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directories_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, file_system_ids, file_system_names, filter, ids, limit, names, offset, sort, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param file_system_ids: Performs the operation on the file system ID specified. Enter multiple file
                                system IDs in comma-separated format. The `file_system_ids` or
                                `file_system_names` parameter is required, but they cannot be set
                                together.
        :type file_system_ids: List[str]
        :param file_system_names: Performs the operation on the file system name specified. Enter multiple file
                                system names in comma-separated format. For example,
                                `filesystem01,filesystem02`.
        :type file_system_names: List[str]
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'ids', 'names', 'sort'], kwargs)
        return self._call_api('DirectoriesApi', 'api232_directories_get_with_http_info', kwargs)

    def post_directories_locks_nlm_reclamations(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Initiate NLM reclamation.  # noqa: E501
        
        NLM reclamation is a system-wide operation, affecting all clients, and so only one may be in progress at a time. Attempting to initiate reclamation while one is in progress will result in an error. When NLM reclamation is initiated, all NLM locks are deleted and client applications are notified that they can reacquire their locks within a grace period.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directories_locks_nlm_reclamations_post_with_http_info(x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('DirectoriesApi', 'api232_directories_locks_nlm_reclamations_post_with_http_info', kwargs)

    def patch_directories(
        self,
        directory: 'models.DirectoryPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify a managed directory  # noqa: E501
        
        Modifies a managed directory. To rename a managed directory, set `name` to the new name. The `ids` or `names` parameter is required, but cannot be set together. The `name` or `directory_name` parameter is required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directories_patch_with_http_info(directory, authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param directory: (required)
        :type directory: models.DirectoryPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            directory=directory,
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('DirectoriesApi', 'api232_directories_patch_with_http_info', kwargs)

    def get_directories_performance(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        protocol: Annotated[Optional[StrictStr], Field(description="Protocol type. Valid values are `nfs`, `smb`, and `all`.")] = None,
        protocol_group: Annotated[Optional[StrictStr], Field(description="Protocol group type. Valid values are `block`, `file`, and `all`.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The number of milliseconds between samples of historical data. For array-wide performance metrics (`/arrays/performance` endpoint), valid values are `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For performance metrics on storage objects (`<object name>/performance` endpoint), such as volumes, valid values are `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For space metrics, (`<object name>/space` endpoint), valid values are `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). Include the `start_time` parameter to display the performance data starting at the specified start time. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. Include the `end_time` parameter to display the performance data until the specified end time. If `end_time`is not specified, the end time will default to the current time. If the `resolution` parameter is not specified but either the `start_time` or `end_time` parameter is, then `resolution` will default to the lowest valid resolution.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List directory performance data  # noqa: E501
        
        Displays real-time and historical performance data, real-time latency data, and average I/O sizes for each directory and as a total of all directories across the entire array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directories_performance_get_with_http_info(authorization, x_request_id, destroyed, end_time, filter, ids, limit, names, offset, protocol, protocol_group, resolution, sort, start_time, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param end_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type end_time: int
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param protocol: Protocol type. Valid values are `nfs`, `smb`, and `all`.
        :type protocol: str
        :param protocol_group: Protocol group type. Valid values are `block`, `file`, and `all`.
        :type protocol_group: str
        :param resolution: The number of milliseconds between samples of historical data. For array-wide
                        performance metrics (`/arrays/performance` endpoint), valid values are
                        `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30
                        minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24
                        hours). For performance metrics on storage objects (`<object
                        name>/performance` endpoint), such as volumes, valid values are `30000` (30
                        seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours),
                        `28800000` (8 hours), and `86400000` (24 hours). For space metrics,
                        (`<object name>/space` endpoint), valid values are `300000` (5 minutes),
                        `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and
                        `86400000` (24 hours). Include the `start_time` parameter to display the
                        performance data starting at the specified start time. If `start_time` is
                        not specified, the start time will default to one resolution before the end
                        time, meaning that the most recent sample of performance data will be
                        displayed. Include the `end_time` parameter to display the performance data
                        until the specified end time. If `end_time`is not specified, the end time
                        will default to the current time. If the `resolution` parameter is not
                        specified but either the `start_time` or `end_time` parameter is, then
                        `resolution` will default to the lowest valid resolution.
        :type resolution: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param start_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type start_time: int
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            destroyed=destroyed,
            end_time=end_time,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            protocol=protocol,
            protocol_group=protocol_group,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('DirectoriesApi', 'api232_directories_performance_get_with_http_info', kwargs)

    def delete_directories_policies_autodir(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a membership between a directory and one or more auto managed directory policies  # noqa: E501
        
        Deletes a membership between a directory with one or more auto managed directory policies. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together. The `member_ids` or `member_names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directories_policies_autodir_delete_with_http_info(authorization, x_request_id, member_ids, member_names, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('DirectoriesApi', 'api232_directories_policies_autodir_delete_with_http_info', kwargs)

    def get_directories_policies_autodir(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List auto managed directory policies attached to a directory  # noqa: E501
        
        Displays a list of auto managed directory policies that are attached to directories.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directories_policies_autodir_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, limit, member_ids, member_names, offset, policy_ids, policy_names, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('DirectoriesApi', 'api232_directories_policies_autodir_get_with_http_info', kwargs)

    def post_directories_policies_autodir(
        self,
        policies: 'models.DirectoryPolicyPost',
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a membership between a directory with one or more auto managed directory policies  # noqa: E501
        
        Creates a membership between a directory with one or more auto managed directory policies. The `member_ids` or `member_names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directories_policies_autodir_post_with_http_info(policies, authorization, x_request_id, member_ids, member_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: (required)
        :type policies: models.DirectoryPolicyPost
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            policies=policies,
            authorization=authorization,
            x_request_id=x_request_id,
            member_ids=member_ids,
            member_names=member_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names'], kwargs)
        return self._call_api('DirectoriesApi', 'api232_directories_policies_autodir_post_with_http_info', kwargs)

    def get_directories_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List policies  # noqa: E501
        
        Displays a list of policies that are attached to directories.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directories_policies_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, limit, member_ids, member_names, offset, policy_ids, policy_names, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('DirectoriesApi', 'api232_directories_policies_get_with_http_info', kwargs)

    def delete_directories_policies_nfs(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a membership between a directory and one or more NFS policies  # noqa: E501
        
        Deletes a membership between a directory and one or more NFS policies. The `policy_ids` or `policy_names` parameter is required, but cannot be set together. The `member_ids` or `member_names` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directories_policies_nfs_delete_with_http_info(authorization, x_request_id, member_ids, member_names, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('DirectoriesApi', 'api232_directories_policies_nfs_delete_with_http_info', kwargs)

    def get_directories_policies_nfs(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List NFS policies attached to a directory  # noqa: E501
        
        Displays a list of NFS policies that are attached to directories.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directories_policies_nfs_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, limit, member_ids, member_names, offset, policy_ids, policy_names, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('DirectoriesApi', 'api232_directories_policies_nfs_get_with_http_info', kwargs)

    def post_directories_policies_nfs(
        self,
        policies: 'models.DirectoryPolicyExportPost',
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a membership between a directory and one or more NFS policies  # noqa: E501
        
        Creates a membership between a directory and one or more NFS policies. The `member_ids` or `member_names` parameter is required but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directories_policies_nfs_post_with_http_info(policies, authorization, x_request_id, member_ids, member_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: (required)
        :type policies: models.DirectoryPolicyExportPost
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            policies=policies,
            authorization=authorization,
            x_request_id=x_request_id,
            member_ids=member_ids,
            member_names=member_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names'], kwargs)
        return self._call_api('DirectoriesApi', 'api232_directories_policies_nfs_post_with_http_info', kwargs)

    def delete_directories_policies_quota(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a membership between a directory and one or more quota policies  # noqa: E501
        
        Deletes a membership between a directory and one or more quota policies. The `policy_ids` or `policy_names` parameter is required, but cannot be set together. The `member_ids` or `member_names` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directories_policies_quota_delete_with_http_info(authorization, x_request_id, member_ids, member_names, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('DirectoriesApi', 'api232_directories_policies_quota_delete_with_http_info', kwargs)

    def get_directories_policies_quota(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List quota policies attached to a directory  # noqa: E501
        
        Displays a list of quota policies that are attached to directories.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directories_policies_quota_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, limit, member_ids, member_names, offset, policy_ids, policy_names, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('DirectoriesApi', 'api232_directories_policies_quota_get_with_http_info', kwargs)

    def post_directories_policies_quota(
        self,
        policies: 'models.DirectoryPolicyPost',
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ignore_usage: Annotated[Optional[StrictBool], Field(description="Flag used to override checks for quota management operations. If set to `true`, directory usage is not checked against the `quota_limits` that are set. If set to `false`, the actual logical bytes in use are prevented from exceeding the limits set on the directory. Client operations might be impacted. If the limit exceeds the quota, the client operation is not allowed. If not specified, defaults to `false`.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a membership between a directory and one or more quota policies  # noqa: E501
        
        Creates a membership between a directory and one or more quota policies. The `member_ids` or `member_names` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directories_policies_quota_post_with_http_info(policies, authorization, x_request_id, ignore_usage, member_ids, member_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: (required)
        :type policies: models.DirectoryPolicyPost
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ignore_usage: Flag used to override checks for quota management operations. If set to `true`,
                            directory usage is not checked against the `quota_limits` that are set. If
                            set to `false`, the actual logical bytes in use are prevented from
                            exceeding the limits set on the directory. Client operations might be
                            impacted. If the limit exceeds the quota, the client operation is not
                            allowed. If not specified, defaults to `false`.
        :type ignore_usage: bool
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            policies=policies,
            authorization=authorization,
            x_request_id=x_request_id,
            ignore_usage=ignore_usage,
            member_ids=member_ids,
            member_names=member_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names'], kwargs)
        return self._call_api('DirectoriesApi', 'api232_directories_policies_quota_post_with_http_info', kwargs)

    def delete_directories_policies_smb(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a membership between a directory and one or more SMB policies  # noqa: E501
        
        Deletes a membership between a directory and one or more SMB policies. The `policy_ids` or `policy_names` parameter is required, but cannot be set together. The `member_ids` or `member_names` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directories_policies_smb_delete_with_http_info(authorization, x_request_id, member_ids, member_names, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('DirectoriesApi', 'api232_directories_policies_smb_delete_with_http_info', kwargs)

    def get_directories_policies_smb(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List SMB policies attached to a directory  # noqa: E501
        
        Displays a list of SMB policies that are attached to directories.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directories_policies_smb_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, limit, member_ids, member_names, offset, policy_ids, policy_names, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('DirectoriesApi', 'api232_directories_policies_smb_get_with_http_info', kwargs)

    def post_directories_policies_smb(
        self,
        policies: 'models.DirectoryPolicyExportPost',
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a membership between a directory and one or more SMB policies  # noqa: E501
        
        Creates a membership between a directory and one or more SMB policies. The `member_ids` or `member_names` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directories_policies_smb_post_with_http_info(policies, authorization, x_request_id, member_ids, member_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: (required)
        :type policies: models.DirectoryPolicyExportPost
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            policies=policies,
            authorization=authorization,
            x_request_id=x_request_id,
            member_ids=member_ids,
            member_names=member_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names'], kwargs)
        return self._call_api('DirectoriesApi', 'api232_directories_policies_smb_post_with_http_info', kwargs)

    def delete_directories_policies_snapshot(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a membership between a directory and one or more snapshot policies  # noqa: E501
        
        Deletes a membership between a directory and one or more snapshot policies. The `policy_ids` or `policy_names` parameter is required, but cannot be set together. The `member_ids` or `member_names` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directories_policies_snapshot_delete_with_http_info(authorization, x_request_id, member_ids, member_names, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('DirectoriesApi', 'api232_directories_policies_snapshot_delete_with_http_info', kwargs)

    def get_directories_policies_snapshot(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List snapshot policies attached to a directory  # noqa: E501
        
        Displays a list of snapshot policies that are attached to directories.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directories_policies_snapshot_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, limit, member_ids, member_names, offset, policy_ids, policy_names, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('DirectoriesApi', 'api232_directories_policies_snapshot_get_with_http_info', kwargs)

    def post_directories_policies_snapshot(
        self,
        policies: 'models.DirectoryPolicyPost',
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a membership between a directory with one or more snapshot policies  # noqa: E501
        
        Creates a membership between a directory with one or more snapshot policies. The `member_ids` or `member_names` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directories_policies_snapshot_post_with_http_info(policies, authorization, x_request_id, member_ids, member_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: (required)
        :type policies: models.DirectoryPolicyPost
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            policies=policies,
            authorization=authorization,
            x_request_id=x_request_id,
            member_ids=member_ids,
            member_names=member_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names'], kwargs)
        return self._call_api('DirectoriesApi', 'api232_directories_policies_snapshot_post_with_http_info', kwargs)

    def post_directories(
        self,
        directory: 'models.DirectoryPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the file system ID specified. Enter multiple file system IDs in comma-separated format. The `file_system_ids` or `file_system_names` parameter is required, but they cannot be set together.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the file system name specified. Enter multiple file system names in comma-separated format. For example, `filesystem01,filesystem02`.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create directory  # noqa: E501
        
        Creates a managed directory at the specified path. The managed directory name must consist of a file system name prefix and a managed directory name suffix (separated with '&#58;'). The suffix must be between 1 and 63 characters (alphanumeric and '-') in length and begin and end with a letter or number. The suffix must include at least one letter or '-'. Set `names` to create a managed directory with the specified full managed directory name, or set `file_system_names` or `file_system_ids` in the query parameters and `suffix` in the body parameters to create a managed directory in the specified file system with the specified suffix. These two options are exclusive.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directories_post_with_http_info(directory, authorization, x_request_id, file_system_ids, file_system_names, names, async_req=True)
        >>> result = thread.get()
        
        :param directory: (required)
        :type directory: models.DirectoryPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param file_system_ids: Performs the operation on the file system ID specified. Enter multiple file
                                system IDs in comma-separated format. The `file_system_ids` or
                                `file_system_names` parameter is required, but they cannot be set
                                together.
        :type file_system_ids: List[str]
        :param file_system_names: Performs the operation on the file system name specified. Enter multiple file
                                system names in comma-separated format. For example,
                                `filesystem01,filesystem02`.
        :type file_system_names: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            directory=directory,
            authorization=authorization,
            x_request_id=x_request_id,
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'names'], kwargs)
        return self._call_api('DirectoriesApi', 'api232_directories_post_with_http_info', kwargs)

    def get_directories_space(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The number of milliseconds between samples of historical data. For array-wide performance metrics (`/arrays/performance` endpoint), valid values are `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For performance metrics on storage objects (`<object name>/performance` endpoint), such as volumes, valid values are `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For space metrics, (`<object name>/space` endpoint), valid values are `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). Include the `start_time` parameter to display the performance data starting at the specified start time. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. Include the `end_time` parameter to display the performance data until the specified end time. If `end_time`is not specified, the end time will default to the current time. If the `resolution` parameter is not specified but either the `start_time` or `end_time` parameter is, then `resolution` will default to the lowest valid resolution.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List directory space information  # noqa: E501
        
        Displays physical storage consumption data for each directory.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directories_space_get_with_http_info(authorization, x_request_id, destroyed, end_time, filter, ids, limit, names, offset, resolution, sort, start_time, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param end_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type end_time: int
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param resolution: The number of milliseconds between samples of historical data. For array-wide
                        performance metrics (`/arrays/performance` endpoint), valid values are
                        `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30
                        minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24
                        hours). For performance metrics on storage objects (`<object
                        name>/performance` endpoint), such as volumes, valid values are `30000` (30
                        seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours),
                        `28800000` (8 hours), and `86400000` (24 hours). For space metrics,
                        (`<object name>/space` endpoint), valid values are `300000` (5 minutes),
                        `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and
                        `86400000` (24 hours). Include the `start_time` parameter to display the
                        performance data starting at the specified start time. If `start_time` is
                        not specified, the start time will default to one resolution before the end
                        time, meaning that the most recent sample of performance data will be
                        displayed. Include the `end_time` parameter to display the performance data
                        until the specified end time. If `end_time`is not specified, the end time
                        will default to the current time. If the `resolution` parameter is not
                        specified but either the `start_time` or `end_time` parameter is, then
                        `resolution` will default to the lowest valid resolution.
        :type resolution: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param start_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type start_time: int
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            destroyed=destroyed,
            end_time=end_time,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('DirectoriesApi', 'api232_directories_space_get_with_http_info', kwargs)

    def delete_directory_exports(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        exports: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        directories: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        directory_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique managed directory IDs specified. Enter multiple managed directory IDs in comma-separated format. The `directory_ids` or `directory_names` parameter is required, but they cannot be set together.")] = None,
        directory_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the managed directory names specified. Enter multiple full managed directory names in comma-separated format. For example, `fs:dir01,fs:dir02`.")] = None,
        export_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the export names specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete directory exports  # noqa: E501
        
        Deletes one or more directory exports. If any of the `export_names` is not unique across the system, `policy_ids` or `policy_names` must be specified to determine the exports.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_exports_delete_with_http_info(authorization, x_request_id, directory_ids, directory_names, export_names, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param exports: A list of exports to query for. Overrides export_names keyword argument.
        :type exports: ReferenceType or List[ReferenceType], optional
        :param directories: A list of directories to query for. Overrides directory_ids and directory_names keyword arguments.
        :type directories: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param directory_ids: Performs the operation on the unique managed directory IDs specified. Enter
                            multiple managed directory IDs in comma-separated format. The
                            `directory_ids` or `directory_names` parameter is required, but they cannot
                            be set together.
        :type directory_ids: List[str]
        :param directory_names: Performs the operation on the managed directory names specified. Enter multiple
                                full managed directory names in comma-separated format. For example,
                                `fs:dir01,fs:dir02`.
        :type directory_names: List[str]
        :param export_names: Performs the operation on the export names specified. Enter multiple names in
                            comma-separated format. For example, `name01,name02`.
        :type export_names: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            directory_ids=directory_ids,
            directory_names=directory_names,
            export_names=export_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(directories, ['directory_ids', 'directory_names'], kwargs)
        _process_references(exports, ['export_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['directory_ids', 'directory_names', 'export_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('DirectoryExportsApi', 'api232_directory_exports_delete_with_http_info', kwargs)

    def get_directory_exports(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        exports: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        directories: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        directory_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique managed directory IDs specified. Enter multiple managed directory IDs in comma-separated format. The `directory_ids` or `directory_names` parameter is required, but they cannot be set together.")] = None,
        directory_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the managed directory names specified. Enter multiple full managed directory names in comma-separated format. For example, `fs:dir01,fs:dir02`.")] = None,
        export_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the export names specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List directory exports  # noqa: E501
        
        Displays a list of directory exports.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_exports_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, directory_ids, directory_names, export_names, filter, limit, offset, policy_ids, policy_names, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param exports: A list of exports to query for. Overrides export_names keyword argument.
        :type exports: ReferenceType or List[ReferenceType], optional
        :param directories: A list of directories to query for. Overrides directory_ids and directory_names keyword arguments.
        :type directories: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param directory_ids: Performs the operation on the unique managed directory IDs specified. Enter
                            multiple managed directory IDs in comma-separated format. The
                            `directory_ids` or `directory_names` parameter is required, but they cannot
                            be set together.
        :type directory_ids: List[str]
        :param directory_names: Performs the operation on the managed directory names specified. Enter multiple
                                full managed directory names in comma-separated format. For example,
                                `fs:dir01,fs:dir02`.
        :type directory_names: List[str]
        :param export_names: Performs the operation on the export names specified. Enter multiple names in
                            comma-separated format. For example, `name01,name02`.
        :type export_names: List[str]
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            directory_ids=directory_ids,
            directory_names=directory_names,
            export_names=export_names,
            filter=filter,
            limit=limit,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(directories, ['directory_ids', 'directory_names'], kwargs)
        _process_references(exports, ['export_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['directory_ids', 'directory_names', 'export_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('DirectoryExportsApi', 'api232_directory_exports_get_with_http_info', kwargs)

    def patch_directory_exports(
        self,
        export: 'models.DirectoryExportPatch',
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        exports: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        directories: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        directory_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique managed directory IDs specified. Enter multiple managed directory IDs in comma-separated format. The `directory_ids` or `directory_names` parameter is required, but they cannot be set together.")] = None,
        directory_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the managed directory names specified. Enter multiple full managed directory names in comma-separated format. For example, `fs:dir01,fs:dir02`.")] = None,
        export_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the export names specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify directory exports  # noqa: E501
        
        Modifies a directory export. Used for manually renaming, enabling, and disabling directory exports. To rename a directory export, set 'export_name' to the new name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_exports_patch_with_http_info(export, authorization, x_request_id, directory_ids, directory_names, export_names, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param export: (required)
        :type export: models.DirectoryExportPatch
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param exports: A list of exports to query for. Overrides export_names keyword argument.
        :type exports: ReferenceType or List[ReferenceType], optional
        :param directories: A list of directories to query for. Overrides directory_ids and directory_names keyword arguments.
        :type directories: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param directory_ids: Performs the operation on the unique managed directory IDs specified. Enter
                            multiple managed directory IDs in comma-separated format. The
                            `directory_ids` or `directory_names` parameter is required, but they cannot
                            be set together.
        :type directory_ids: List[str]
        :param directory_names: Performs the operation on the managed directory names specified. Enter multiple
                                full managed directory names in comma-separated format. For example,
                                `fs:dir01,fs:dir02`.
        :type directory_names: List[str]
        :param export_names: Performs the operation on the export names specified. Enter multiple names in
                            comma-separated format. For example, `name01,name02`.
        :type export_names: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            export=export,
            authorization=authorization,
            x_request_id=x_request_id,
            directory_ids=directory_ids,
            directory_names=directory_names,
            export_names=export_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(directories, ['directory_ids', 'directory_names'], kwargs)
        _process_references(exports, ['export_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['directory_ids', 'directory_names', 'export_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('DirectoryExportsApi', 'api232_directory_exports_patch_with_http_info', kwargs)

    def post_directory_exports(
        self,
        exports: 'models.DirectoryExportPost',
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        directories: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        directory_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique managed directory IDs specified. Enter multiple managed directory IDs in comma-separated format. The `directory_ids` or `directory_names` parameter is required, but they cannot be set together.")] = None,
        directory_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the managed directory names specified. Enter multiple full managed directory names in comma-separated format. For example, `fs:dir01,fs:dir02`.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create directory exports  # noqa: E501
        
        Creates an export of a managed directory. The `directory_ids` or `directory_names` parameter is required, but cannot be set together. The `policy_ids` or `policy_names` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_exports_post_with_http_info(exports, authorization, x_request_id, directory_ids, directory_names, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param exports: (required)
        :type exports: models.DirectoryExportPost
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param directories: A list of directories to query for. Overrides directory_ids and directory_names keyword arguments.
        :type directories: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param directory_ids: Performs the operation on the unique managed directory IDs specified. Enter
                            multiple managed directory IDs in comma-separated format. The
                            `directory_ids` or `directory_names` parameter is required, but they cannot
                            be set together.
        :type directory_ids: List[str]
        :param directory_names: Performs the operation on the managed directory names specified. Enter multiple
                                full managed directory names in comma-separated format. For example,
                                `fs:dir01,fs:dir02`.
        :type directory_names: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            exports=exports,
            authorization=authorization,
            x_request_id=x_request_id,
            directory_ids=directory_ids,
            directory_names=directory_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(directories, ['directory_ids', 'directory_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['directory_ids', 'directory_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('DirectoryExportsApi', 'api232_directory_exports_post_with_http_info', kwargs)

    def get_directory_quotas(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        directories: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        directory_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique managed directory IDs specified. Enter multiple managed directory IDs in comma-separated format. The `directory_ids` or `directory_names` parameter is required, but they cannot be set together.")] = None,
        directory_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the managed directory names specified. Enter multiple full managed directory names in comma-separated format. For example, `fs:dir01,fs:dir02`.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List directories with attached quota policies  # noqa: E501
        
        Displays a list of directories and the quota policies attached to them. Directories with multiple policies are listed repeatedly (once per policy). The directories without a policy attached are not listed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_quotas_get_with_http_info(authorization, x_request_id, continuation_token, directory_ids, directory_names, filter, limit, offset, policy_ids, policy_names, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param directories: A list of directories to query for. Overrides directory_ids and directory_names keyword arguments.
        :type directories: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param directory_ids: Performs the operation on the unique managed directory IDs specified. Enter
                            multiple managed directory IDs in comma-separated format. The
                            `directory_ids` or `directory_names` parameter is required, but they cannot
                            be set together.
        :type directory_ids: List[str]
        :param directory_names: Performs the operation on the managed directory names specified. Enter multiple
                                full managed directory names in comma-separated format. For example,
                                `fs:dir01,fs:dir02`.
        :type directory_names: List[str]
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            directory_ids=directory_ids,
            directory_names=directory_names,
            filter=filter,
            limit=limit,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(directories, ['directory_ids', 'directory_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['directory_ids', 'directory_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('DirectoryQuotasApi', 'api232_directory_quotas_get_with_http_info', kwargs)

    def get_directory_services(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List directory services configuration  # noqa: E501
        
        Displays the directory services configuration settings for manageability.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_services_get_with_http_info(authorization, x_request_id, continuation_token, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api232_directory_services_get_with_http_info', kwargs)

    def delete_directory_services_local_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        gids: Annotated[Optional[conlist(StrictInt)], Field(description="Performs the operation on the specified GIDs. Enter multiple GIDs in comma-separated format. For example, `4234235,9681923`.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        sids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the object SID specified. Enter multiple SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete local groups  # noqa: E501
        
        Deletes one or more local groups. The `gids`, `names`, or `sids` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_services_local_groups_delete_with_http_info(authorization, x_request_id, gids, names, sids, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param gids: Performs the operation on the specified GIDs. Enter multiple GIDs in comma-
                    separated format. For example, `4234235,9681923`.
        :type gids: List[int]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param sids: Performs the operation on the object SID specified. Enter multiple SIDs in
                    comma-separated format. For example,
                    `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type sids: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            gids=gids,
            names=names,
            sids=sids,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['gids', 'names', 'sids'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api232_directory_services_local_groups_delete_with_http_info', kwargs)

    def get_directory_services_local_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        gids: Annotated[Optional[conlist(StrictInt)], Field(description="Performs the operation on the specified GIDs. Enter multiple GIDs in comma-separated format. For example, `4234235,9681923`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the object SID specified. Enter multiple SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List local groups  # noqa: E501
        
        Displays a list of local groups.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_services_local_groups_get_with_http_info(authorization, x_request_id, continuation_token, filter, gids, ids, limit, names, offset, sids, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param gids: Performs the operation on the specified GIDs. Enter multiple GIDs in comma-
                    separated format. For example, `4234235,9681923`.
        :type gids: List[int]
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sids: Performs the operation on the object SID specified. Enter multiple SIDs in
                    comma-separated format. For example,
                    `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type sids: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            gids=gids,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sids=sids,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['gids', 'ids', 'names', 'sids', 'sort'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api232_directory_services_local_groups_get_with_http_info', kwargs)

    def delete_directory_services_local_groups_members(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        group_gids: Annotated[Optional[conlist(StrictInt)], Field(description="Performs the operation on the specified GIDs. Enter multiple GIDs in comma-separated format. For example, `4234235,9681923`.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the group names specified. Enter multiple group names in comma-separated format. For example, `group1,group2`.")] = None,
        group_sids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the specified group SID. Enter multiple group SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        member_ids: Annotated[Optional[conlist(StrictInt)], Field(description="Performs the operation on the unique local member IDs specified. Enter multiple member IDs in comma-separated format. For local group IDs refer to group IDs (GID). For local user IDs refer to user IDs (UID). The `member_ids` and `member_names` parameters cannot be provided together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        member_sids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the specified member SID. Enter multiple member SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        member_types: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the member types specified. The type of member is the full name of the resource endpoint. Valid values include `directories`. Enter multiple member types in comma-separated format. For example, `type01,type02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete local group membership  # noqa: E501
        
        Deletes one or more local group memberships. The `group_names`, `group_sids`, or `group_ids` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_services_local_groups_members_delete_with_http_info(authorization, x_request_id, group_gids, group_names, group_sids, member_ids, member_names, member_sids, member_types, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param group_gids: Performs the operation on the specified GIDs. Enter multiple GIDs in comma-
                        separated format. For example, `4234235,9681923`.
        :type group_gids: List[int]
        :param group_names: Performs the operation on the group names specified. Enter multiple group names
                            in comma-separated format. For example, `group1,group2`.
        :type group_names: List[str]
        :param group_sids: Performs the operation on the specified group SID. Enter multiple group SIDs in
                        comma-separated format. For example,
                        `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type group_sids: List[str]
        :param member_ids: Performs the operation on the unique local member IDs specified. Enter multiple
                        member IDs in comma-separated format. For local group IDs refer to group IDs
                        (GID). For local user IDs refer to user IDs (UID). The `member_ids` and
                        `member_names` parameters cannot be provided together.
        :type member_ids: List[int]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param member_sids: Performs the operation on the specified member SID. Enter multiple member SIDs
                            in comma-separated format. For example,
                            `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type member_sids: List[str]
        :param member_types: Performs the operation on the member types specified. The type of member is the
                            full name of the resource endpoint. Valid values include `directories`.
                            Enter multiple member types in comma-separated format. For example,
                            `type01,type02`.
        :type member_types: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            group_gids=group_gids,
            group_names=group_names,
            group_sids=group_sids,
            member_ids=member_ids,
            member_names=member_names,
            member_sids=member_sids,
            member_types=member_types,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _fixup_list_type_params(['group_gids', 'group_names', 'group_sids', 'member_ids', 'member_names', 'member_sids', 'member_types'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api232_directory_services_local_groups_members_delete_with_http_info', kwargs)

    def get_directory_services_local_groups_members(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        group_gids: Annotated[Optional[conlist(StrictInt)], Field(description="Performs the operation on the specified GIDs. Enter multiple GIDs in comma-separated format. For example, `4234235,9681923`.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the group names specified. Enter multiple group names in comma-separated format. For example, `group1,group2`.")] = None,
        group_sids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the specified group SID. Enter multiple group SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_ids: Annotated[Optional[conlist(StrictInt)], Field(description="Performs the operation on the unique local member IDs specified. Enter multiple member IDs in comma-separated format. For local group IDs refer to group IDs (GID). For local user IDs refer to user IDs (UID). The `member_ids` and `member_names` parameters cannot be provided together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        member_sids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the specified member SID. Enter multiple member SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        member_types: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the member types specified. The type of member is the full name of the resource endpoint. Valid values include `directories`. Enter multiple member types in comma-separated format. For example, `type01,type02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List local group memberships  # noqa: E501
        
        Displays a list of local group memberships.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_services_local_groups_members_get_with_http_info(authorization, x_request_id, continuation_token, filter, group_gids, group_names, group_sids, limit, member_ids, member_names, member_sids, member_types, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param group_gids: Performs the operation on the specified GIDs. Enter multiple GIDs in comma-
                        separated format. For example, `4234235,9681923`.
        :type group_gids: List[int]
        :param group_names: Performs the operation on the group names specified. Enter multiple group names
                            in comma-separated format. For example, `group1,group2`.
        :type group_names: List[str]
        :param group_sids: Performs the operation on the specified group SID. Enter multiple group SIDs in
                        comma-separated format. For example,
                        `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type group_sids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_ids: Performs the operation on the unique local member IDs specified. Enter multiple
                        member IDs in comma-separated format. For local group IDs refer to group IDs
                        (GID). For local user IDs refer to user IDs (UID). The `member_ids` and
                        `member_names` parameters cannot be provided together.
        :type member_ids: List[int]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param member_sids: Performs the operation on the specified member SID. Enter multiple member SIDs
                            in comma-separated format. For example,
                            `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type member_sids: List[str]
        :param member_types: Performs the operation on the member types specified. The type of member is the
                            full name of the resource endpoint. Valid values include `directories`.
                            Enter multiple member types in comma-separated format. For example,
                            `type01,type02`.
        :type member_types: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            group_gids=group_gids,
            group_names=group_names,
            group_sids=group_sids,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            member_sids=member_sids,
            member_types=member_types,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _fixup_list_type_params(['group_gids', 'group_names', 'group_sids', 'member_ids', 'member_names', 'member_sids', 'member_types', 'sort'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api232_directory_services_local_groups_members_get_with_http_info', kwargs)

    def post_directory_services_local_groups_members(
        self,
        local_membership: Annotated['models.LocalGroupMembershipPost', Field(..., description="The `member_names`, `member_sids`, or `member_gids` parameter is required, but cannot be set together.")],
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        group_gids: Annotated[Optional[conlist(StrictInt)], Field(description="Performs the operation on the specified GIDs. Enter multiple GIDs in comma-separated format. For example, `4234235,9681923`.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the group names specified. Enter multiple group names in comma-separated format. For example, `group1,group2`.")] = None,
        group_sids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the specified group SID. Enter multiple group SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create local group membership  # noqa: E501
        
        Creates a local group membership with a group. The `group_names`, `group_sids`, or `group_ids` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_services_local_groups_members_post_with_http_info(local_membership, authorization, x_request_id, group_gids, group_names, group_sids, async_req=True)
        >>> result = thread.get()
        
        :param local_membership: The `member_names`, `member_sids`, or `member_gids` parameter is required, but
                                cannot be set together. (required)
        :type local_membership: models.LocalGroupMembershipPost
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param group_gids: Performs the operation on the specified GIDs. Enter multiple GIDs in comma-
                        separated format. For example, `4234235,9681923`.
        :type group_gids: List[int]
        :param group_names: Performs the operation on the group names specified. Enter multiple group names
                            in comma-separated format. For example, `group1,group2`.
        :type group_names: List[str]
        :param group_sids: Performs the operation on the specified group SID. Enter multiple group SIDs in
                        comma-separated format. For example,
                        `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type group_sids: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            local_membership=local_membership,
            authorization=authorization,
            x_request_id=x_request_id,
            group_gids=group_gids,
            group_names=group_names,
            group_sids=group_sids,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_names'], kwargs)
        _fixup_list_type_params(['group_gids', 'group_names', 'group_sids'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api232_directory_services_local_groups_members_post_with_http_info', kwargs)

    def patch_directory_services_local_groups(
        self,
        local_group: 'models.LocalGroup',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        gids: Annotated[Optional[conlist(StrictInt)], Field(description="Performs the operation on the specified GIDs. Enter multiple GIDs in comma-separated format. For example, `4234235,9681923`.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        sids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the object SID specified. Enter multiple SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify local groups  # noqa: E501
        
        Modifies local groups.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_services_local_groups_patch_with_http_info(local_group, authorization, x_request_id, gids, names, sids, async_req=True)
        >>> result = thread.get()
        
        :param local_group: (required)
        :type local_group: models.LocalGroup
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param gids: Performs the operation on the specified GIDs. Enter multiple GIDs in comma-
                    separated format. For example, `4234235,9681923`.
        :type gids: List[int]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param sids: Performs the operation on the object SID specified. Enter multiple SIDs in
                    comma-separated format. For example,
                    `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type sids: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            local_group=local_group,
            authorization=authorization,
            x_request_id=x_request_id,
            gids=gids,
            names=names,
            sids=sids,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['gids', 'names', 'sids'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api232_directory_services_local_groups_patch_with_http_info', kwargs)

    def post_directory_services_local_groups(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="Performs the operation on the unique name specified. For example, `name01`. Enter multiple names in comma-separated format.")],
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        local_group: Optional['models.LocalGroupPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create local group  # noqa: E501
        
        Creates a local group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_services_local_groups_post_with_http_info(names, authorization, x_request_id, local_group, async_req=True)
        >>> result = thread.get()
        
        :param names: Performs the operation on the unique name specified. For example, `name01`.
                    Enter multiple names in comma-separated format. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param local_group:
        :type local_group: LocalGroupPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            authorization=authorization,
            x_request_id=x_request_id,
            local_group=local_group,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api232_directory_services_local_groups_post_with_http_info', kwargs)

    def delete_directory_services_local_users(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        sids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the object SID specified. Enter multiple SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        uids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of local user IDs (UIDs). Enter multiple local user IDs in comma-separated format. For example, `423,51234`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete local users  # noqa: E501
        
        Deletes one or more local users. The `uids`, `names`, or `sids` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_services_local_users_delete_with_http_info(authorization, x_request_id, names, sids, uids, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param sids: Performs the operation on the object SID specified. Enter multiple SIDs in
                    comma-separated format. For example,
                    `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type sids: List[str]
        :param uids: A comma-separated list of local user IDs (UIDs). Enter multiple local user IDs
                    in comma-separated format. For example, `423,51234`.
        :type uids: List[int]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            sids=sids,
            uids=uids,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sids', 'uids'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api232_directory_services_local_users_delete_with_http_info', kwargs)

    def get_directory_services_local_users(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the object SID specified. Enter multiple SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        uids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of local user IDs (UIDs). Enter multiple local user IDs in comma-separated format. For example, `423,51234`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List local users  # noqa: E501
        
        Displays a list of local users.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_services_local_users_get_with_http_info(authorization, x_request_id, continuation_token, filter, ids, limit, names, offset, sids, sort, total_item_count, uids, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sids: Performs the operation on the object SID specified. Enter multiple SIDs in
                    comma-separated format. For example,
                    `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type sids: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param uids: A comma-separated list of local user IDs (UIDs). Enter multiple local user IDs
                    in comma-separated format. For example, `423,51234`.
        :type uids: List[int]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sids=sids,
            sort=sort,
            total_item_count=total_item_count,
            uids=uids,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sids', 'sort', 'uids'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api232_directory_services_local_users_get_with_http_info', kwargs)

    def delete_directory_services_local_users_members(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        group_gids: Annotated[Optional[conlist(StrictInt)], Field(description="Performs the operation on the specified GIDs. Enter multiple GIDs in comma-separated format. For example, `4234235,9681923`.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the group names specified. Enter multiple group names in comma-separated format. For example, `group1,group2`.")] = None,
        group_sids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the specified group SID. Enter multiple group SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        member_ids: Annotated[Optional[conlist(StrictInt)], Field(description="Performs the operation on the unique local member IDs specified. Enter multiple member IDs in comma-separated format. For local group IDs refer to group IDs (GID). For local user IDs refer to user IDs (UID). The `member_ids` and `member_names` parameters cannot be provided together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        member_sids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the specified member SID. Enter multiple member SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        member_types: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the member types specified. The type of member is the full name of the resource endpoint. Valid values include `directories`. Enter multiple member types in comma-separated format. For example, `type01,type02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete local user membership  # noqa: E501
        
        Deletes one or more local user memberships. The `member_names`, `member_sids`, or `member_ids` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_services_local_users_members_delete_with_http_info(authorization, x_request_id, group_gids, group_names, group_sids, member_ids, member_names, member_sids, member_types, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param group_gids: Performs the operation on the specified GIDs. Enter multiple GIDs in comma-
                        separated format. For example, `4234235,9681923`.
        :type group_gids: List[int]
        :param group_names: Performs the operation on the group names specified. Enter multiple group names
                            in comma-separated format. For example, `group1,group2`.
        :type group_names: List[str]
        :param group_sids: Performs the operation on the specified group SID. Enter multiple group SIDs in
                        comma-separated format. For example,
                        `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type group_sids: List[str]
        :param member_ids: Performs the operation on the unique local member IDs specified. Enter multiple
                        member IDs in comma-separated format. For local group IDs refer to group IDs
                        (GID). For local user IDs refer to user IDs (UID). The `member_ids` and
                        `member_names` parameters cannot be provided together.
        :type member_ids: List[int]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param member_sids: Performs the operation on the specified member SID. Enter multiple member SIDs
                            in comma-separated format. For example,
                            `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type member_sids: List[str]
        :param member_types: Performs the operation on the member types specified. The type of member is the
                            full name of the resource endpoint. Valid values include `directories`.
                            Enter multiple member types in comma-separated format. For example,
                            `type01,type02`.
        :type member_types: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            group_gids=group_gids,
            group_names=group_names,
            group_sids=group_sids,
            member_ids=member_ids,
            member_names=member_names,
            member_sids=member_sids,
            member_types=member_types,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _fixup_list_type_params(['group_gids', 'group_names', 'group_sids', 'member_ids', 'member_names', 'member_sids', 'member_types'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api232_directory_services_local_users_members_delete_with_http_info', kwargs)

    def get_directory_services_local_users_members(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        group_gids: Annotated[Optional[conlist(StrictInt)], Field(description="Performs the operation on the specified GIDs. Enter multiple GIDs in comma-separated format. For example, `4234235,9681923`.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the group names specified. Enter multiple group names in comma-separated format. For example, `group1,group2`.")] = None,
        group_sids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the specified group SID. Enter multiple group SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_ids: Annotated[Optional[conlist(StrictInt)], Field(description="Performs the operation on the unique local member IDs specified. Enter multiple member IDs in comma-separated format. For local group IDs refer to group IDs (GID). For local user IDs refer to user IDs (UID). The `member_ids` and `member_names` parameters cannot be provided together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        member_sids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the specified member SID. Enter multiple member SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List local user memberships  # noqa: E501
        
        Displays a list of local user memberships.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_services_local_users_members_get_with_http_info(authorization, x_request_id, continuation_token, filter, group_gids, group_names, group_sids, limit, member_ids, member_names, member_sids, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param group_gids: Performs the operation on the specified GIDs. Enter multiple GIDs in comma-
                        separated format. For example, `4234235,9681923`.
        :type group_gids: List[int]
        :param group_names: Performs the operation on the group names specified. Enter multiple group names
                            in comma-separated format. For example, `group1,group2`.
        :type group_names: List[str]
        :param group_sids: Performs the operation on the specified group SID. Enter multiple group SIDs in
                        comma-separated format. For example,
                        `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type group_sids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_ids: Performs the operation on the unique local member IDs specified. Enter multiple
                        member IDs in comma-separated format. For local group IDs refer to group IDs
                        (GID). For local user IDs refer to user IDs (UID). The `member_ids` and
                        `member_names` parameters cannot be provided together.
        :type member_ids: List[int]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param member_sids: Performs the operation on the specified member SID. Enter multiple member SIDs
                            in comma-separated format. For example,
                            `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type member_sids: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            group_gids=group_gids,
            group_names=group_names,
            group_sids=group_sids,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            member_sids=member_sids,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _fixup_list_type_params(['group_gids', 'group_names', 'group_sids', 'member_ids', 'member_names', 'member_sids', 'sort'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api232_directory_services_local_users_members_get_with_http_info', kwargs)

    def post_directory_services_local_users_members(
        self,
        local_membership: Annotated['models.LocalUserMembershipPost', Field(..., description="The `group_names`, `group_sids`, or `group_gids` parameter is required, but cannot be set together.")],
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[conlist(StrictInt)], Field(description="Performs the operation on the unique local member IDs specified. Enter multiple member IDs in comma-separated format. For local group IDs refer to group IDs (GID). For local user IDs refer to user IDs (UID). The `member_ids` and `member_names` parameters cannot be provided together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        member_sids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the specified member SID. Enter multiple member SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create local user membership  # noqa: E501
        
        Creates a local user membership with a group. The `member_names` or `member_sids` or `member_ids` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_services_local_users_members_post_with_http_info(local_membership, authorization, x_request_id, member_ids, member_names, member_sids, async_req=True)
        >>> result = thread.get()
        
        :param local_membership: The `group_names`, `group_sids`, or `group_gids` parameter is required, but
                                cannot be set together. (required)
        :type local_membership: models.LocalUserMembershipPost
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: Performs the operation on the unique local member IDs specified. Enter multiple
                        member IDs in comma-separated format. For local group IDs refer to group IDs
                        (GID). For local user IDs refer to user IDs (UID). The `member_ids` and
                        `member_names` parameters cannot be provided together.
        :type member_ids: List[int]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param member_sids: Performs the operation on the specified member SID. Enter multiple member SIDs
                            in comma-separated format. For example,
                            `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type member_sids: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            local_membership=local_membership,
            authorization=authorization,
            x_request_id=x_request_id,
            member_ids=member_ids,
            member_names=member_names,
            member_sids=member_sids,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'member_sids'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api232_directory_services_local_users_members_post_with_http_info', kwargs)

    def patch_directory_services_local_users(
        self,
        local_user: 'models.LocalUserPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        keep_open_sessions: Annotated[Optional[StrictBool], Field(description="If set to `true`, the session does not expire. If set to `false`, when the user is disabled or password is changed, the session expires. If not specified, defaults to `false`.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        sids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the object SID specified. Enter multiple SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        uids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of local user IDs (UIDs). Enter multiple local user IDs in comma-separated format. For example, `423,51234`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify local user  # noqa: E501
        
        Modifies a local user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_services_local_users_patch_with_http_info(local_user, authorization, x_request_id, keep_open_sessions, names, sids, uids, async_req=True)
        >>> result = thread.get()
        
        :param local_user: (required)
        :type local_user: models.LocalUserPatch
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param keep_open_sessions: If set to `true`, the session does not expire. If set to `false`, when the user
                                is disabled or password is changed, the session expires. If not specified,
                                defaults to `false`.
        :type keep_open_sessions: bool
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param sids: Performs the operation on the object SID specified. Enter multiple SIDs in
                    comma-separated format. For example,
                    `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type sids: List[str]
        :param uids: A comma-separated list of local user IDs (UIDs). Enter multiple local user IDs
                    in comma-separated format. For example, `423,51234`.
        :type uids: List[int]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            local_user=local_user,
            authorization=authorization,
            x_request_id=x_request_id,
            keep_open_sessions=keep_open_sessions,
            names=names,
            sids=sids,
            uids=uids,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sids', 'uids'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api232_directory_services_local_users_patch_with_http_info', kwargs)

    def post_directory_services_local_users(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="Performs the operation on the unique name specified. For example, `name01`. Enter multiple names in comma-separated format.")],
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        local_user: Optional['models.LocalUserPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create local user  # noqa: E501
        
        Creates a local user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_services_local_users_post_with_http_info(names, authorization, x_request_id, local_user, async_req=True)
        >>> result = thread.get()
        
        :param names: Performs the operation on the unique name specified. For example, `name01`.
                    Enter multiple names in comma-separated format. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param local_user:
        :type local_user: LocalUserPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            authorization=authorization,
            x_request_id=x_request_id,
            local_user=local_user,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api232_directory_services_local_users_post_with_http_info', kwargs)

    def patch_directory_services(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="Performs the operation on the unique name specified. For example, `name01`. Enter multiple names in comma-separated format.")],
        directory_service: 'models.DirectoryService',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify directory services configuration  # noqa: E501
        
        Modifies the directory service configuration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_services_patch_with_http_info(names, directory_service, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param names: Performs the operation on the unique name specified. For example, `name01`.
                    Enter multiple names in comma-separated format. (required)
        :type names: List[str]
        :param directory_service: (required)
        :type directory_service: models.DirectoryService
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            directory_service=directory_service,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api232_directory_services_patch_with_http_info', kwargs)

    def delete_directory_services_roles(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="Performs the operation on the unique names specified. For example, `GroupRoleMappingName`. Enter multiple names in comma-separated format.")],
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a group to role mapping  # noqa: E501
        
        Delete a group to role mapping  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_services_roles_delete_with_http_info(names, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param names: Performs the operation on the unique names specified. For example,
                    `GroupRoleMappingName`. Enter multiple names in comma-separated format.
                    (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api232_directory_services_roles_delete_with_http_info', kwargs)

    def get_directory_services_roles(
        self,
        roles: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique names specified. For example, `GroupRoleMappingName`. Enter multiple names in comma-separated format.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        role_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique roles specified. For example, `array_admin`. Enter multiple roles in comma-separated format.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List directory services roles  # noqa: E501
        
        Displays the role-based access control (RBAC) group role settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_services_roles_get_with_http_info(authorization, x_request_id, continuation_token, filter, limit, names, offset, role_names, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param roles: A list of roles to query for. Overrides role_names keyword argument.
        :type roles: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique names specified. For example,
                    `GroupRoleMappingName`. Enter multiple names in comma-separated format.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param role_names: Performs the operation on the unique roles specified. For example,
                        `array_admin`. Enter multiple roles in comma-separated format.
        :type role_names: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            role_names=role_names,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _process_references(roles, ['role_names'], kwargs)
        _fixup_list_type_params(['names', 'role_names', 'sort'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api232_directory_services_roles_get_with_http_info', kwargs)

    def patch_directory_services_roles(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="Performs the operation on the unique names specified. For example, `GroupRoleMappingName`. Enter multiple names in comma-separated format.")],
        directory_service_roles: 'models.DirectoryServiceRole',
        roles: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        role_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique roles specified. For example, `array_admin`. Enter multiple roles in comma-separated format.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify a group to role mapping  # noqa: E501
        
        Modifies group to role mapping entries  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_services_roles_patch_with_http_info(names, directory_service_roles, authorization, x_request_id, role_names, async_req=True)
        >>> result = thread.get()
        
        :param names: Performs the operation on the unique names specified. For example,
                    `GroupRoleMappingName`. Enter multiple names in comma-separated format.
                    (required)
        :type names: List[str]
        :param directory_service_roles: (required)
        :type directory_service_roles: models.DirectoryServiceRole
        :param roles: A list of roles to query for. Overrides role_names keyword argument.
        :type roles: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param role_names: Performs the operation on the unique roles specified. For example,
                        `array_admin`. Enter multiple roles in comma-separated format.
        :type role_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            directory_service_roles=directory_service_roles,
            authorization=authorization,
            x_request_id=x_request_id,
            role_names=role_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _process_references(roles, ['role_names'], kwargs)
        _fixup_list_type_params(['names', 'role_names'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api232_directory_services_roles_patch_with_http_info', kwargs)

    def post_directory_services_roles(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="Performs the operation on the unique names specified. For example, `GroupRoleMappingName`. Enter multiple names in comma-separated format.")],
        directory_service_roles: 'models.DirectoryServiceRole',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Add group to role mapping  # noqa: E501
        
        Add group to role mapping  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_services_roles_post_with_http_info(names, directory_service_roles, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param names: Performs the operation on the unique names specified. For example,
                    `GroupRoleMappingName`. Enter multiple names in comma-separated format.
                    (required)
        :type names: List[str]
        :param directory_service_roles: (required)
        :type directory_service_roles: models.DirectoryServiceRole
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            directory_service_roles=directory_service_roles,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api232_directory_services_roles_post_with_http_info', kwargs)

    def get_directory_services_test(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="Performs the operation on the unique name specified. For example, `name01`. Enter multiple names in comma-separated format.")],
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List directory services test results  # noqa: E501
        
        Displays the directory services test and displays the results. The test verifies that URIs can be resolved and that the array can bind and query the tree using the bind user credentials. The test also verifies that the array can find all configured groups to ensure the common names and group base are correctly configured.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_services_test_get_with_http_info(names, authorization, x_request_id, continuation_token, filter, limit, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param names: Performs the operation on the unique name specified. For example, `name01`.
                    Enter multiple names in comma-separated format. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api232_directory_services_test_get_with_http_info', kwargs)

    def delete_directory_snapshots(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete directory snapshot  # noqa: E501
        
        Deletes a directory snapshot that has been destroyed and is pending eradication. Eradicated directory snapshots cannot be recovered. Directory snapshots are destroyed by using the PATCH method. The `ids` or `names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_snapshots_delete_with_http_info(authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('DirectorySnapshotsApi', 'api232_directory_snapshots_delete_with_http_info', kwargs)

    def get_directory_snapshots(
        self,
        sources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        source_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source ID specified. Enter multiple source IDs in comma-separated format.")] = None,
        source_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source name specified. Enter multiple source names in comma-separated format. For example, `name01,name02`.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List directory snapshots  # noqa: E501
        
        Displays a list of directory snapshots, including those pending eradication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_snapshots_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, ids, limit, names, offset, sort, source_ids, source_names, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param sources: A list of sources to query for. Overrides source_ids and source_names keyword arguments.
        :type sources: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param source_ids: Performs the operation on the source ID specified. Enter multiple source IDs in
                        comma-separated format.
        :type source_ids: List[str]
        :param source_names: Performs the operation on the source name specified. Enter multiple source names
                            in comma-separated format. For example, `name01,name02`.
        :type source_names: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            source_ids=source_ids,
            source_names=source_names,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _process_references(sources, ['source_ids', 'source_names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort', 'source_ids', 'source_names'], kwargs)
        return self._call_api('DirectorySnapshotsApi', 'api232_directory_snapshots_get_with_http_info', kwargs)

    def patch_directory_snapshots(
        self,
        directory_snapshot: 'models.DirectorySnapshotPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify directory snapshot  # noqa: E501
        
        Modifies a directory snapshot. You can destroy, recover, or update the policy or time remaining of a directory snapshot. To destroy a directory snapshot, set `destroyed=true`. To recover a directory snapshot that has been destroyed and is pending eradication, set `destroyed=false`. To rename a directory snapshot, set `name` to the new name. The `ids` or `names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_snapshots_patch_with_http_info(directory_snapshot, authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param directory_snapshot: (required)
        :type directory_snapshot: models.DirectorySnapshotPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            directory_snapshot=directory_snapshot,
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('DirectorySnapshotsApi', 'api232_directory_snapshots_patch_with_http_info', kwargs)

    def post_directory_snapshots(
        self,
        directory_snapshot: 'models.DirectorySnapshotPost',
        sources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        source_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source ID specified. Enter multiple source IDs in comma-separated format.")] = None,
        source_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source name specified. Enter multiple source names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create directory snapshot  # noqa: E501
        
        Creates a snapshot of the contents of a directory. The `source_ids` or `source_names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_directory_snapshots_post_with_http_info(directory_snapshot, authorization, x_request_id, source_ids, source_names, async_req=True)
        >>> result = thread.get()
        
        :param directory_snapshot: (required)
        :type directory_snapshot: models.DirectorySnapshotPost
        :param sources: A list of sources to query for. Overrides source_ids and source_names keyword arguments.
        :type sources: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param source_ids: Performs the operation on the source ID specified. Enter multiple source IDs in
                        comma-separated format.
        :type source_ids: List[str]
        :param source_names: Performs the operation on the source name specified. Enter multiple source names
                            in comma-separated format. For example, `name01,name02`.
        :type source_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            directory_snapshot=directory_snapshot,
            authorization=authorization,
            x_request_id=x_request_id,
            source_ids=source_ids,
            source_names=source_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(sources, ['source_ids', 'source_names'], kwargs)
        _fixup_list_type_params(['source_ids', 'source_names'], kwargs)
        return self._call_api('DirectorySnapshotsApi', 'api232_directory_snapshots_post_with_http_info', kwargs)

    def get_drives(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List flash, NVRAM, and cache modules  # noqa: E501
        
        Displays a list of flash, NVRAM, and cache modules that are installed in the array along with their attributes and status.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_drives_get_with_http_info(authorization, x_request_id, continuation_token, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('DrivesApi', 'api232_drives_get_with_http_info', kwargs)

    def patch_drives(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        admit: Annotated[Optional[StrictBool], Field(description="If `true`, admits any `unadmitted` drives into the system.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify flash and NVRAM modules  # noqa: E501
        
        Modifies flash and NVRAM modules that have been added or connected but not yet admitted to the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_drives_patch_with_http_info(authorization, x_request_id, admit, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param admit: If `true`, admits any `unadmitted` drives into the system.
        :type admit: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            admit=admit,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('DrivesApi', 'api232_drives_patch_with_http_info', kwargs)

    def delete_file_systems(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete file system  # noqa: E501
        
        Deletes a file system that has been destroyed and is pending eradication. Eradicated file systems cannot be recovered. File systems are destroyed using the PATCH method.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_file_systems_delete_with_http_info(authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('FileSystemsApi', 'api232_file_systems_delete_with_http_info', kwargs)

    def get_file_systems(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List file systems  # noqa: E501
        
        Displays a list of file systems, including those pending eradication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_file_systems_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, ids, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('FileSystemsApi', 'api232_file_systems_get_with_http_info', kwargs)

    def patch_file_systems(
        self,
        file_system: 'models.FileSystemPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify a file system  # noqa: E501
        
        Modifies a file system. You can rename, destroy, move, or recover a file system. To rename a file system, set `name` to the new name. To destroy a file system, set `destroyed=true`. To move a file system, set 'pod' to the destination pod reference. To recover a file system that has been destroyed and is pending eradication, set `destroyed=false`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_file_systems_patch_with_http_info(file_system, authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param file_system: (required)
        :type file_system: models.FileSystemPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            file_system=file_system,
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('FileSystemsApi', 'api232_file_systems_patch_with_http_info', kwargs)

    def post_file_systems(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="Performs the operation on the unique name specified. For example, `name01`. Enter multiple names in comma-separated format.")],
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create file system  # noqa: E501
        
        Creates one or more file systems.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_file_systems_post_with_http_info(names, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param names: Performs the operation on the unique name specified. For example, `name01`.
                    Enter multiple names in comma-separated format. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('FileSystemsApi', 'api232_file_systems_post_with_http_info', kwargs)

    def post_files(
        self,
        source_file: 'models.FilePost',
        directories: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        directory_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique managed directory IDs specified. Enter multiple managed directory IDs in comma-separated format. The `directory_ids` or `directory_names` parameter is required, but they cannot be set together.")] = None,
        directory_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the managed directory names specified. Enter multiple full managed directory names in comma-separated format. For example, `fs:dir01,fs:dir02`.")] = None,
        overwrite: Annotated[Optional[StrictBool], Field(description="If set to `true`, overwrites an existing object during an object copy operation. If set to `false` or not set at all and the target name is an existing object, the copy operation fails. Required if the `source` body parameter is set and the source overwrites an existing object during the copy operation.")] = None,
        paths: Annotated[Optional[conlist(StrictStr)], Field(description="Target file path relative to the target directory. Enter multiple target file path in a comma-separated format. For example, `/dir1/dir2/file1,/dir3/dir4/file2`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a file copy  # noqa: E501
        
        Creates a file copy from one path to another path. The `directory_ids`, `directory_names` or `paths` value must be specified. If the `directory_ids` or `directory_names` value is not specified, the file is copied to the source directory specified in the body params. The `paths` value refers to the path of the target file relative to the target directory. If `paths` value is not specified, the file will be copied to the relative path specified in `source_path` under the target directory. The `source_path` value refers to the path of the source file relative to the source directory. To overwrite an existing file, set the `overwrite` flag to `true`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_files_post_with_http_info(source_file, authorization, x_request_id, directory_ids, directory_names, overwrite, paths, async_req=True)
        >>> result = thread.get()
        
        :param source_file: (required)
        :type source_file: models.FilePost
        :param directories: A list of directories to query for. Overrides directory_ids and directory_names keyword arguments.
        :type directories: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param directory_ids: Performs the operation on the unique managed directory IDs specified. Enter
                            multiple managed directory IDs in comma-separated format. The
                            `directory_ids` or `directory_names` parameter is required, but they cannot
                            be set together.
        :type directory_ids: List[str]
        :param directory_names: Performs the operation on the managed directory names specified. Enter multiple
                                full managed directory names in comma-separated format. For example,
                                `fs:dir01,fs:dir02`.
        :type directory_names: List[str]
        :param overwrite: If set to `true`, overwrites an existing object during an object copy operation.
                        If set to `false` or not set at all and the target name is an existing
                        object, the copy operation fails. Required if the `source` body parameter is
                        set and the source overwrites an existing object during the copy operation.
        :type overwrite: bool
        :param paths: Target file path relative to the target directory. Enter multiple target file
                    path in a comma-separated format. For example,
                    `/dir1/dir2/file1,/dir3/dir4/file2`.
        :type paths: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            source_file=source_file,
            authorization=authorization,
            x_request_id=x_request_id,
            directory_ids=directory_ids,
            directory_names=directory_names,
            overwrite=overwrite,
            paths=paths,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(directories, ['directory_ids', 'directory_names'], kwargs)
        _fixup_list_type_params(['directory_ids', 'directory_names', 'paths'], kwargs)
        return self._call_api('FilesApi', 'api232_files_post_with_http_info', kwargs)

    def get_hardware(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List hardware component information  # noqa: E501
        
        Displays a list of hardware slots and bays and status of installed components.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_hardware_get_with_http_info(authorization, x_request_id, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('HardwareApi', 'api232_hardware_get_with_http_info', kwargs)

    def patch_hardware(
        self,
        hardware: 'models.HardwarePatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify visual identification  # noqa: E501
        
        Modifies the visual identification of a specified hardware component, and causing the ID LED to turn on or off.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_hardware_patch_with_http_info(hardware, authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param hardware: (required)
        :type hardware: models.HardwarePatch
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            hardware=hardware,
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('HardwareApi', 'api232_hardware_patch_with_http_info', kwargs)

    def delete_host_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a host group  # noqa: E501
        
        Deletes a host group. The `names` query parameter is required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_host_groups_delete_with_http_info(authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('HostGroupsApi', 'api232_host_groups_delete_with_http_info', kwargs)

    def get_host_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List host groups  # noqa: E501
        
        Displays a list of host groups.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_host_groups_get_with_http_info(authorization, x_request_id, continuation_token, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('HostGroupsApi', 'api232_host_groups_get_with_http_info', kwargs)

    def delete_host_groups_hosts(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Remove a host from a host group  # noqa: E501
        
        Removes a host from a host group. Removing a host from a host group automatically disconnects the host from all volumes associated with the group. Hosts can be removed from host groups at any time. The `group_names` and `member_names` parameters are required and must be set together, and only one host group can be specified at a time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_host_groups_hosts_delete_with_http_info(authorization, x_request_id, group_names, member_names, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_names keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            group_names=group_names,
            member_names=member_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_names'], kwargs)
        _process_references(members, ['member_names'], kwargs)
        _fixup_list_type_params(['group_names', 'member_names'], kwargs)
        return self._call_api('HostGroupsApi', 'api232_host_groups_hosts_delete_with_http_info', kwargs)

    def get_host_groups_hosts(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List host groups that are associated with hosts  # noqa: E501
        
        Returns a list of host groups that are associated with hosts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_host_groups_hosts_get_with_http_info(authorization, x_request_id, continuation_token, filter, group_names, limit, member_names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_names keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            group_names=group_names,
            limit=limit,
            member_names=member_names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_names'], kwargs)
        _process_references(members, ['member_names'], kwargs)
        _fixup_list_type_params(['group_names', 'member_names', 'sort'], kwargs)
        return self._call_api('HostGroupsApi', 'api232_host_groups_hosts_get_with_http_info', kwargs)

    def post_host_groups_hosts(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Add a host to a host group  # noqa: E501
        
        Adds a host to a host group. Adding a host to a host group automatically connects the host to all volumes associated with the group. Multiple hosts can be belong to a host group, but a host can only belong to one host group. Hosts can be added to host groups at any time. The `group_names` and `member_names` parameters are required and must be set together, and only one host group can be specified at a time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_host_groups_hosts_post_with_http_info(authorization, x_request_id, group_names, member_names, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_names keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            group_names=group_names,
            member_names=member_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_names'], kwargs)
        _process_references(members, ['member_names'], kwargs)
        _fixup_list_type_params(['group_names', 'member_names'], kwargs)
        return self._call_api('HostGroupsApi', 'api232_host_groups_hosts_post_with_http_info', kwargs)

    def patch_host_groups(
        self,
        host_group: 'models.HostGroupPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify a host group  # noqa: E501
        
        Modifies a host group. The `names` query parameter is required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_host_groups_patch_with_http_info(host_group, authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param host_group: (required)
        :type host_group: models.HostGroupPatch
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            host_group=host_group,
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('HostGroupsApi', 'api232_host_groups_patch_with_http_info', kwargs)

    def get_host_groups_performance_by_array(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The number of milliseconds between samples of historical data. For array-wide performance metrics (`/arrays/performance` endpoint), valid values are `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For performance metrics on storage objects (`<object name>/performance` endpoint), such as volumes, valid values are `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For space metrics, (`<object name>/space` endpoint), valid values are `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). Include the `start_time` parameter to display the performance data starting at the specified start time. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. Include the `end_time` parameter to display the performance data until the specified end time. If `end_time`is not specified, the end time will default to the current time. If the `resolution` parameter is not specified but either the `start_time` or `end_time` parameter is, then `resolution` will default to the lowest valid resolution.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List host group performance data by array  # noqa: E501
        
        Displays real-time and historical performance data, real-time latency data, and average I/O size data. The data is displayed by total size across all host groups on each array and by individual host group on each array. The displayed data represents the volumes that are connected to a host group on the current array and the volumes that are connected to a host group on any remote arrays that are visible to the current array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_host_groups_performance_by_array_get_with_http_info(authorization, x_request_id, end_time, filter, limit, names, offset, resolution, sort, start_time, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param end_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type end_time: int
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param resolution: The number of milliseconds between samples of historical data. For array-wide
                        performance metrics (`/arrays/performance` endpoint), valid values are
                        `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30
                        minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24
                        hours). For performance metrics on storage objects (`<object
                        name>/performance` endpoint), such as volumes, valid values are `30000` (30
                        seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours),
                        `28800000` (8 hours), and `86400000` (24 hours). For space metrics,
                        (`<object name>/space` endpoint), valid values are `300000` (5 minutes),
                        `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and
                        `86400000` (24 hours). Include the `start_time` parameter to display the
                        performance data starting at the specified start time. If `start_time` is
                        not specified, the start time will default to one resolution before the end
                        time, meaning that the most recent sample of performance data will be
                        displayed. Include the `end_time` parameter to display the performance data
                        until the specified end time. If `end_time`is not specified, the end time
                        will default to the current time. If the `resolution` parameter is not
                        specified but either the `start_time` or `end_time` parameter is, then
                        `resolution` will default to the lowest valid resolution.
        :type resolution: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param start_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type start_time: int
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            end_time=end_time,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('HostGroupsApi', 'api232_host_groups_performance_by_array_get_with_http_info', kwargs)

    def get_host_groups_performance(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The number of milliseconds between samples of historical data. For array-wide performance metrics (`/arrays/performance` endpoint), valid values are `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For performance metrics on storage objects (`<object name>/performance` endpoint), such as volumes, valid values are `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For space metrics, (`<object name>/space` endpoint), valid values are `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). Include the `start_time` parameter to display the performance data starting at the specified start time. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. Include the `end_time` parameter to display the performance data until the specified end time. If `end_time`is not specified, the end time will default to the current time. If the `resolution` parameter is not specified but either the `start_time` or `end_time` parameter is, then `resolution` will default to the lowest valid resolution.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List host group performance data  # noqa: E501
        
        Displays real-time and historical performance data, real-time latency data, and average I/O sizes of all host groups, displayed both by host group and by total size across all host groups. This data represents volumes that are connected to the host groups on the local array and stretched volumes connected to the host groups on arrays that are connected by synchronous replication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_host_groups_performance_get_with_http_info(authorization, x_request_id, end_time, filter, limit, names, offset, resolution, sort, start_time, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param end_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type end_time: int
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param resolution: The number of milliseconds between samples of historical data. For array-wide
                        performance metrics (`/arrays/performance` endpoint), valid values are
                        `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30
                        minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24
                        hours). For performance metrics on storage objects (`<object
                        name>/performance` endpoint), such as volumes, valid values are `30000` (30
                        seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours),
                        `28800000` (8 hours), and `86400000` (24 hours). For space metrics,
                        (`<object name>/space` endpoint), valid values are `300000` (5 minutes),
                        `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and
                        `86400000` (24 hours). Include the `start_time` parameter to display the
                        performance data starting at the specified start time. If `start_time` is
                        not specified, the start time will default to one resolution before the end
                        time, meaning that the most recent sample of performance data will be
                        displayed. Include the `end_time` parameter to display the performance data
                        until the specified end time. If `end_time`is not specified, the end time
                        will default to the current time. If the `resolution` parameter is not
                        specified but either the `start_time` or `end_time` parameter is, then
                        `resolution` will default to the lowest valid resolution.
        :type resolution: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param start_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type start_time: int
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            end_time=end_time,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('HostGroupsApi', 'api232_host_groups_performance_get_with_http_info', kwargs)

    def post_host_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a host group  # noqa: E501
        
        Creates a host group. The `names` query parameter is required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_host_groups_post_with_http_info(authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('HostGroupsApi', 'api232_host_groups_post_with_http_info', kwargs)

    def delete_host_groups_protection_groups(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a host group from a protection group  # noqa: E501
        
        Deletes a host group member from a protection group. After the member has been removed, it is no longer protected by the group. Any protection group snapshots that were taken before the member was removed are not affected. Removing a member from a protection group does not delete the member from the array, and the member can be added back to the protection group at any time. The `group_names` parameter represents the name of the protection group, and the `member_names` parameter represents the name of the host group. The `group_names` and `member_names` parameters are required and must be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_host_groups_protection_groups_delete_with_http_info(authorization, x_request_id, group_ids, group_names, member_names, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_names keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_ids and group_names keyword arguments.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param group_ids: A comma-separated list of group IDs.
        :type group_ids: List[str]
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            group_ids=group_ids,
            group_names=group_names,
            member_names=member_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_ids', 'group_names'], kwargs)
        _process_references(members, ['member_names'], kwargs)
        _fixup_list_type_params(['group_ids', 'group_names', 'member_names'], kwargs)
        return self._call_api('HostGroupsApi', 'api232_host_groups_protection_groups_delete_with_http_info', kwargs)

    def get_host_groups_protection_groups(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List host groups that are members of protection groups  # noqa: E501
        
        Displays a list of host group members that belong to one or more protection groups.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_host_groups_protection_groups_get_with_http_info(authorization, x_request_id, continuation_token, filter, group_ids, group_names, limit, member_names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_names keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_ids and group_names keyword arguments.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param group_ids: A comma-separated list of group IDs.
        :type group_ids: List[str]
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            group_ids=group_ids,
            group_names=group_names,
            limit=limit,
            member_names=member_names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_ids', 'group_names'], kwargs)
        _process_references(members, ['member_names'], kwargs)
        _fixup_list_type_params(['group_ids', 'group_names', 'member_names', 'sort'], kwargs)
        return self._call_api('HostGroupsApi', 'api232_host_groups_protection_groups_get_with_http_info', kwargs)

    def post_host_groups_protection_groups(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a host group  # noqa: E501
        
        Creates a host group member and assigns to a protection group. Members that are already in the protection group are not affected. For asynchronous replication, only members of the same type can belong to a protection group. The `group_names` parameter represents the name of the protection group, and the `member_names` parameter represents the name of the host group. The `group_names` and `member_names` parameters are required and must be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_host_groups_protection_groups_post_with_http_info(authorization, x_request_id, group_ids, group_names, member_names, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_names keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_ids and group_names keyword arguments.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param group_ids: A comma-separated list of group IDs.
        :type group_ids: List[str]
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            group_ids=group_ids,
            group_names=group_names,
            member_names=member_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_ids', 'group_names'], kwargs)
        _process_references(members, ['member_names'], kwargs)
        _fixup_list_type_params(['group_ids', 'group_names', 'member_names'], kwargs)
        return self._call_api('HostGroupsApi', 'api232_host_groups_protection_groups_post_with_http_info', kwargs)

    def get_host_groups_space(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List host group space information  # noqa: E501
        
        Displays provisioned size and physical storage consumption data for each host group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_host_groups_space_get_with_http_info(authorization, x_request_id, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('HostGroupsApi', 'api232_host_groups_space_get_with_http_info', kwargs)

    def delete_hosts(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a host  # noqa: E501
        
        Deletes an existing host. All volumes that are connected to the host, either through private or shared connections, must be disconnected from the host before the host can be deleted. The `names` query parameter is required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_hosts_delete_with_http_info(authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('HostsApi', 'api232_hosts_delete_with_http_info', kwargs)

    def get_hosts(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List hosts  # noqa: E501
        
        Displays a list of hosts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_hosts_get_with_http_info(authorization, x_request_id, continuation_token, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('HostsApi', 'api232_hosts_get_with_http_info', kwargs)

    def delete_hosts_host_groups(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Remove a host from a host group  # noqa: E501
        
        Removes a host from a host group. Removing a host from a host group automatically disconnects the host from all volumes associated with the group. Hosts can be removed from host groups at any time. The `group_names` and `member_names` parameters are required and must be set together, and only one host group can be specified at a time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_hosts_host_groups_delete_with_http_info(authorization, x_request_id, group_names, member_names, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_names keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            group_names=group_names,
            member_names=member_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_names'], kwargs)
        _process_references(members, ['member_names'], kwargs)
        _fixup_list_type_params(['group_names', 'member_names'], kwargs)
        return self._call_api('HostsApi', 'api232_hosts_host_groups_delete_with_http_info', kwargs)

    def get_hosts_host_groups(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List hosts that are associated with host groups  # noqa: E501
        
        Returns a list of hosts that are associated with host groups.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_hosts_host_groups_get_with_http_info(authorization, x_request_id, continuation_token, filter, group_names, limit, member_names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_names keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            group_names=group_names,
            limit=limit,
            member_names=member_names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_names'], kwargs)
        _process_references(members, ['member_names'], kwargs)
        _fixup_list_type_params(['group_names', 'member_names', 'sort'], kwargs)
        return self._call_api('HostsApi', 'api232_hosts_host_groups_get_with_http_info', kwargs)

    def post_hosts_host_groups(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Add a host to a host group  # noqa: E501
        
        Adds a host to a host group. Adding a host to a host group automatically connects the host to all volumes associated with the group. Multiple hosts can be belong to a host group, but a host can only belong to one host group. Hosts can be added to host groups at any time. The `group_names` and `member_names` parameters are required and must be set together, and only one host group can be specified at a time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_hosts_host_groups_post_with_http_info(authorization, x_request_id, group_names, member_names, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_names keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            group_names=group_names,
            member_names=member_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_names'], kwargs)
        _process_references(members, ['member_names'], kwargs)
        _fixup_list_type_params(['group_names', 'member_names'], kwargs)
        return self._call_api('HostsApi', 'api232_hosts_host_groups_post_with_http_info', kwargs)

    def patch_hosts(
        self,
        host: 'models.HostPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify a host  # noqa: E501
        
        Modifies an existing host, including its storage network addresses, CHAP, host personality, and preferred arrays, or associate a host to a host group. The `names` query parameter is required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_hosts_patch_with_http_info(host, authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param host: (required)
        :type host: models.HostPatch
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            host=host,
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('HostsApi', 'api232_hosts_patch_with_http_info', kwargs)

    def get_hosts_performance_balance(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List host performance balance  # noqa: E501
        
        Displays the I/O balance statistics for host paths.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_hosts_performance_balance_get_with_http_info(authorization, x_request_id, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('HostsApi', 'api232_hosts_performance_balance_get_with_http_info', kwargs)

    def get_hosts_performance_by_array(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The number of milliseconds between samples of historical data. For array-wide performance metrics (`/arrays/performance` endpoint), valid values are `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For performance metrics on storage objects (`<object name>/performance` endpoint), such as volumes, valid values are `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For space metrics, (`<object name>/space` endpoint), valid values are `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). Include the `start_time` parameter to display the performance data starting at the specified start time. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. Include the `end_time` parameter to display the performance data until the specified end time. If `end_time`is not specified, the end time will default to the current time. If the `resolution` parameter is not specified but either the `start_time` or `end_time` parameter is, then `resolution` will default to the lowest valid resolution.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List host performance data by array  # noqa: E501
        
        Displays real-time and historical performance data, real-time latency data, and average I/O size data. The data is displayed by total size across all hosts on each array and by individual host on each array. The displayed data represents the volumes that are connected to a host on the current array and the volumes that are connected to a host on any remote arrays that are visible to the current array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_hosts_performance_by_array_get_with_http_info(authorization, x_request_id, end_time, filter, limit, names, offset, resolution, sort, start_time, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param end_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type end_time: int
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param resolution: The number of milliseconds between samples of historical data. For array-wide
                        performance metrics (`/arrays/performance` endpoint), valid values are
                        `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30
                        minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24
                        hours). For performance metrics on storage objects (`<object
                        name>/performance` endpoint), such as volumes, valid values are `30000` (30
                        seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours),
                        `28800000` (8 hours), and `86400000` (24 hours). For space metrics,
                        (`<object name>/space` endpoint), valid values are `300000` (5 minutes),
                        `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and
                        `86400000` (24 hours). Include the `start_time` parameter to display the
                        performance data starting at the specified start time. If `start_time` is
                        not specified, the start time will default to one resolution before the end
                        time, meaning that the most recent sample of performance data will be
                        displayed. Include the `end_time` parameter to display the performance data
                        until the specified end time. If `end_time`is not specified, the end time
                        will default to the current time. If the `resolution` parameter is not
                        specified but either the `start_time` or `end_time` parameter is, then
                        `resolution` will default to the lowest valid resolution.
        :type resolution: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param start_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type start_time: int
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            end_time=end_time,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('HostsApi', 'api232_hosts_performance_by_array_get_with_http_info', kwargs)

    def get_hosts_performance(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The number of milliseconds between samples of historical data. For array-wide performance metrics (`/arrays/performance` endpoint), valid values are `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For performance metrics on storage objects (`<object name>/performance` endpoint), such as volumes, valid values are `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For space metrics, (`<object name>/space` endpoint), valid values are `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). Include the `start_time` parameter to display the performance data starting at the specified start time. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. Include the `end_time` parameter to display the performance data until the specified end time. If `end_time`is not specified, the end time will default to the current time. If the `resolution` parameter is not specified but either the `start_time` or `end_time` parameter is, then `resolution` will default to the lowest valid resolution.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List host performance data  # noqa: E501
        
        Displays real-time and historical performance data, real-time latency data, and average I/O sizes across all hosts, displayed by host and by total size across all hosts. This data represents volumes that are connected to the hosts on the local array and stretched volumes connected to the hosts on any arrays that are connected by synchronous replication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_hosts_performance_get_with_http_info(authorization, x_request_id, end_time, filter, limit, names, offset, resolution, sort, start_time, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param end_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type end_time: int
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param resolution: The number of milliseconds between samples of historical data. For array-wide
                        performance metrics (`/arrays/performance` endpoint), valid values are
                        `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30
                        minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24
                        hours). For performance metrics on storage objects (`<object
                        name>/performance` endpoint), such as volumes, valid values are `30000` (30
                        seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours),
                        `28800000` (8 hours), and `86400000` (24 hours). For space metrics,
                        (`<object name>/space` endpoint), valid values are `300000` (5 minutes),
                        `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and
                        `86400000` (24 hours). Include the `start_time` parameter to display the
                        performance data starting at the specified start time. If `start_time` is
                        not specified, the start time will default to one resolution before the end
                        time, meaning that the most recent sample of performance data will be
                        displayed. Include the `end_time` parameter to display the performance data
                        until the specified end time. If `end_time`is not specified, the end time
                        will default to the current time. If the `resolution` parameter is not
                        specified but either the `start_time` or `end_time` parameter is, then
                        `resolution` will default to the lowest valid resolution.
        :type resolution: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param start_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type start_time: int
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            end_time=end_time,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('HostsApi', 'api232_hosts_performance_get_with_http_info', kwargs)

    def post_hosts(
        self,
        host: 'models.HostPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a host  # noqa: E501
        
        Creates a host. The `names` query parameter is required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_hosts_post_with_http_info(host, authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param host: (required)
        :type host: models.HostPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            host=host,
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('HostsApi', 'api232_hosts_post_with_http_info', kwargs)

    def delete_hosts_protection_groups(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a host from a protection group  # noqa: E501
        
        Deletes a host member from a protection group. After the member has been removed, it is no longer protected by the group. Any protection group snapshots that were taken before the member was removed are not affected. Removing a member from a protection group does not delete the member from the array, and the member can be added back to the protection group at any time. The `group_names` parameter represents the name of the protection group, and the `member_names` parameter represents the name of the host. The `group_names` and `member_names` parameters are required and must be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_hosts_protection_groups_delete_with_http_info(authorization, x_request_id, group_ids, group_names, member_names, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_names keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_ids and group_names keyword arguments.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param group_ids: A comma-separated list of group IDs.
        :type group_ids: List[str]
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            group_ids=group_ids,
            group_names=group_names,
            member_names=member_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_ids', 'group_names'], kwargs)
        _process_references(members, ['member_names'], kwargs)
        _fixup_list_type_params(['group_ids', 'group_names', 'member_names'], kwargs)
        return self._call_api('HostsApi', 'api232_hosts_protection_groups_delete_with_http_info', kwargs)

    def get_hosts_protection_groups(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List hosts that are members of protection groups  # noqa: E501
        
        Displays a list of host members that belong to one or more protection groups.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_hosts_protection_groups_get_with_http_info(authorization, x_request_id, continuation_token, filter, group_ids, group_names, limit, member_names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_names keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_ids and group_names keyword arguments.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param group_ids: A comma-separated list of group IDs.
        :type group_ids: List[str]
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            group_ids=group_ids,
            group_names=group_names,
            limit=limit,
            member_names=member_names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_ids', 'group_names'], kwargs)
        _process_references(members, ['member_names'], kwargs)
        _fixup_list_type_params(['group_ids', 'group_names', 'member_names', 'sort'], kwargs)
        return self._call_api('HostsApi', 'api232_hosts_protection_groups_get_with_http_info', kwargs)

    def post_hosts_protection_groups(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a host  # noqa: E501
        
        Creates a host member and adds it to a protection group. Members that are already in the protection group are not affected. For asynchronous replication, only members of the same type can belong to a protection group. The `group_names` parameter represents the name of the protection group, and the `member_names` parameter represents the name of the host. The `group_names` and `member_names` parameters are required and must be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_hosts_protection_groups_post_with_http_info(authorization, x_request_id, group_ids, group_names, member_names, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_names keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_ids and group_names keyword arguments.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param group_ids: A comma-separated list of group IDs.
        :type group_ids: List[str]
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            group_ids=group_ids,
            group_names=group_names,
            member_names=member_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_ids', 'group_names'], kwargs)
        _process_references(members, ['member_names'], kwargs)
        _fixup_list_type_params(['group_ids', 'group_names', 'member_names'], kwargs)
        return self._call_api('HostsApi', 'api232_hosts_protection_groups_post_with_http_info', kwargs)

    def get_hosts_space(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List host space information  # noqa: E501
        
        Displays provisioned size and physical storage consumption data for each host.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_hosts_space_get_with_http_info(authorization, x_request_id, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('HostsApi', 'api232_hosts_space_get_with_http_info', kwargs)

    def delete_kmip(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete KMIP server object  # noqa: E501
        
        Deletes KMIP server objects.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_kmip_delete_with_http_info(authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('KMIPApi', 'api232_kmip_delete_with_http_info', kwargs)

    def get_kmip(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List KMIP server objects  # noqa: E501
        
        Displays the list of KMIP server objects.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_kmip_get_with_http_info(authorization, x_request_id, continuation_token, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('KMIPApi', 'api232_kmip_get_with_http_info', kwargs)

    def patch_kmip(
        self,
        kmip: 'models.KmipPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify KMIP attributes  # noqa: E501
        
        Modifies one or more attributes of KMIP server objects.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_kmip_patch_with_http_info(kmip, authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param kmip: (required)
        :type kmip: models.KmipPatch
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            kmip=kmip,
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('KMIPApi', 'api232_kmip_patch_with_http_info', kwargs)

    def post_kmip(
        self,
        kmip: 'models.KmipPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create KMIP server object  # noqa: E501
        
        Creates KMIP server objects.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_kmip_post_with_http_info(kmip, authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param kmip: (required)
        :type kmip: models.KmipPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            kmip=kmip,
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('KMIPApi', 'api232_kmip_post_with_http_info', kwargs)

    def get_kmip_test(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="Performs the operation on the unique name specified. For example, `name01`. Enter multiple names in comma-separated format.")],
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Lists KMIP connection tests  # noqa: E501
        
        Displays communication data between a FlashArray and KMIP server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_kmip_test_get_with_http_info(names, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param names: Performs the operation on the unique name specified. For example, `name01`.
                    Enter multiple names in comma-separated format. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('KMIPApi', 'api232_kmip_test_get_with_http_info', kwargs)

    def delete_maintenance_windows(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete maintenance window  # noqa: E501
        
        Deletes an open maintenance window before its scheduled end (`expire`) time. The `names` parameter is required and must be set to `environment`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_maintenance_windows_delete_with_http_info(authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('MaintenanceWindowsApi', 'api232_maintenance_windows_delete_with_http_info', kwargs)

    def get_maintenance_windows(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List maintenance window details  # noqa: E501
        
        Displays maintenance window details, including start time, end time, and maintenance type.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_maintenance_windows_get_with_http_info(authorization, x_request_id, continuation_token, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('MaintenanceWindowsApi', 'api232_maintenance_windows_get_with_http_info', kwargs)

    def post_maintenance_windows(
        self,
        maintenance_window: 'models.MaintenanceWindowPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a maintenance window  # noqa: E501
        
        Creates a maintenance window that suppresses alerts for a specified period of time. A maintenance window can be manually closed at any time. The `names` and `timeout` parameters are required. Set the `names` parameter to `environment`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_maintenance_windows_post_with_http_info(maintenance_window, authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param maintenance_window: (required)
        :type maintenance_window: models.MaintenanceWindowPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            maintenance_window=maintenance_window,
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('MaintenanceWindowsApi', 'api232_maintenance_windows_post_with_http_info', kwargs)

    def delete_network_interfaces(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete network interface  # noqa: E501
        
        Deletes a network interface on a controller.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_network_interfaces_delete_with_http_info(authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('NetworkInterfacesApi', 'api232_network_interfaces_delete_with_http_info', kwargs)

    def get_network_interfaces(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List network interfaces  # noqa: E501
        
        Displays all network interfaces for all controllers on the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_network_interfaces_get_with_http_info(authorization, x_request_id, continuation_token, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('NetworkInterfacesApi', 'api232_network_interfaces_get_with_http_info', kwargs)

    def get_network_interfaces_neighbors(
        self,
        local_ports: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        local_port_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique local port name specified. Enter multiple names in comma-separated format. For example, `ct0.eth0,ct1.eth0`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List network interface neighbors  # noqa: E501
        
        Displays all neighbors for all network interfaces on the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_network_interfaces_neighbors_get_with_http_info(authorization, x_request_id, filter, limit, local_port_names, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param local_ports: A list of local_ports to query for. Overrides local_port_names keyword argument.
        :type local_ports: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param local_port_names: Performs the operation on the unique local port name specified. Enter multiple
                                names in comma-separated format. For example, `ct0.eth0,ct1.eth0`.
        :type local_port_names: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            limit=limit,
            local_port_names=local_port_names,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(local_ports, ['local_port_names'], kwargs)
        _fixup_list_type_params(['local_port_names', 'sort'], kwargs)
        return self._call_api('NetworkInterfacesApi', 'api232_network_interfaces_neighbors_get_with_http_info', kwargs)

    def patch_network_interfaces(
        self,
        network: 'models.NetworkInterfacePatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify network interface  # noqa: E501
        
        Modifies a network interface on a controller.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_network_interfaces_patch_with_http_info(network, authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param network: (required)
        :type network: models.NetworkInterfacePatch
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            network=network,
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('NetworkInterfacesApi', 'api232_network_interfaces_patch_with_http_info', kwargs)

    def get_network_interfaces_performance(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The number of milliseconds between samples of historical data. For array-wide performance metrics (`/arrays/performance` endpoint), valid values are `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For performance metrics on storage objects (`<object name>/performance` endpoint), such as volumes, valid values are `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For space metrics, (`<object name>/space` endpoint), valid values are `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). Include the `start_time` parameter to display the performance data starting at the specified start time. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. Include the `end_time` parameter to display the performance data until the specified end time. If `end_time`is not specified, the end time will default to the current time. If the `resolution` parameter is not specified but either the `start_time` or `end_time` parameter is, then `resolution` will default to the lowest valid resolution.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List network performance statistics  # noqa: E501
        
        Displays network statistics, historical bandwidth, and error reporting for all specified network interfaces.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_network_interfaces_performance_get_with_http_info(authorization, x_request_id, end_time, filter, limit, names, offset, resolution, sort, start_time, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param end_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type end_time: int
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param resolution: The number of milliseconds between samples of historical data. For array-wide
                        performance metrics (`/arrays/performance` endpoint), valid values are
                        `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30
                        minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24
                        hours). For performance metrics on storage objects (`<object
                        name>/performance` endpoint), such as volumes, valid values are `30000` (30
                        seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours),
                        `28800000` (8 hours), and `86400000` (24 hours). For space metrics,
                        (`<object name>/space` endpoint), valid values are `300000` (5 minutes),
                        `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and
                        `86400000` (24 hours). Include the `start_time` parameter to display the
                        performance data starting at the specified start time. If `start_time` is
                        not specified, the start time will default to one resolution before the end
                        time, meaning that the most recent sample of performance data will be
                        displayed. Include the `end_time` parameter to display the performance data
                        until the specified end time. If `end_time`is not specified, the end time
                        will default to the current time. If the `resolution` parameter is not
                        specified but either the `start_time` or `end_time` parameter is, then
                        `resolution` will default to the lowest valid resolution.
        :type resolution: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param start_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type start_time: int
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            end_time=end_time,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('NetworkInterfacesApi', 'api232_network_interfaces_performance_get_with_http_info', kwargs)

    def get_network_interfaces_port_details(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List SFP port details  # noqa: E501
        
        Displays Ethernet and Fibre Channel SFP details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_network_interfaces_port_details_get_with_http_info(authorization, x_request_id, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('NetworkInterfacesApi', 'api232_network_interfaces_port_details_get_with_http_info', kwargs)

    def post_network_interfaces(
        self,
        network: 'models.NetworkInterfacePost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create network interface  # noqa: E501
        
        Creates a network interface on a controller on the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_network_interfaces_post_with_http_info(network, authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param network: (required)
        :type network: models.NetworkInterfacePost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            network=network,
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('NetworkInterfacesApi', 'api232_network_interfaces_post_with_http_info', kwargs)

    def delete_offloads(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete offload target  # noqa: E501
        
        Deletes an offload target.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_offloads_delete_with_http_info(authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('OffloadsApi', 'api232_offloads_delete_with_http_info', kwargs)

    def get_offloads(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        protocol: Annotated[Optional[StrictStr], Field(description="Protocol type. Valid values are `azure`, `google-cloud`, `nfs`, and `s3`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List offload targets  # noqa: E501
        
        Displays a list of offload targets that are connected to the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_offloads_get_with_http_info(authorization, x_request_id, filter, limit, names, offset, protocol, sort, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param protocol: Protocol type. Valid values are `azure`, `google-cloud`, `nfs`, and `s3`.
        :type protocol: str
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            protocol=protocol,
            sort=sort,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('OffloadsApi', 'api232_offloads_get_with_http_info', kwargs)

    def post_offloads(
        self,
        offload: 'models.OffloadPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        initialize: Annotated[Optional[StrictBool], Field(description="If set to `true`, initializes the Amazon S3/Azure Blob container/Google Cloud Storage in preparation for offloading. The parameter must be set to `true` if this is the first time the array is connecting to the offload target.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create offload target  # noqa: E501
        
        Creates an offload target, connecting it to an array. Before you can connect to, manage, and replicate to an offload target, the Purity Run app must be installed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_offloads_post_with_http_info(offload, authorization, x_request_id, initialize, names, async_req=True)
        >>> result = thread.get()
        
        :param offload: (required)
        :type offload: models.OffloadPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param initialize: If set to `true`, initializes the Amazon S3/Azure Blob container/Google Cloud
                        Storage in preparation for offloading. The parameter must be set to `true`
                        if this is the first time the array is connecting to the offload target.
        :type initialize: bool
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            offload=offload,
            authorization=authorization,
            x_request_id=x_request_id,
            initialize=initialize,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('OffloadsApi', 'api232_offloads_post_with_http_info', kwargs)

    def delete_pod_replica_links(
        self,
        remote_pods: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_pods: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        local_pod_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local pod IDs. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_pod_names` query parameter.")] = None,
        local_pod_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local pod names. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_pod_ids` query parameter.")] = None,
        remote_pod_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote pod IDs. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_pod_names` query parameter.")] = None,
        remote_pod_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote pod names. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_pod_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete pod replica links  # noqa: E501
        
        Deletes pod replica links. The `local_pod_names` and `remote_pod_names` are required. Valid values are `replicating`, `baselining`, `paused`, `unhealthy`, `quiescing`, and `quiesced`. A status of `replicating` indicates that the source array is replicating to the target array. A status of `baselining` indicates that the the initial version of the dataset is being sent. During this phase, you cannot promote the target pod. In addition, changing the link direction might trigger the `baselining` status to recur. A status of `paused ` indicates that data transfer between objects has stopped. A status of `unhealthy` indicates that the link is currently unhealthy and customers must perform some health checks to determine the cause. A status of `quiescing` indicates that the source pod is not accepting new write requests but the most recent changes to the source have not arrived on the target. A status of `quiesced` indicates that the source pod has been demoted and all changes have been replicated to the target pod.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_pod_replica_links_delete_with_http_info(authorization, x_request_id, ids, local_pod_ids, local_pod_names, remote_pod_ids, remote_pod_names, async_req=True)
        >>> result = thread.get()
        
        :param remote_pods: A list of remote_pods to query for. Overrides remote_pod_ids and remote_pod_names keyword arguments.
        :type remote_pods: ReferenceType or List[ReferenceType], optional
        :param local_pods: A list of local_pods to query for. Overrides local_pod_ids and local_pod_names keyword arguments.
        :type local_pods: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param local_pod_ids: A comma-separated list of local pod IDs. If, after filtering, there is not at
                            least one resource that matches each of the elements, then an error is
                            returned. This cannot be provided together with the `local_pod_names` query
                            parameter.
        :type local_pod_ids: List[str]
        :param local_pod_names: A comma-separated list of local pod names. If, after filtering, there is not at
                                least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `local_pod_ids` query
                                parameter.
        :type local_pod_names: List[str]
        :param remote_pod_ids: A comma-separated list of remote pod IDs. If, after filtering, there is not at
                            least one resource that matches each of the elements, then an error is
                            returned. This cannot be provided together with the `remote_pod_names`
                            query parameter.
        :type remote_pod_ids: List[str]
        :param remote_pod_names: A comma-separated list of remote pod names. If, after filtering, there is not at
                                least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `remote_pod_ids` query
                                parameter.
        :type remote_pod_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            local_pod_ids=local_pod_ids,
            local_pod_names=local_pod_names,
            remote_pod_ids=remote_pod_ids,
            remote_pod_names=remote_pod_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids'], kwargs)
        _process_references(local_pods, ['local_pod_ids', 'local_pod_names'], kwargs)
        _process_references(remote_pods, ['remote_pod_ids', 'remote_pod_names'], kwargs)
        _fixup_list_type_params(['ids', 'local_pod_ids', 'local_pod_names', 'remote_pod_ids', 'remote_pod_names'], kwargs)
        return self._call_api('PodReplicaLinksApi', 'api232_pod_replica_links_delete_with_http_info', kwargs)

    def get_pod_replica_links(
        self,
        remote_pods: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_pods: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        local_pod_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local pod IDs. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_pod_names` query parameter.")] = None,
        local_pod_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local pod names. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_pod_ids` query parameter.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_ids` query parameter.")] = None,
        remote_pod_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote pod IDs. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_pod_names` query parameter.")] = None,
        remote_pod_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote pod names. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_pod_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List pod replica links  # noqa: E501
        
        Displays the list of pod replica links that are configured between arrays.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_pod_replica_links_get_with_http_info(authorization, x_request_id, filter, ids, limit, local_pod_ids, local_pod_names, offset, remote_ids, remote_names, remote_pod_ids, remote_pod_names, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param remote_pods: A list of remote_pods to query for. Overrides remote_pod_ids and remote_pod_names keyword arguments.
        :type remote_pods: ReferenceType or List[ReferenceType], optional
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param local_pods: A list of local_pods to query for. Overrides local_pod_ids and local_pod_names keyword arguments.
        :type local_pods: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param local_pod_ids: A comma-separated list of local pod IDs. If, after filtering, there is not at
                            least one resource that matches each of the elements, then an error is
                            returned. This cannot be provided together with the `local_pod_names` query
                            parameter.
        :type local_pod_ids: List[str]
        :param local_pod_names: A comma-separated list of local pod names. If, after filtering, there is not at
                                least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `local_pod_ids` query
                                parameter.
        :type local_pod_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param remote_ids: A comma-separated list of remote array IDs. If, after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If, after filtering, there is not
                            at least one resource that matches each of the elements, then an error is
                            returned. This cannot be provided together with the `remote_ids` query
                            parameter.
        :type remote_names: List[str]
        :param remote_pod_ids: A comma-separated list of remote pod IDs. If, after filtering, there is not at
                            least one resource that matches each of the elements, then an error is
                            returned. This cannot be provided together with the `remote_pod_names`
                            query parameter.
        :type remote_pod_ids: List[str]
        :param remote_pod_names: A comma-separated list of remote pod names. If, after filtering, there is not at
                                least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `remote_pod_ids` query
                                parameter.
        :type remote_pod_names: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            ids=ids,
            limit=limit,
            local_pod_ids=local_pod_ids,
            local_pod_names=local_pod_names,
            offset=offset,
            remote_ids=remote_ids,
            remote_names=remote_names,
            remote_pod_ids=remote_pod_ids,
            remote_pod_names=remote_pod_names,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids'], kwargs)
        _process_references(local_pods, ['local_pod_ids', 'local_pod_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _process_references(remote_pods, ['remote_pod_ids', 'remote_pod_names'], kwargs)
        _fixup_list_type_params(['ids', 'local_pod_ids', 'local_pod_names', 'remote_ids', 'remote_names', 'remote_pod_ids', 'remote_pod_names', 'sort'], kwargs)
        return self._call_api('PodReplicaLinksApi', 'api232_pod_replica_links_get_with_http_info', kwargs)

    def get_pod_replica_links_lag(
        self,
        remote_pods: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_pods: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        local_pod_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local pod IDs. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_pod_names` query parameter.")] = None,
        local_pod_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local pod names. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_pod_ids` query parameter.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_ids` query parameter.")] = None,
        remote_pod_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote pod IDs. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_pod_names` query parameter.")] = None,
        remote_pod_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote pod names. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_pod_ids` query parameter.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The number of milliseconds between samples of historical data. For array-wide performance metrics (`/arrays/performance` endpoint), valid values are `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For performance metrics on storage objects (`<object name>/performance` endpoint), such as volumes, valid values are `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For space metrics, (`<object name>/space` endpoint), valid values are `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). Include the `start_time` parameter to display the performance data starting at the specified start time. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. Include the `end_time` parameter to display the performance data until the specified end time. If `end_time`is not specified, the end time will default to the current time. If the `resolution` parameter is not specified but either the `start_time` or `end_time` parameter is, then `resolution` will default to the lowest valid resolution.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List pod replica link lag  # noqa: E501
        
        Displays the lag in milliseconds that the replication target is behind the source. This is the time difference between the current time and the recovery point.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_pod_replica_links_lag_get_with_http_info(authorization, x_request_id, end_time, filter, ids, limit, local_pod_ids, local_pod_names, offset, remote_ids, remote_names, remote_pod_ids, remote_pod_names, resolution, sort, start_time, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param remote_pods: A list of remote_pods to query for. Overrides remote_pod_ids and remote_pod_names keyword arguments.
        :type remote_pods: ReferenceType or List[ReferenceType], optional
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param local_pods: A list of local_pods to query for. Overrides local_pod_ids and local_pod_names keyword arguments.
        :type local_pods: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param end_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type end_time: int
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param local_pod_ids: A comma-separated list of local pod IDs. If, after filtering, there is not at
                            least one resource that matches each of the elements, then an error is
                            returned. This cannot be provided together with the `local_pod_names` query
                            parameter.
        :type local_pod_ids: List[str]
        :param local_pod_names: A comma-separated list of local pod names. If, after filtering, there is not at
                                least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `local_pod_ids` query
                                parameter.
        :type local_pod_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param remote_ids: A comma-separated list of remote array IDs. If, after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If, after filtering, there is not
                            at least one resource that matches each of the elements, then an error is
                            returned. This cannot be provided together with the `remote_ids` query
                            parameter.
        :type remote_names: List[str]
        :param remote_pod_ids: A comma-separated list of remote pod IDs. If, after filtering, there is not at
                            least one resource that matches each of the elements, then an error is
                            returned. This cannot be provided together with the `remote_pod_names`
                            query parameter.
        :type remote_pod_ids: List[str]
        :param remote_pod_names: A comma-separated list of remote pod names. If, after filtering, there is not at
                                least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `remote_pod_ids` query
                                parameter.
        :type remote_pod_names: List[str]
        :param resolution: The number of milliseconds between samples of historical data. For array-wide
                        performance metrics (`/arrays/performance` endpoint), valid values are
                        `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30
                        minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24
                        hours). For performance metrics on storage objects (`<object
                        name>/performance` endpoint), such as volumes, valid values are `30000` (30
                        seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours),
                        `28800000` (8 hours), and `86400000` (24 hours). For space metrics,
                        (`<object name>/space` endpoint), valid values are `300000` (5 minutes),
                        `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and
                        `86400000` (24 hours). Include the `start_time` parameter to display the
                        performance data starting at the specified start time. If `start_time` is
                        not specified, the start time will default to one resolution before the end
                        time, meaning that the most recent sample of performance data will be
                        displayed. Include the `end_time` parameter to display the performance data
                        until the specified end time. If `end_time`is not specified, the end time
                        will default to the current time. If the `resolution` parameter is not
                        specified but either the `start_time` or `end_time` parameter is, then
                        `resolution` will default to the lowest valid resolution.
        :type resolution: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param start_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type start_time: int
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            end_time=end_time,
            filter=filter,
            ids=ids,
            limit=limit,
            local_pod_ids=local_pod_ids,
            local_pod_names=local_pod_names,
            offset=offset,
            remote_ids=remote_ids,
            remote_names=remote_names,
            remote_pod_ids=remote_pod_ids,
            remote_pod_names=remote_pod_names,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids'], kwargs)
        _process_references(local_pods, ['local_pod_ids', 'local_pod_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _process_references(remote_pods, ['remote_pod_ids', 'remote_pod_names'], kwargs)
        _fixup_list_type_params(['ids', 'local_pod_ids', 'local_pod_names', 'remote_ids', 'remote_names', 'remote_pod_ids', 'remote_pod_names', 'sort'], kwargs)
        return self._call_api('PodReplicaLinksApi', 'api232_pod_replica_links_lag_get_with_http_info', kwargs)

    def get_pod_replica_links_mappings_policies(
        self,
        remote_pods: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        pod_replica_links: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_pods: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        local_pod_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local pod IDs. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_pod_names` query parameter.")] = None,
        local_pod_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local pod names. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_pod_ids` query parameter.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        pod_replica_link_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of pod replica link IDs. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_ids` query parameter.")] = None,
        remote_pod_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote pod IDs. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_pod_names` query parameter.")] = None,
        remote_pod_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote pod names. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_pod_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List policy mappings  # noqa: E501
        
        Displays a list of policy mappings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_pod_replica_links_mappings_policies_get_with_http_info(authorization, x_request_id, continuation_token, filter, ids, limit, local_pod_ids, local_pod_names, offset, pod_replica_link_ids, remote_ids, remote_names, remote_pod_ids, remote_pod_names, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param remote_pods: A list of remote_pods to query for. Overrides remote_pod_ids and remote_pod_names keyword arguments.
        :type remote_pods: ReferenceType or List[ReferenceType], optional
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param pod_replica_links: A list of pod_replica_links to query for. Overrides pod_replica_link_ids keyword argument.
        :type pod_replica_links: ReferenceType or List[ReferenceType], optional
        :param local_pods: A list of local_pods to query for. Overrides local_pod_ids and local_pod_names keyword arguments.
        :type local_pods: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param local_pod_ids: A comma-separated list of local pod IDs. If, after filtering, there is not at
                            least one resource that matches each of the elements, then an error is
                            returned. This cannot be provided together with the `local_pod_names` query
                            parameter.
        :type local_pod_ids: List[str]
        :param local_pod_names: A comma-separated list of local pod names. If, after filtering, there is not at
                                least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `local_pod_ids` query
                                parameter.
        :type local_pod_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param pod_replica_link_ids: A comma-separated list of pod replica link IDs. If, after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned.
        :type pod_replica_link_ids: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If, after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If, after filtering, there is not
                            at least one resource that matches each of the elements, then an error is
                            returned. This cannot be provided together with the `remote_ids` query
                            parameter.
        :type remote_names: List[str]
        :param remote_pod_ids: A comma-separated list of remote pod IDs. If, after filtering, there is not at
                            least one resource that matches each of the elements, then an error is
                            returned. This cannot be provided together with the `remote_pod_names`
                            query parameter.
        :type remote_pod_ids: List[str]
        :param remote_pod_names: A comma-separated list of remote pod names. If, after filtering, there is not at
                                least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `remote_pod_ids` query
                                parameter.
        :type remote_pod_names: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            local_pod_ids=local_pod_ids,
            local_pod_names=local_pod_names,
            offset=offset,
            pod_replica_link_ids=pod_replica_link_ids,
            remote_ids=remote_ids,
            remote_names=remote_names,
            remote_pod_ids=remote_pod_ids,
            remote_pod_names=remote_pod_names,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids'], kwargs)
        _process_references(local_pods, ['local_pod_ids', 'local_pod_names'], kwargs)
        _process_references(pod_replica_links, ['pod_replica_link_ids'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _process_references(remote_pods, ['remote_pod_ids', 'remote_pod_names'], kwargs)
        _fixup_list_type_params(['ids', 'local_pod_ids', 'local_pod_names', 'pod_replica_link_ids', 'remote_ids', 'remote_names', 'remote_pod_ids', 'remote_pod_names', 'sort'], kwargs)
        return self._call_api('PodReplicaLinksApi', 'api232_pod_replica_links_mappings_policies_get_with_http_info', kwargs)

    def patch_pod_replica_links_mappings_policies(
        self,
        mapping: 'models.MappingPolicyPatch',
        remote_policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_pods: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        pod_replica_links: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_pods: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        local_pod_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local pod IDs. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_pod_names` query parameter.")] = None,
        local_pod_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local pod names. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_pod_ids` query parameter.")] = None,
        pod_replica_link_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of pod replica link IDs. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_ids` query parameter.")] = None,
        remote_pod_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote pod IDs. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_pod_names` query parameter.")] = None,
        remote_pod_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote pod names. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_pod_ids` query parameter.")] = None,
        remote_policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote policy IDs. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_policy_names` query parameter.")] = None,
        remote_policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote policy names. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_policy_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify policy mappings  # noqa: E501
        
        Modifies policy mappings of a replica link. Valid `mapping` values are `connected` and `disconnected`. `connected` indicates that the source policy and its attachments will be mirrored on the target pod. `disconnected` indicates that the associated policy and its attachments are independent from any policy on the remote. This operation can only be performed on the target side of a pod replica link.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_pod_replica_links_mappings_policies_patch_with_http_info(mapping, authorization, x_request_id, ids, local_pod_ids, local_pod_names, pod_replica_link_ids, remote_ids, remote_names, remote_pod_ids, remote_pod_names, remote_policy_ids, remote_policy_names, async_req=True)
        >>> result = thread.get()
        
        :param mapping: (required)
        :type mapping: models.MappingPolicyPatch
        :param remote_policies: A list of remote_policies to query for. Overrides remote_policy_ids and remote_policy_names keyword arguments.
        :type remote_policies: ReferenceType or List[ReferenceType], optional
        :param remote_pods: A list of remote_pods to query for. Overrides remote_pod_ids and remote_pod_names keyword arguments.
        :type remote_pods: ReferenceType or List[ReferenceType], optional
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param pod_replica_links: A list of pod_replica_links to query for. Overrides pod_replica_link_ids keyword argument.
        :type pod_replica_links: ReferenceType or List[ReferenceType], optional
        :param local_pods: A list of local_pods to query for. Overrides local_pod_ids and local_pod_names keyword arguments.
        :type local_pods: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param local_pod_ids: A comma-separated list of local pod IDs. If, after filtering, there is not at
                            least one resource that matches each of the elements, then an error is
                            returned. This cannot be provided together with the `local_pod_names` query
                            parameter.
        :type local_pod_ids: List[str]
        :param local_pod_names: A comma-separated list of local pod names. If, after filtering, there is not at
                                least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `local_pod_ids` query
                                parameter.
        :type local_pod_names: List[str]
        :param pod_replica_link_ids: A comma-separated list of pod replica link IDs. If, after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned.
        :type pod_replica_link_ids: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If, after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If, after filtering, there is not
                            at least one resource that matches each of the elements, then an error is
                            returned. This cannot be provided together with the `remote_ids` query
                            parameter.
        :type remote_names: List[str]
        :param remote_pod_ids: A comma-separated list of remote pod IDs. If, after filtering, there is not at
                            least one resource that matches each of the elements, then an error is
                            returned. This cannot be provided together with the `remote_pod_names`
                            query parameter.
        :type remote_pod_ids: List[str]
        :param remote_pod_names: A comma-separated list of remote pod names. If, after filtering, there is not at
                                least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `remote_pod_ids` query
                                parameter.
        :type remote_pod_names: List[str]
        :param remote_policy_ids: A comma-separated list of remote policy IDs. If, after filtering, there is not
                                at least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `remote_policy_names`
                                query parameter.
        :type remote_policy_ids: List[str]
        :param remote_policy_names: A comma-separated list of remote policy names. If, after filtering, there is not
                                    at least one resource that matches each of the elements, then an error is
                                    returned. This cannot be provided together with the `remote_policy_ids`
                                    query parameter.
        :type remote_policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            mapping=mapping,
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            local_pod_ids=local_pod_ids,
            local_pod_names=local_pod_names,
            pod_replica_link_ids=pod_replica_link_ids,
            remote_ids=remote_ids,
            remote_names=remote_names,
            remote_pod_ids=remote_pod_ids,
            remote_pod_names=remote_pod_names,
            remote_policy_ids=remote_policy_ids,
            remote_policy_names=remote_policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids'], kwargs)
        _process_references(local_pods, ['local_pod_ids', 'local_pod_names'], kwargs)
        _process_references(pod_replica_links, ['pod_replica_link_ids'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _process_references(remote_pods, ['remote_pod_ids', 'remote_pod_names'], kwargs)
        _process_references(remote_policies, ['remote_policy_ids', 'remote_policy_names'], kwargs)
        _fixup_list_type_params(['ids', 'local_pod_ids', 'local_pod_names', 'pod_replica_link_ids', 'remote_ids', 'remote_names', 'remote_pod_ids', 'remote_pod_names', 'remote_policy_ids', 'remote_policy_names'], kwargs)
        return self._call_api('PodReplicaLinksApi', 'api232_pod_replica_links_mappings_policies_patch_with_http_info', kwargs)

    def patch_pod_replica_links(
        self,
        pod_replica_link: 'models.PodReplicaLinkPatch',
        remote_pods: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_pods: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        local_pod_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local pod IDs. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_pod_names` query parameter.")] = None,
        local_pod_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local pod names. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_pod_ids` query parameter.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_ids` query parameter.")] = None,
        remote_pod_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote pod IDs. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_pod_names` query parameter.")] = None,
        remote_pod_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote pod names. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_pod_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify pod replica links  # noqa: E501
        
        Modifies pod replica links. The `local_pod_names` and `remote_pod_names` are required. Valid values are `replicating`, `baselining`, `paused`, `unhealthy`, `quiescing`, and `quiesced`. A status of `replicating` indicates that the source array is replicating to the target array. A status of `baselining` indicates that the the initial version of the dataset is being sent. During this phase, you cannot promote the target pod. In addition, changing the link direction might trigger the `baselining` status to recur. A status of `paused ` indicates that data transfer between objects has stopped. A status of `unhealthy` indicates that the link is currently unhealthy and customers must perform some health checks to determine the cause. A status of `quiescing` indicates that the source pod is not accepting new write requests but the most recent changes to the source have not arrived on the target. A status of `quiesced` indicates that the source pod has been demoted and all changes have been replicated to the target pod.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_pod_replica_links_patch_with_http_info(pod_replica_link, authorization, x_request_id, ids, local_pod_ids, local_pod_names, remote_ids, remote_names, remote_pod_ids, remote_pod_names, async_req=True)
        >>> result = thread.get()
        
        :param pod_replica_link: (required)
        :type pod_replica_link: models.PodReplicaLinkPatch
        :param remote_pods: A list of remote_pods to query for. Overrides remote_pod_ids and remote_pod_names keyword arguments.
        :type remote_pods: ReferenceType or List[ReferenceType], optional
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param local_pods: A list of local_pods to query for. Overrides local_pod_ids and local_pod_names keyword arguments.
        :type local_pods: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param local_pod_ids: A comma-separated list of local pod IDs. If, after filtering, there is not at
                            least one resource that matches each of the elements, then an error is
                            returned. This cannot be provided together with the `local_pod_names` query
                            parameter.
        :type local_pod_ids: List[str]
        :param local_pod_names: A comma-separated list of local pod names. If, after filtering, there is not at
                                least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `local_pod_ids` query
                                parameter.
        :type local_pod_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If, after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If, after filtering, there is not
                            at least one resource that matches each of the elements, then an error is
                            returned. This cannot be provided together with the `remote_ids` query
                            parameter.
        :type remote_names: List[str]
        :param remote_pod_ids: A comma-separated list of remote pod IDs. If, after filtering, there is not at
                            least one resource that matches each of the elements, then an error is
                            returned. This cannot be provided together with the `remote_pod_names`
                            query parameter.
        :type remote_pod_ids: List[str]
        :param remote_pod_names: A comma-separated list of remote pod names. If, after filtering, there is not at
                                least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `remote_pod_ids` query
                                parameter.
        :type remote_pod_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            pod_replica_link=pod_replica_link,
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            local_pod_ids=local_pod_ids,
            local_pod_names=local_pod_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            remote_pod_ids=remote_pod_ids,
            remote_pod_names=remote_pod_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids'], kwargs)
        _process_references(local_pods, ['local_pod_ids', 'local_pod_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _process_references(remote_pods, ['remote_pod_ids', 'remote_pod_names'], kwargs)
        _fixup_list_type_params(['ids', 'local_pod_ids', 'local_pod_names', 'remote_ids', 'remote_names', 'remote_pod_ids', 'remote_pod_names'], kwargs)
        return self._call_api('PodReplicaLinksApi', 'api232_pod_replica_links_patch_with_http_info', kwargs)

    def get_pod_replica_links_performance_replication(
        self,
        remote_pods: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_pods: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        local_pod_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local pod IDs. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_pod_names` query parameter.")] = None,
        local_pod_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local pod names. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_pod_ids` query parameter.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_ids` query parameter.")] = None,
        remote_pod_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote pod IDs. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_pod_names` query parameter.")] = None,
        remote_pod_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote pod names. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_pod_ids` query parameter.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The number of milliseconds between samples of historical data. For array-wide performance metrics (`/arrays/performance` endpoint), valid values are `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For performance metrics on storage objects (`<object name>/performance` endpoint), such as volumes, valid values are `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For space metrics, (`<object name>/space` endpoint), valid values are `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). Include the `start_time` parameter to display the performance data starting at the specified start time. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. Include the `end_time` parameter to display the performance data until the specified end time. If `end_time`is not specified, the end time will default to the current time. If the `resolution` parameter is not specified but either the `start_time` or `end_time` parameter is, then `resolution` will default to the lowest valid resolution.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, only return the aggregate value of all items after filtering. For real-time performance, the values are aggregated for the latest timestamp. For historical performance, the values are aggregated for each timestamp from `start_time` to `end_time`. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """api232_pod_replica_links_performance_replication_get  # noqa: E501
        
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_pod_replica_links_performance_replication_get_with_http_info(authorization, x_request_id, end_time, filter, ids, limit, local_pod_ids, local_pod_names, offset, remote_ids, remote_names, remote_pod_ids, remote_pod_names, resolution, sort, start_time, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param remote_pods: A list of remote_pods to query for. Overrides remote_pod_ids and remote_pod_names keyword arguments.
        :type remote_pods: ReferenceType or List[ReferenceType], optional
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param local_pods: A list of local_pods to query for. Overrides local_pod_ids and local_pod_names keyword arguments.
        :type local_pods: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param end_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type end_time: int
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param local_pod_ids: A comma-separated list of local pod IDs. If, after filtering, there is not at
                            least one resource that matches each of the elements, then an error is
                            returned. This cannot be provided together with the `local_pod_names` query
                            parameter.
        :type local_pod_ids: List[str]
        :param local_pod_names: A comma-separated list of local pod names. If, after filtering, there is not at
                                least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `local_pod_ids` query
                                parameter.
        :type local_pod_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param remote_ids: A comma-separated list of remote array IDs. If, after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If, after filtering, there is not
                            at least one resource that matches each of the elements, then an error is
                            returned. This cannot be provided together with the `remote_ids` query
                            parameter.
        :type remote_names: List[str]
        :param remote_pod_ids: A comma-separated list of remote pod IDs. If, after filtering, there is not at
                            least one resource that matches each of the elements, then an error is
                            returned. This cannot be provided together with the `remote_pod_names`
                            query parameter.
        :type remote_pod_ids: List[str]
        :param remote_pod_names: A comma-separated list of remote pod names. If, after filtering, there is not at
                                least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `remote_pod_ids` query
                                parameter.
        :type remote_pod_names: List[str]
        :param resolution: The number of milliseconds between samples of historical data. For array-wide
                        performance metrics (`/arrays/performance` endpoint), valid values are
                        `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30
                        minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24
                        hours). For performance metrics on storage objects (`<object
                        name>/performance` endpoint), such as volumes, valid values are `30000` (30
                        seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours),
                        `28800000` (8 hours), and `86400000` (24 hours). For space metrics,
                        (`<object name>/space` endpoint), valid values are `300000` (5 minutes),
                        `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and
                        `86400000` (24 hours). Include the `start_time` parameter to display the
                        performance data starting at the specified start time. If `start_time` is
                        not specified, the start time will default to one resolution before the end
                        time, meaning that the most recent sample of performance data will be
                        displayed. Include the `end_time` parameter to display the performance data
                        until the specified end time. If `end_time`is not specified, the end time
                        will default to the current time. If the `resolution` parameter is not
                        specified but either the `start_time` or `end_time` parameter is, then
                        `resolution` will default to the lowest valid resolution.
        :type resolution: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param start_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type start_time: int
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, only return the aggregate value of all items after filtering.
                        For real-time performance, the values are aggregated for the latest
                        timestamp. For historical performance, the values are aggregated for each
                        timestamp from `start_time` to `end_time`. Where it makes more sense, the
                        average value is displayed instead. The values are displayed for each name
                        where meaningful. If `total_only=true`, the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            end_time=end_time,
            filter=filter,
            ids=ids,
            limit=limit,
            local_pod_ids=local_pod_ids,
            local_pod_names=local_pod_names,
            offset=offset,
            remote_ids=remote_ids,
            remote_names=remote_names,
            remote_pod_ids=remote_pod_ids,
            remote_pod_names=remote_pod_names,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids'], kwargs)
        _process_references(local_pods, ['local_pod_ids', 'local_pod_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _process_references(remote_pods, ['remote_pod_ids', 'remote_pod_names'], kwargs)
        _fixup_list_type_params(['ids', 'local_pod_ids', 'local_pod_names', 'remote_ids', 'remote_names', 'remote_pod_ids', 'remote_pod_names', 'sort'], kwargs)
        return self._call_api('PodReplicaLinksApi', 'api232_pod_replica_links_performance_replication_get_with_http_info', kwargs)

    def post_pod_replica_links(
        self,
        remote_pods: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_pods: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        local_pod_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local pod IDs. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_pod_names` query parameter.")] = None,
        local_pod_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local pod names. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_pod_ids` query parameter.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_ids` query parameter.")] = None,
        remote_pod_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote pod IDs. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_pod_names` query parameter.")] = None,
        remote_pod_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote pod names. If, after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_pod_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create pod replica links  # noqa: E501
        
        Creates pod replica links between two arrays. The `local_pod_names` and `remote_pod_names` are required. Valid values are `replicating`, `baselining`, `paused`, `unhealthy`, `quiescing`, and `quiesced`. A status of `replicating` indicates that the source array is replicating to the target array. A status of `baselining` indicates that the the initial version of the dataset is being sent. During this phase, you cannot promote the target pod. In addition, changing the link direction might trigger the `baselining` status to recur. A status of `paused ` indicates that data transfer between objects has stopped. A status of `unhealthy` indicates that the link is currently unhealthy and customers must perform some health checks to determine the cause. A status of `quiescing` indicates that the source pod is not accepting new write requests but the most recent changes to the source have not arrived on the target. A status of `quiesced` indicates that the source pod has been demoted and all changes have been replicated to the target pod.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_pod_replica_links_post_with_http_info(authorization, x_request_id, local_pod_ids, local_pod_names, remote_ids, remote_names, remote_pod_ids, remote_pod_names, async_req=True)
        >>> result = thread.get()
        
        :param remote_pods: A list of remote_pods to query for. Overrides remote_pod_ids and remote_pod_names keyword arguments.
        :type remote_pods: ReferenceType or List[ReferenceType], optional
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param local_pods: A list of local_pods to query for. Overrides local_pod_ids and local_pod_names keyword arguments.
        :type local_pods: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param local_pod_ids: A comma-separated list of local pod IDs. If, after filtering, there is not at
                            least one resource that matches each of the elements, then an error is
                            returned. This cannot be provided together with the `local_pod_names` query
                            parameter.
        :type local_pod_ids: List[str]
        :param local_pod_names: A comma-separated list of local pod names. If, after filtering, there is not at
                                least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `local_pod_ids` query
                                parameter.
        :type local_pod_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If, after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If, after filtering, there is not
                            at least one resource that matches each of the elements, then an error is
                            returned. This cannot be provided together with the `remote_ids` query
                            parameter.
        :type remote_names: List[str]
        :param remote_pod_ids: A comma-separated list of remote pod IDs. If, after filtering, there is not at
                            least one resource that matches each of the elements, then an error is
                            returned. This cannot be provided together with the `remote_pod_names`
                            query parameter.
        :type remote_pod_ids: List[str]
        :param remote_pod_names: A comma-separated list of remote pod names. If, after filtering, there is not at
                                least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `remote_pod_ids` query
                                parameter.
        :type remote_pod_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            local_pod_ids=local_pod_ids,
            local_pod_names=local_pod_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            remote_pod_ids=remote_pod_ids,
            remote_pod_names=remote_pod_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(local_pods, ['local_pod_ids', 'local_pod_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _process_references(remote_pods, ['remote_pod_ids', 'remote_pod_names'], kwargs)
        _fixup_list_type_params(['local_pod_ids', 'local_pod_names', 'remote_ids', 'remote_names', 'remote_pod_ids', 'remote_pod_names'], kwargs)
        return self._call_api('PodReplicaLinksApi', 'api232_pod_replica_links_post_with_http_info', kwargs)

    def delete_pods_arrays(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        with_unknown: Annotated[Optional[StrictBool], Field(description="If set to `true`, unstretches the specified pod from the specified array by force. Use the `with_unknown` parameter in the following rare event&#58; the local array goes offline while the pod is still stretched across two arrays, the status of the remote array becomes unknown, and there is no guarantee that the pod is online elsewhere.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Unstretch a pod from an array  # noqa: E501
        
        Unstretches a pod from an array, collapsing the pod to a single array. Unstretch a pod from an array when the volumes within the stretched pod no longer need to be synchronously replicated between the two arrays. After a pod has been unstretched, synchronous replication stops. A destroyed version of the pod with "restretch" appended to the pod name is created on the array that no longer has the pod. The restretch pod represents a point-in-time snapshot of the pod, just before it was unstretched. The restretch pod enters an eradication pending period starting from the time that the pod was unstretched. A restretch can pod can be cloned or destroyed, but it cannot be explicitly recovered. The `group_names` parameter represents the name of the pod to be unstretched. The `member_names` parameter represents the name of the array from which the pod is to be unstretched. The `group_names` and `member_names` parameters are required and must be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_pods_arrays_delete_with_http_info(authorization, x_request_id, group_ids, group_names, member_ids, member_names, with_unknown, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_ids and group_names keyword arguments.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param group_ids: A comma-separated list of group IDs.
        :type group_ids: List[str]
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param with_unknown: If set to `true`, unstretches the specified pod from the specified array by
                            force. Use the `with_unknown` parameter in the following rare event&#58;
                            the local array goes offline while the pod is still stretched across two
                            arrays, the status of the remote array becomes unknown, and there is no
                            guarantee that the pod is online elsewhere.
        :type with_unknown: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            group_ids=group_ids,
            group_names=group_names,
            member_ids=member_ids,
            member_names=member_names,
            with_unknown=with_unknown,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_ids', 'group_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _fixup_list_type_params(['group_ids', 'group_names', 'member_ids', 'member_names'], kwargs)
        return self._call_api('PodsApi', 'api232_pods_arrays_delete_with_http_info', kwargs)

    def get_pods_arrays(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List pods and their the array members  # noqa: E501
        
        Returns a list of pods and the local and remote arrays over which the pods are stretched. The optional `group_names` parameter represents the name of the pod. The optional `member_names` parameter represents the name of the array over which the pod is stretched.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_pods_arrays_get_with_http_info(authorization, x_request_id, filter, group_ids, group_names, limit, member_ids, member_names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_ids and group_names keyword arguments.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param group_ids: A comma-separated list of group IDs.
        :type group_ids: List[str]
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            group_ids=group_ids,
            group_names=group_names,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_ids', 'group_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _fixup_list_type_params(['group_ids', 'group_names', 'member_ids', 'member_names', 'sort'], kwargs)
        return self._call_api('PodsApi', 'api232_pods_arrays_get_with_http_info', kwargs)

    def post_pods_arrays(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Stretch a pod to an array  # noqa: E501
        
        Stretches a pod to an array. When a pod is stretched to an array, the data in the arrays over which the pod is stretched is synchronously replicated. The `group_names` parameter represents the name of the pod to be stretched. The `member_names` parameter represents the name of the array over which the pod is to be stretched. The `group_names` and `member_names` parameters are required and must be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_pods_arrays_post_with_http_info(authorization, x_request_id, group_ids, group_names, member_ids, member_names, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_ids and group_names keyword arguments.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param group_ids: A comma-separated list of group IDs.
        :type group_ids: List[str]
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            group_ids=group_ids,
            group_names=group_names,
            member_ids=member_ids,
            member_names=member_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_ids', 'group_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _fixup_list_type_params(['group_ids', 'group_names', 'member_ids', 'member_names'], kwargs)
        return self._call_api('PodsApi', 'api232_pods_arrays_post_with_http_info', kwargs)

    def delete_pods(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        eradicate_contents: Annotated[Optional[StrictBool], Field(description="Set to `true` to eradicate contents (e.g., volumes, protection groups, snapshots) and containers (e.g., pods, volume groups). This enables you to eradicate containers with contents.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a pod  # noqa: E501
        
        Deletes a pod that has been destroyed and is pending eradication. Eradicated pods cannot be recovered. Pods are destroyed using the PATCH method. The `ids` or `names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_pods_delete_with_http_info(authorization, x_request_id, eradicate_contents, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param eradicate_contents: Set to `true` to eradicate contents (e.g., volumes, protection groups,
                                snapshots) and containers (e.g., pods, volume groups). This enables you to
                                eradicate containers with contents.
        :type eradicate_contents: bool
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            eradicate_contents=eradicate_contents,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('PodsApi', 'api232_pods_delete_with_http_info', kwargs)

    def get_pods(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List pods  # noqa: E501
        
        Displays a list of pods that are stretched to this array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_pods_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, ids, limit, names, offset, sort, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('PodsApi', 'api232_pods_get_with_http_info', kwargs)

    def patch_pods(
        self,
        pod: 'models.PodPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        abort_quiesce: Annotated[Optional[StrictBool], Field(description="Set to `true` to promote the pod when the `pod-replica-link` is in the `quiescing` state and abort when waiting for the `pod-replica-link` to complete the quiescing operation.")] = None,
        destroy_contents: Annotated[Optional[StrictBool], Field(description="Set to `true` to destroy contents (e.g., volumes, protection groups, snapshots) and containers (e.g., pods, volume groups). This enables you to destroy containers with contents.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        promote_from: Annotated[Optional[StrictStr], Field(description="The `undo-demote` pod that should be used to promote the pod. After the pod has been promoted, it will have the same data as the `undo-demote` pod and the `undo-demote` pod will be eradicated.")] = None,
        quiesce: Annotated[Optional[StrictBool], Field(description="Set to `true` to demote the pod after the `pod-replica-link` goes into `quiesced` state and allow the pod to become a target of the remote pod. This ensures that all local data has been replicated to the remote pod before the pod is demoted.")] = None,
        skip_quiesce: Annotated[Optional[StrictBool], Field(description="Set to `true` to demote the pod without quiescing the `pod-replica-link` and allow the pod to become a target of the remote pod. This stops all pending replication to the remote pod.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify a pod  # noqa: E501
        
        Modifies pod details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_pods_patch_with_http_info(pod, authorization, x_request_id, abort_quiesce, destroy_contents, ids, names, promote_from, quiesce, skip_quiesce, async_req=True)
        >>> result = thread.get()
        
        :param pod: (required)
        :type pod: models.PodPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param abort_quiesce: Set to `true` to promote the pod when the `pod-replica-link` is in the
                            `quiescing` state and abort when waiting for the `pod-replica-link` to
                            complete the quiescing operation.
        :type abort_quiesce: bool
        :param destroy_contents: Set to `true` to destroy contents (e.g., volumes, protection groups, snapshots)
                                and containers (e.g., pods, volume groups). This enables you to destroy
                                containers with contents.
        :type destroy_contents: bool
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param promote_from: The `undo-demote` pod that should be used to promote the pod. After the pod has
                            been promoted, it will have the same data as the `undo-demote` pod and the
                            `undo-demote` pod will be eradicated.
        :type promote_from: str
        :param quiesce: Set to `true` to demote the pod after the `pod-replica-link` goes into
                        `quiesced` state and allow the pod to become a target of the remote pod.
                        This ensures that all local data has been replicated to the remote pod
                        before the pod is demoted.
        :type quiesce: bool
        :param skip_quiesce: Set to `true` to demote the pod without quiescing the `pod-replica-link` and
                            allow the pod to become a target of the remote pod. This stops all pending
                            replication to the remote pod.
        :type skip_quiesce: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            pod=pod,
            authorization=authorization,
            x_request_id=x_request_id,
            abort_quiesce=abort_quiesce,
            destroy_contents=destroy_contents,
            ids=ids,
            names=names,
            promote_from=promote_from,
            quiesce=quiesce,
            skip_quiesce=skip_quiesce,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('PodsApi', 'api232_pods_patch_with_http_info', kwargs)

    def get_pods_performance_by_array(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        protocol: Annotated[Optional[StrictStr], Field(description="Protocol type. Valid values are `nfs`, `smb`, and `all`.")] = None,
        protocol_group: Annotated[Optional[StrictStr], Field(description="Protocol group type. Valid values are `block`, `file`, and `all`.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The number of milliseconds between samples of historical data. For array-wide performance metrics (`/arrays/performance` endpoint), valid values are `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For performance metrics on storage objects (`<object name>/performance` endpoint), such as volumes, valid values are `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For space metrics, (`<object name>/space` endpoint), valid values are `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). Include the `start_time` parameter to display the performance data starting at the specified start time. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. Include the `end_time` parameter to display the performance data until the specified end time. If `end_time`is not specified, the end time will default to the current time. If the `resolution` parameter is not specified but either the `start_time` or `end_time` parameter is, then `resolution` will default to the lowest valid resolution.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List pod performance data by array  # noqa: E501
        
        Displays real-time and historical performance data, real-time latency data, and average I/O size data. The data is displayed as a total across all pods on the local array and by individual pod.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_pods_performance_by_array_get_with_http_info(authorization, x_request_id, destroyed, end_time, filter, ids, limit, names, offset, protocol, protocol_group, resolution, sort, start_time, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param end_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type end_time: int
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param protocol: Protocol type. Valid values are `nfs`, `smb`, and `all`.
        :type protocol: str
        :param protocol_group: Protocol group type. Valid values are `block`, `file`, and `all`.
        :type protocol_group: str
        :param resolution: The number of milliseconds between samples of historical data. For array-wide
                        performance metrics (`/arrays/performance` endpoint), valid values are
                        `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30
                        minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24
                        hours). For performance metrics on storage objects (`<object
                        name>/performance` endpoint), such as volumes, valid values are `30000` (30
                        seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours),
                        `28800000` (8 hours), and `86400000` (24 hours). For space metrics,
                        (`<object name>/space` endpoint), valid values are `300000` (5 minutes),
                        `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and
                        `86400000` (24 hours). Include the `start_time` parameter to display the
                        performance data starting at the specified start time. If `start_time` is
                        not specified, the start time will default to one resolution before the end
                        time, meaning that the most recent sample of performance data will be
                        displayed. Include the `end_time` parameter to display the performance data
                        until the specified end time. If `end_time`is not specified, the end time
                        will default to the current time. If the `resolution` parameter is not
                        specified but either the `start_time` or `end_time` parameter is, then
                        `resolution` will default to the lowest valid resolution.
        :type resolution: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param start_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type start_time: int
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            destroyed=destroyed,
            end_time=end_time,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            protocol=protocol,
            protocol_group=protocol_group,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('PodsApi', 'api232_pods_performance_by_array_get_with_http_info', kwargs)

    def get_pods_performance(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        protocol: Annotated[Optional[StrictStr], Field(description="Protocol type. Valid values are `nfs`, `smb`, and `all`.")] = None,
        protocol_group: Annotated[Optional[StrictStr], Field(description="Protocol group type. Valid values are `block`, `file`, and `all`.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The number of milliseconds between samples of historical data. For array-wide performance metrics (`/arrays/performance` endpoint), valid values are `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For performance metrics on storage objects (`<object name>/performance` endpoint), such as volumes, valid values are `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For space metrics, (`<object name>/space` endpoint), valid values are `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). Include the `start_time` parameter to display the performance data starting at the specified start time. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. Include the `end_time` parameter to display the performance data until the specified end time. If `end_time`is not specified, the end time will default to the current time. If the `resolution` parameter is not specified but either the `start_time` or `end_time` parameter is, then `resolution` will default to the lowest valid resolution.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List pod performance data  # noqa: E501
        
        Displays real-time and historical performance data, real-time latency data, and average I/O sizes across all pods, displayed both by pod and as a total across all pods.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_pods_performance_get_with_http_info(authorization, x_request_id, destroyed, end_time, filter, ids, limit, names, offset, protocol, protocol_group, resolution, sort, start_time, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param end_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type end_time: int
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param protocol: Protocol type. Valid values are `nfs`, `smb`, and `all`.
        :type protocol: str
        :param protocol_group: Protocol group type. Valid values are `block`, `file`, and `all`.
        :type protocol_group: str
        :param resolution: The number of milliseconds between samples of historical data. For array-wide
                        performance metrics (`/arrays/performance` endpoint), valid values are
                        `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30
                        minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24
                        hours). For performance metrics on storage objects (`<object
                        name>/performance` endpoint), such as volumes, valid values are `30000` (30
                        seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours),
                        `28800000` (8 hours), and `86400000` (24 hours). For space metrics,
                        (`<object name>/space` endpoint), valid values are `300000` (5 minutes),
                        `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and
                        `86400000` (24 hours). Include the `start_time` parameter to display the
                        performance data starting at the specified start time. If `start_time` is
                        not specified, the start time will default to one resolution before the end
                        time, meaning that the most recent sample of performance data will be
                        displayed. Include the `end_time` parameter to display the performance data
                        until the specified end time. If `end_time`is not specified, the end time
                        will default to the current time. If the `resolution` parameter is not
                        specified but either the `start_time` or `end_time` parameter is, then
                        `resolution` will default to the lowest valid resolution.
        :type resolution: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param start_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type start_time: int
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            destroyed=destroyed,
            end_time=end_time,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            protocol=protocol,
            protocol_group=protocol_group,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('PodsApi', 'api232_pods_performance_get_with_http_info', kwargs)

    def get_pods_performance_replication_by_array(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The number of milliseconds between samples of historical data. For array-wide performance metrics (`/arrays/performance` endpoint), valid values are `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For performance metrics on storage objects (`<object name>/performance` endpoint), such as volumes, valid values are `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For space metrics, (`<object name>/space` endpoint), valid values are `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). Include the `start_time` parameter to display the performance data starting at the specified start time. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. Include the `end_time` parameter to display the performance data until the specified end time. If `end_time`is not specified, the end time will default to the current time. If the `resolution` parameter is not specified but either the `start_time` or `end_time` parameter is, then `resolution` will default to the lowest valid resolution.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List pod replication performance data by array  # noqa: E501
        
        Displays pod replication performance data, organized by array. The data returned is the real-time and historical performance data for each replication type at the pod level. Values include `continuous`, `periodic`, `resync`, and `sync`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_pods_performance_replication_by_array_get_with_http_info(authorization, x_request_id, destroyed, end_time, filter, ids, limit, names, offset, resolution, sort, start_time, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param end_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type end_time: int
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param resolution: The number of milliseconds between samples of historical data. For array-wide
                        performance metrics (`/arrays/performance` endpoint), valid values are
                        `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30
                        minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24
                        hours). For performance metrics on storage objects (`<object
                        name>/performance` endpoint), such as volumes, valid values are `30000` (30
                        seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours),
                        `28800000` (8 hours), and `86400000` (24 hours). For space metrics,
                        (`<object name>/space` endpoint), valid values are `300000` (5 minutes),
                        `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and
                        `86400000` (24 hours). Include the `start_time` parameter to display the
                        performance data starting at the specified start time. If `start_time` is
                        not specified, the start time will default to one resolution before the end
                        time, meaning that the most recent sample of performance data will be
                        displayed. Include the `end_time` parameter to display the performance data
                        until the specified end time. If `end_time`is not specified, the end time
                        will default to the current time. If the `resolution` parameter is not
                        specified but either the `start_time` or `end_time` parameter is, then
                        `resolution` will default to the lowest valid resolution.
        :type resolution: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param start_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type start_time: int
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            destroyed=destroyed,
            end_time=end_time,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('PodsApi', 'api232_pods_performance_replication_by_array_get_with_http_info', kwargs)

    def get_pods_performance_replication(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The number of milliseconds between samples of historical data. For array-wide performance metrics (`/arrays/performance` endpoint), valid values are `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For performance metrics on storage objects (`<object name>/performance` endpoint), such as volumes, valid values are `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For space metrics, (`<object name>/space` endpoint), valid values are `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). Include the `start_time` parameter to display the performance data starting at the specified start time. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. Include the `end_time` parameter to display the performance data until the specified end time. If `end_time`is not specified, the end time will default to the current time. If the `resolution` parameter is not specified but either the `start_time` or `end_time` parameter is, then `resolution` will default to the lowest valid resolution.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, only return the aggregate value of all items after filtering. For real-time performance, the values are aggregated for the latest timestamp. For historical performance, the values are aggregated for each timestamp from `start_time` to `end_time`. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List pod replication performance data  # noqa: E501
        
        Displays pod replication performance data. The data returned is the real-time and historical performance data for each replication type at the pod level. Values include `continuous`, `periodic`, `resync`, and `sync`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_pods_performance_replication_get_with_http_info(authorization, x_request_id, destroyed, end_time, filter, ids, limit, names, offset, resolution, sort, start_time, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param end_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type end_time: int
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param resolution: The number of milliseconds between samples of historical data. For array-wide
                        performance metrics (`/arrays/performance` endpoint), valid values are
                        `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30
                        minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24
                        hours). For performance metrics on storage objects (`<object
                        name>/performance` endpoint), such as volumes, valid values are `30000` (30
                        seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours),
                        `28800000` (8 hours), and `86400000` (24 hours). For space metrics,
                        (`<object name>/space` endpoint), valid values are `300000` (5 minutes),
                        `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and
                        `86400000` (24 hours). Include the `start_time` parameter to display the
                        performance data starting at the specified start time. If `start_time` is
                        not specified, the start time will default to one resolution before the end
                        time, meaning that the most recent sample of performance data will be
                        displayed. Include the `end_time` parameter to display the performance data
                        until the specified end time. If `end_time`is not specified, the end time
                        will default to the current time. If the `resolution` parameter is not
                        specified but either the `start_time` or `end_time` parameter is, then
                        `resolution` will default to the lowest valid resolution.
        :type resolution: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param start_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type start_time: int
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, only return the aggregate value of all items after filtering.
                        For real-time performance, the values are aggregated for the latest
                        timestamp. For historical performance, the values are aggregated for each
                        timestamp from `start_time` to `end_time`. Where it makes more sense, the
                        average value is displayed instead. The values are displayed for each name
                        where meaningful. If `total_only=true`, the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            destroyed=destroyed,
            end_time=end_time,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('PodsApi', 'api232_pods_performance_replication_get_with_http_info', kwargs)

    def post_pods(
        self,
        pod: 'models.PodPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_throttle: Annotated[Optional[StrictBool], Field(description="If set to `true`, allows operation to fail if array health is not optimal.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a pod  # noqa: E501
        
        Creates a pod on the local array. Each pod must be given a unique name across the arrays to which they are stretched. A pod cannot be stretched to an array that already contains a pod with the same name. After a pod has been created, add volumes and protection groups, and then stretch the pod to another (connected) array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_pods_post_with_http_info(pod, authorization, x_request_id, allow_throttle, names, async_req=True)
        >>> result = thread.get()
        
        :param pod: (required)
        :type pod: models.PodPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_throttle: If set to `true`, allows operation to fail if array health is not optimal.
        :type allow_throttle: bool
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            pod=pod,
            authorization=authorization,
            x_request_id=x_request_id,
            allow_throttle=allow_throttle,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('PodsApi', 'api232_pods_post_with_http_info', kwargs)

    def get_pods_space(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The number of milliseconds between samples of historical data. For array-wide performance metrics (`/arrays/performance` endpoint), valid values are `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For performance metrics on storage objects (`<object name>/performance` endpoint), such as volumes, valid values are `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For space metrics, (`<object name>/space` endpoint), valid values are `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). Include the `start_time` parameter to display the performance data starting at the specified start time. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. Include the `end_time` parameter to display the performance data until the specified end time. If `end_time`is not specified, the end time will default to the current time. If the `resolution` parameter is not specified but either the `start_time` or `end_time` parameter is, then `resolution` will default to the lowest valid resolution.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List pod space information  # noqa: E501
        
        Displays provisioned size and physical storage consumption data for each pod on the local array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_pods_space_get_with_http_info(authorization, x_request_id, destroyed, end_time, filter, ids, limit, names, offset, resolution, sort, start_time, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param end_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type end_time: int
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param resolution: The number of milliseconds between samples of historical data. For array-wide
                        performance metrics (`/arrays/performance` endpoint), valid values are
                        `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30
                        minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24
                        hours). For performance metrics on storage objects (`<object
                        name>/performance` endpoint), such as volumes, valid values are `30000` (30
                        seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours),
                        `28800000` (8 hours), and `86400000` (24 hours). For space metrics,
                        (`<object name>/space` endpoint), valid values are `300000` (5 minutes),
                        `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and
                        `86400000` (24 hours). Include the `start_time` parameter to display the
                        performance data starting at the specified start time. If `start_time` is
                        not specified, the start time will default to one resolution before the end
                        time, meaning that the most recent sample of performance data will be
                        displayed. Include the `end_time` parameter to display the performance data
                        until the specified end time. If `end_time`is not specified, the end time
                        will default to the current time. If the `resolution` parameter is not
                        specified but either the `start_time` or `end_time` parameter is, then
                        `resolution` will default to the lowest valid resolution.
        :type resolution: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param start_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type start_time: int
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            destroyed=destroyed,
            end_time=end_time,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('PodsApi', 'api232_pods_space_get_with_http_info', kwargs)

    def post_pods_test(
        self,
        pod: 'models.PodPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_throttle: Annotated[Optional[StrictBool], Field(description="If set to `true`, allows operation to fail if array health is not optimal.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create an attempt to clone a pod  # noqa: E501
        
        Creates an attempt to clone a pod on the local array without actually cloning it, to test if the pod can be successfully cloned. It does not suppport pod creation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_pods_test_post_with_http_info(pod, authorization, x_request_id, allow_throttle, names, async_req=True)
        >>> result = thread.get()
        
        :param pod: (required)
        :type pod: models.PodPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_throttle: If set to `true`, allows operation to fail if array health is not optimal.
        :type allow_throttle: bool
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            pod=pod,
            authorization=authorization,
            x_request_id=x_request_id,
            allow_throttle=allow_throttle,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('PodsApi', 'api232_pods_test_post_with_http_info', kwargs)

    def delete_policies_autodir(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete auto managed directory policies  # noqa: E501
        
        Deletes one or more auto managed directory policies. The `ids` or `names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_autodir_delete_with_http_info(authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_autodir_delete_with_http_info', kwargs)

    def get_policies_autodir(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List auto managed directory policies  # noqa: E501
        
        Displays a list of auto managed directory policies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_autodir_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, ids, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_autodir_get_with_http_info', kwargs)

    def delete_policies_autodir_members(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        member_types: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the member types specified. The type of member is the full name of the resource endpoint. Valid values include `directories`. Enter multiple member types in comma-separated format. For example, `type01,type02`.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete auto managed directory policies  # noqa: E501
        
        Deletes one or more auto managed directory policies from resources. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together. The `member_ids` or `member_names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_autodir_members_delete_with_http_info(authorization, x_request_id, member_ids, member_names, member_types, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param member_types: Performs the operation on the member types specified. The type of member is the
                            full name of the resource endpoint. Valid values include `directories`.
                            Enter multiple member types in comma-separated format. For example,
                            `type01,type02`.
        :type member_types: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            member_ids=member_ids,
            member_names=member_names,
            member_types=member_types,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'member_types', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_autodir_members_delete_with_http_info', kwargs)

    def get_policies_autodir_members(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        member_types: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the member types specified. The type of member is the full name of the resource endpoint. Valid values include `directories`. Enter multiple member types in comma-separated format. For example, `type01,type02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List auto managed directories policy members  # noqa: E501
        
        Displays a list of auto managed directory policy members.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_autodir_members_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, limit, member_ids, member_names, member_types, offset, policy_ids, policy_names, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param member_types: Performs the operation on the member types specified. The type of member is the
                            full name of the resource endpoint. Valid values include `directories`.
                            Enter multiple member types in comma-separated format. For example,
                            `type01,type02`.
        :type member_types: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            member_types=member_types,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'member_types', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_autodir_members_get_with_http_info', kwargs)

    def post_policies_autodir_members(
        self,
        members: 'models.PolicyMemberPost',
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create auto managed directory policies  # noqa: E501
        
        Creates a membership between one or more resources with an auto managed directory policy. Applicable resources are directories. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_autodir_members_post_with_http_info(members, authorization, x_request_id, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param members: (required)
        :type members: models.PolicyMemberPost
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            members=members,
            authorization=authorization,
            x_request_id=x_request_id,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_autodir_members_post_with_http_info', kwargs)

    def patch_policies_autodir(
        self,
        policy: 'models.PolicyPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify auto managed directory policies  # noqa: E501
        
        Modifies one or more auto managed directory policies. To enable a policy, set `enabled=true`. To disable a policy, set `enabled=true`. To rename a policy, set `name` to the new name. The `ids` or `names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_autodir_patch_with_http_info(policy, authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param policy: (required)
        :type policy: models.PolicyPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            policy=policy,
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_autodir_patch_with_http_info', kwargs)

    def post_policies_autodir(
        self,
        sources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        source_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source ID specified. Enter multiple source IDs in comma-separated format.")] = None,
        source_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source name specified. Enter multiple source names in comma-separated format. For example, `name01,name02`.")] = None,
        policy: Optional['models.PolicyPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create auto managed directory policies  # noqa: E501
        
        Creates one or more auto managed directory policies. To copy a policy, set one of either `source_names` or `source_ids`. Each policy can only have one entry. To create a policy from scratch, policy body is required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_autodir_post_with_http_info(authorization, x_request_id, names, source_ids, source_names, policy, async_req=True)
        >>> result = thread.get()
        
        :param sources: A list of sources to query for. Overrides source_ids and source_names keyword arguments.
        :type sources: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param source_ids: Performs the operation on the source ID specified. Enter multiple source IDs in
                        comma-separated format.
        :type source_ids: List[str]
        :param source_names: Performs the operation on the source name specified. Enter multiple source names
                            in comma-separated format. For example, `name01,name02`.
        :type source_names: List[str]
        :param policy:
        :type policy: PolicyPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            source_ids=source_ids,
            source_names=source_names,
            policy=policy,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _process_references(sources, ['source_ids', 'source_names'], kwargs)
        _fixup_list_type_params(['names', 'source_ids', 'source_names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_autodir_post_with_http_info', kwargs)

    def get_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List policies  # noqa: E501
        
        Displays a list of policies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, ids, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_get_with_http_info', kwargs)

    def get_policies_members(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        member_types: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the member types specified. The type of member is the full name of the resource endpoint. Valid values include `directories`. Enter multiple member types in comma-separated format. For example, `type01,type02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List policy members  # noqa: E501
        
        Displays a list of policy members.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_members_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, limit, member_ids, member_names, member_types, offset, policy_ids, policy_names, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param member_types: Performs the operation on the member types specified. The type of member is the
                            full name of the resource endpoint. Valid values include `directories`.
                            Enter multiple member types in comma-separated format. For example,
                            `type01,type02`.
        :type member_types: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            member_types=member_types,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'member_types', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_members_get_with_http_info', kwargs)

    def delete_policies_nfs_client_rules(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete NFS client policy rules.  # noqa: E501
        
        Deletes one or more NFS client policy rules. The `policy_ids` or `policy_names` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_nfs_client_rules_delete_with_http_info(authorization, x_request_id, names, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_nfs_client_rules_delete_with_http_info', kwargs)

    def get_policies_nfs_client_rules(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List NFS client policy rules  # noqa: E501
        
        Displays a list of NFS client policy rules.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_nfs_client_rules_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, limit, names, offset, policy_ids, policy_names, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_nfs_client_rules_get_with_http_info', kwargs)

    def post_policies_nfs_client_rules(
        self,
        rules: 'models.PolicyRuleNfsClientPost',
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create NFS client policy rules  # noqa: E501
        
        Creates one or more NFS client policy rules. The `policy_ids` or `policy_names` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_nfs_client_rules_post_with_http_info(rules, authorization, x_request_id, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param rules: (required)
        :type rules: models.PolicyRuleNfsClientPost
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            rules=rules,
            authorization=authorization,
            x_request_id=x_request_id,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_nfs_client_rules_post_with_http_info', kwargs)

    def delete_policies_nfs(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete NFS policies  # noqa: E501
        
        Deletes one or more NFS policies. The `ids` or `names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_nfs_delete_with_http_info(authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_nfs_delete_with_http_info', kwargs)

    def get_policies_nfs(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List NFS policies  # noqa: E501
        
        Displays a list of NFS policies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_nfs_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, ids, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_nfs_get_with_http_info', kwargs)

    def delete_policies_nfs_members(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        member_types: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the member types specified. The type of member is the full name of the resource endpoint. Valid values include `directories`. Enter multiple member types in comma-separated format. For example, `type01,type02`.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete NFS policies  # noqa: E501
        
        Deletes one or more NFS policies from resources. The `policy_ids` or `policy_names` parameter is required, but cannot be set together. The `member_ids` or `member_names` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_nfs_members_delete_with_http_info(authorization, x_request_id, member_ids, member_names, member_types, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param member_types: Performs the operation on the member types specified. The type of member is the
                            full name of the resource endpoint. Valid values include `directories`.
                            Enter multiple member types in comma-separated format. For example,
                            `type01,type02`.
        :type member_types: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            member_ids=member_ids,
            member_names=member_names,
            member_types=member_types,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'member_types', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_nfs_members_delete_with_http_info', kwargs)

    def get_policies_nfs_members(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        member_types: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the member types specified. The type of member is the full name of the resource endpoint. Valid values include `directories`. Enter multiple member types in comma-separated format. For example, `type01,type02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List NFS policy members  # noqa: E501
        
        Displays a list of NFS policy members.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_nfs_members_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, limit, member_ids, member_names, member_types, offset, policy_ids, policy_names, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param member_types: Performs the operation on the member types specified. The type of member is the
                            full name of the resource endpoint. Valid values include `directories`.
                            Enter multiple member types in comma-separated format. For example,
                            `type01,type02`.
        :type member_types: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            member_types=member_types,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'member_types', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_nfs_members_get_with_http_info', kwargs)

    def post_policies_nfs_members(
        self,
        members: 'models.PolicyMemberExportPost',
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create NFS policies  # noqa: E501
        
        Creates a membership between one or more resources and an NFS policy. Applicable resources are directories. The `policy_ids` or `policy_names` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_nfs_members_post_with_http_info(members, authorization, x_request_id, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param members: (required)
        :type members: models.PolicyMemberExportPost
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            members=members,
            authorization=authorization,
            x_request_id=x_request_id,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_nfs_members_post_with_http_info', kwargs)

    def patch_policies_nfs(
        self,
        policy: 'models.PolicyNfsPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify NFS policies  # noqa: E501
        
        Modifies one or more NFS policies. To enable a policy, set `enabled=true`. To disable a policy, set `enabled=false`. To rename a policy, set `name` to the new name. The `ids` or `names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_nfs_patch_with_http_info(policy, authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param policy: (required)
        :type policy: models.PolicyNfsPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            policy=policy,
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_nfs_patch_with_http_info', kwargs)

    def post_policies_nfs(
        self,
        sources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        source_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source ID specified. Enter multiple source IDs in comma-separated format.")] = None,
        source_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source name specified. Enter multiple source names in comma-separated format. For example, `name01,name02`.")] = None,
        policy: Optional['models.PolicyNfsPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create NFS policies  # noqa: E501
        
        Creates one or more NFS policies or copies an existing policy. To copy a policy, the `source_names` or `source_ids` parameter is required, but they cannot be set together. To create a policy, policy body is required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_nfs_post_with_http_info(authorization, x_request_id, names, source_ids, source_names, policy, async_req=True)
        >>> result = thread.get()
        
        :param sources: A list of sources to query for. Overrides source_ids and source_names keyword arguments.
        :type sources: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param source_ids: Performs the operation on the source ID specified. Enter multiple source IDs in
                        comma-separated format.
        :type source_ids: List[str]
        :param source_names: Performs the operation on the source name specified. Enter multiple source names
                            in comma-separated format. For example, `name01,name02`.
        :type source_names: List[str]
        :param policy:
        :type policy: PolicyNfsPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            source_ids=source_ids,
            source_names=source_names,
            policy=policy,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _process_references(sources, ['source_ids', 'source_names'], kwargs)
        _fixup_list_type_params(['names', 'source_ids', 'source_names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_nfs_post_with_http_info', kwargs)

    def delete_policies_quota(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete quota policies  # noqa: E501
        
        Deletes one or more quota policies. The `ids` or `names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_quota_delete_with_http_info(authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_quota_delete_with_http_info', kwargs)

    def get_policies_quota(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List quota policies  # noqa: E501
        
        Displays a list of quota policies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_quota_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, ids, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_quota_get_with_http_info', kwargs)

    def delete_policies_quota_members(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        member_types: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the member types specified. The type of member is the full name of the resource endpoint. Valid values include `directories`. Enter multiple member types in comma-separated format. For example, `type01,type02`.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete membership between quota policies and managed directories  # noqa: E501
        
        Deletes a membership between one or more quota policies and managed directories. The `policy_ids` or `policy_names` parameter is required, but cannot be set together. The `member_ids` or `member_names` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_quota_members_delete_with_http_info(authorization, x_request_id, member_ids, member_names, member_types, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param member_types: Performs the operation on the member types specified. The type of member is the
                            full name of the resource endpoint. Valid values include `directories`.
                            Enter multiple member types in comma-separated format. For example,
                            `type01,type02`.
        :type member_types: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            member_ids=member_ids,
            member_names=member_names,
            member_types=member_types,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'member_types', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_quota_members_delete_with_http_info', kwargs)

    def get_policies_quota_members(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        member_types: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the member types specified. The type of member is the full name of the resource endpoint. Valid values include `directories`. Enter multiple member types in comma-separated format. For example, `type01,type02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List quota policy members  # noqa: E501
        
        Displays a list of quota policy members.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_quota_members_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, limit, member_ids, member_names, member_types, offset, policy_ids, policy_names, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param member_types: Performs the operation on the member types specified. The type of member is the
                            full name of the resource endpoint. Valid values include `directories`.
                            Enter multiple member types in comma-separated format. For example,
                            `type01,type02`.
        :type member_types: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            member_types=member_types,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'member_types', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_quota_members_get_with_http_info', kwargs)

    def post_policies_quota_members(
        self,
        members: 'models.PolicyMemberPost',
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ignore_usage: Annotated[Optional[StrictBool], Field(description="Flag used to override checks for quota management operations. If set to `true`, directory usage is not checked against the `quota_limits` that are set. If set to `false`, the actual logical bytes in use are prevented from exceeding the limits set on the directory. Client operations might be impacted. If the limit exceeds the quota, the client operation is not allowed. If not specified, defaults to `false`.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a membership between a managed directory and a quota policy  # noqa: E501
        
        Creates a membership between one or more managed directories and a quota policy. The `policy_ids` or `policy_names` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_quota_members_post_with_http_info(members, authorization, x_request_id, ignore_usage, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param members: (required)
        :type members: models.PolicyMemberPost
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ignore_usage: Flag used to override checks for quota management operations. If set to `true`,
                            directory usage is not checked against the `quota_limits` that are set. If
                            set to `false`, the actual logical bytes in use are prevented from
                            exceeding the limits set on the directory. Client operations might be
                            impacted. If the limit exceeds the quota, the client operation is not
                            allowed. If not specified, defaults to `false`.
        :type ignore_usage: bool
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            members=members,
            authorization=authorization,
            x_request_id=x_request_id,
            ignore_usage=ignore_usage,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_quota_members_post_with_http_info', kwargs)

    def patch_policies_quota(
        self,
        policy: 'models.PolicyPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        ignore_usage: Annotated[Optional[StrictBool], Field(description="Flag used to override checks for quota management operations. If set to `true`, directory usage is not checked against the `quota_limits` that are set. If set to `false`, the actual logical bytes in use are prevented from exceeding the limits set on the directory. Client operations might be impacted. If the limit exceeds the quota, the client operation is not allowed. If not specified, defaults to `false`.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify quota policies  # noqa: E501
        
        Modifies one or more quota policies. To enable a policy, set `enabled=true`. To disable a policy, set `enabled=false`. To rename a policy, set `name` to the new name. The `ids` or `names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_quota_patch_with_http_info(policy, authorization, x_request_id, ids, ignore_usage, names, async_req=True)
        >>> result = thread.get()
        
        :param policy: (required)
        :type policy: models.PolicyPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param ignore_usage: Flag used to override checks for quota management operations. If set to `true`,
                            directory usage is not checked against the `quota_limits` that are set. If
                            set to `false`, the actual logical bytes in use are prevented from
                            exceeding the limits set on the directory. Client operations might be
                            impacted. If the limit exceeds the quota, the client operation is not
                            allowed. If not specified, defaults to `false`.
        :type ignore_usage: bool
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            policy=policy,
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            ignore_usage=ignore_usage,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_quota_patch_with_http_info', kwargs)

    def post_policies_quota(
        self,
        sources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        source_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source ID specified. Enter multiple source IDs in comma-separated format.")] = None,
        source_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source name specified. Enter multiple source names in comma-separated format. For example, `name01,name02`.")] = None,
        policy: Optional['models.PolicyPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create quota policies  # noqa: E501
        
        Creates one or more quota policies. To copy a policy, the `source_names` or `source_ids` parameter is required, but they cannot be set together. To create a policy from scratch, policy body is required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_quota_post_with_http_info(authorization, x_request_id, names, source_ids, source_names, policy, async_req=True)
        >>> result = thread.get()
        
        :param sources: A list of sources to query for. Overrides source_ids and source_names keyword arguments.
        :type sources: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param source_ids: Performs the operation on the source ID specified. Enter multiple source IDs in
                        comma-separated format.
        :type source_ids: List[str]
        :param source_names: Performs the operation on the source name specified. Enter multiple source names
                            in comma-separated format. For example, `name01,name02`.
        :type source_names: List[str]
        :param policy:
        :type policy: PolicyPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            source_ids=source_ids,
            source_names=source_names,
            policy=policy,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _process_references(sources, ['source_ids', 'source_names'], kwargs)
        _fixup_list_type_params(['names', 'source_ids', 'source_names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_quota_post_with_http_info', kwargs)

    def delete_policies_quota_rules(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete quota policy rules  # noqa: E501
        
        Deletes one or more quota policy rules. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_quota_rules_delete_with_http_info(authorization, x_request_id, names, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_quota_rules_delete_with_http_info', kwargs)

    def get_policies_quota_rules(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List quota policy rules  # noqa: E501
        
        Displays a list of quota policy rules.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_quota_rules_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, limit, names, offset, policy_ids, policy_names, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_quota_rules_get_with_http_info', kwargs)

    def patch_policies_quota_rules(
        self,
        rules: 'models.PolicyRuleQuotaPatch',
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ignore_usage: Annotated[Optional[StrictBool], Field(description="Flag used to override checks for quota management operations. If set to `true`, directory usage is not checked against the `quota_limits` that are set. If set to `false`, the actual logical bytes in use are prevented from exceeding the limits set on the directory. Client operations might be impacted. If the limit exceeds the quota, the client operation is not allowed. If not specified, defaults to `false`.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify quota policy rules  # noqa: E501
        
        Modifies quota policy rules.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_quota_rules_patch_with_http_info(rules, authorization, x_request_id, ignore_usage, names, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param rules: (required)
        :type rules: models.PolicyRuleQuotaPatch
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ignore_usage: Flag used to override checks for quota management operations. If set to `true`,
                            directory usage is not checked against the `quota_limits` that are set. If
                            set to `false`, the actual logical bytes in use are prevented from
                            exceeding the limits set on the directory. Client operations might be
                            impacted. If the limit exceeds the quota, the client operation is not
                            allowed. If not specified, defaults to `false`.
        :type ignore_usage: bool
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            rules=rules,
            authorization=authorization,
            x_request_id=x_request_id,
            ignore_usage=ignore_usage,
            names=names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_quota_rules_patch_with_http_info', kwargs)

    def post_policies_quota_rules(
        self,
        rules: 'models.PolicyRuleQuotaPost',
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ignore_usage: Annotated[Optional[StrictBool], Field(description="Flag used to override checks for quota management operations. If set to `true`, directory usage is not checked against the `quota_limits` that are set. If set to `false`, the actual logical bytes in use are prevented from exceeding the limits set on the directory. Client operations might be impacted. If the limit exceeds the quota, the client operation is not allowed. If not specified, defaults to `false`.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create quota policy rules  # noqa: E501
        
        Creates one or more quota policy rules. The `policy_ids` or `policy_names` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_quota_rules_post_with_http_info(rules, authorization, x_request_id, ignore_usage, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param rules: (required)
        :type rules: models.PolicyRuleQuotaPost
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ignore_usage: Flag used to override checks for quota management operations. If set to `true`,
                            directory usage is not checked against the `quota_limits` that are set. If
                            set to `false`, the actual logical bytes in use are prevented from
                            exceeding the limits set on the directory. Client operations might be
                            impacted. If the limit exceeds the quota, the client operation is not
                            allowed. If not specified, defaults to `false`.
        :type ignore_usage: bool
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            rules=rules,
            authorization=authorization,
            x_request_id=x_request_id,
            ignore_usage=ignore_usage,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_quota_rules_post_with_http_info', kwargs)

    def delete_policies_smb_client_rules(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete SMB client policy rules.  # noqa: E501
        
        Deletes one or more SMB client policy rules. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_smb_client_rules_delete_with_http_info(authorization, x_request_id, names, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_smb_client_rules_delete_with_http_info', kwargs)

    def get_policies_smb_client_rules(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List SMB client policy rules  # noqa: E501
        
        Displays a list of SMB client policy rules.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_smb_client_rules_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, limit, names, offset, policy_ids, policy_names, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_smb_client_rules_get_with_http_info', kwargs)

    def post_policies_smb_client_rules(
        self,
        rules: 'models.PolicyRuleSmbClientPost',
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create SMB client policy rules  # noqa: E501
        
        Creates one or more SMB client policy rules. The `policy_ids` or `policy_names` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_smb_client_rules_post_with_http_info(rules, authorization, x_request_id, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param rules: (required)
        :type rules: models.PolicyRuleSmbClientPost
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            rules=rules,
            authorization=authorization,
            x_request_id=x_request_id,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_smb_client_rules_post_with_http_info', kwargs)

    def delete_policies_smb(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete SMB policies  # noqa: E501
        
        Deletes one or more SMB policies. The `ids` or `names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_smb_delete_with_http_info(authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_smb_delete_with_http_info', kwargs)

    def get_policies_smb(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List SMB policies  # noqa: E501
        
        Displays a list of SMB policies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_smb_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, ids, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_smb_get_with_http_info', kwargs)

    def delete_policies_smb_members(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        member_types: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the member types specified. The type of member is the full name of the resource endpoint. Valid values include `directories`. Enter multiple member types in comma-separated format. For example, `type01,type02`.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete SMB policies  # noqa: E501
        
        Deletes one or more SMB policies from resources. The `policy_ids` or `policy_names` parameter is required, but cannot be set together. The `member_ids` or `member_names` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_smb_members_delete_with_http_info(authorization, x_request_id, member_ids, member_names, member_types, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param member_types: Performs the operation on the member types specified. The type of member is the
                            full name of the resource endpoint. Valid values include `directories`.
                            Enter multiple member types in comma-separated format. For example,
                            `type01,type02`.
        :type member_types: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            member_ids=member_ids,
            member_names=member_names,
            member_types=member_types,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'member_types', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_smb_members_delete_with_http_info', kwargs)

    def get_policies_smb_members(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        member_types: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the member types specified. The type of member is the full name of the resource endpoint. Valid values include `directories`. Enter multiple member types in comma-separated format. For example, `type01,type02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List SMB policy members  # noqa: E501
        
        Displays a list of SMB policy members.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_smb_members_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, limit, member_ids, member_names, member_types, offset, policy_ids, policy_names, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param member_types: Performs the operation on the member types specified. The type of member is the
                            full name of the resource endpoint. Valid values include `directories`.
                            Enter multiple member types in comma-separated format. For example,
                            `type01,type02`.
        :type member_types: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            member_types=member_types,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'member_types', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_smb_members_get_with_http_info', kwargs)

    def post_policies_smb_members(
        self,
        members: 'models.PolicyMemberExportPost',
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create SMB policies  # noqa: E501
        
        Creates a membership between one or more resources and an SMB policy. Applicable resources are directories. The `policy_ids` or `policy_names` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_smb_members_post_with_http_info(members, authorization, x_request_id, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param members: (required)
        :type members: models.PolicyMemberExportPost
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            members=members,
            authorization=authorization,
            x_request_id=x_request_id,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_smb_members_post_with_http_info', kwargs)

    def patch_policies_smb(
        self,
        policy: 'models.PolicySmbPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify SMB policies  # noqa: E501
        
        Modifies one or more SMB policies. To enable a policy, set `enabled=true`. To disable a policy, set `enabled=false`. To enable access based enumeration, set `access_based_enumeration_enabled=true`. To disable access based enumeration, set `access_based_enumeration_enabled=false`. To rename a policy, set `name` to the new name. The `ids` or `names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_smb_patch_with_http_info(policy, authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param policy: (required)
        :type policy: models.PolicySmbPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            policy=policy,
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_smb_patch_with_http_info', kwargs)

    def post_policies_smb(
        self,
        sources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        source_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source ID specified. Enter multiple source IDs in comma-separated format.")] = None,
        source_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source name specified. Enter multiple source names in comma-separated format. For example, `name01,name02`.")] = None,
        policy: Optional['models.PolicySmbPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create SMB policies  # noqa: E501
        
        Creates one or more SMB policies. To copy a policy, set one of either `source_names` or `source_ids`. Each policy can only have one entry. To create a policy from scratch, policy body is required. To create an SMB policy with access based enumeration enabled, set `access_based_enumeration_enabled=true`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_smb_post_with_http_info(authorization, x_request_id, names, source_ids, source_names, policy, async_req=True)
        >>> result = thread.get()
        
        :param sources: A list of sources to query for. Overrides source_ids and source_names keyword arguments.
        :type sources: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param source_ids: Performs the operation on the source ID specified. Enter multiple source IDs in
                        comma-separated format.
        :type source_ids: List[str]
        :param source_names: Performs the operation on the source name specified. Enter multiple source names
                            in comma-separated format. For example, `name01,name02`.
        :type source_names: List[str]
        :param policy:
        :type policy: PolicySmbPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            source_ids=source_ids,
            source_names=source_names,
            policy=policy,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _process_references(sources, ['source_ids', 'source_names'], kwargs)
        _fixup_list_type_params(['names', 'source_ids', 'source_names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_smb_post_with_http_info', kwargs)

    def delete_policies_snapshot(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete snapshot policies  # noqa: E501
        
        Deletes one or more snapshot policies. The `ids` or `names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_snapshot_delete_with_http_info(authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_snapshot_delete_with_http_info', kwargs)

    def get_policies_snapshot(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List snapshot policies  # noqa: E501
        
        Displays a list of snapshot policies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_snapshot_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, ids, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_snapshot_get_with_http_info', kwargs)

    def delete_policies_snapshot_members(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        member_types: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the member types specified. The type of member is the full name of the resource endpoint. Valid values include `directories`. Enter multiple member types in comma-separated format. For example, `type01,type02`.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete snapshot policies  # noqa: E501
        
        Deletes one or more snapshot policies from resources. The `policy_ids` or `policy_names` parameter is required, but cannot be set together. The `member_ids` or `member_names` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_snapshot_members_delete_with_http_info(authorization, x_request_id, member_ids, member_names, member_types, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param member_types: Performs the operation on the member types specified. The type of member is the
                            full name of the resource endpoint. Valid values include `directories`.
                            Enter multiple member types in comma-separated format. For example,
                            `type01,type02`.
        :type member_types: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            member_ids=member_ids,
            member_names=member_names,
            member_types=member_types,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'member_types', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_snapshot_members_delete_with_http_info', kwargs)

    def get_policies_snapshot_members(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        member_types: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the member types specified. The type of member is the full name of the resource endpoint. Valid values include `directories`. Enter multiple member types in comma-separated format. For example, `type01,type02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List snapshot policy members  # noqa: E501
        
        Displays a list of snapshot policy members.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_snapshot_members_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, limit, member_ids, member_names, member_types, offset, policy_ids, policy_names, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param member_types: Performs the operation on the member types specified. The type of member is the
                            full name of the resource endpoint. Valid values include `directories`.
                            Enter multiple member types in comma-separated format. For example,
                            `type01,type02`.
        :type member_types: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            member_types=member_types,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'member_types', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_snapshot_members_get_with_http_info', kwargs)

    def post_policies_snapshot_members(
        self,
        members: 'models.PolicyMemberPost',
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create snapshot policies  # noqa: E501
        
        Creates a membership between one or more resources and a snapshot policy. Applicable resources are directories. The `policy_ids` or `policy_names` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_snapshot_members_post_with_http_info(members, authorization, x_request_id, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param members: (required)
        :type members: models.PolicyMemberPost
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            members=members,
            authorization=authorization,
            x_request_id=x_request_id,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_snapshot_members_post_with_http_info', kwargs)

    def patch_policies_snapshot(
        self,
        policy: 'models.PolicyPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify snapshot policies  # noqa: E501
        
        Modifies one or more snapshot policies. To enable a policy, set `enabled=true`. To disable a policy, set `enabled=true`. To rename a policy, set `name` to the new name. The `ids` or `names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_snapshot_patch_with_http_info(policy, authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param policy: (required)
        :type policy: models.PolicyPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            policy=policy,
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_snapshot_patch_with_http_info', kwargs)

    def post_policies_snapshot(
        self,
        sources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        source_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source ID specified. Enter multiple source IDs in comma-separated format.")] = None,
        source_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source name specified. Enter multiple source names in comma-separated format. For example, `name01,name02`.")] = None,
        policy: Optional['models.PolicyPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create snapshot policies  # noqa: E501
        
        Creates one or more snapshot policies. To copy a policy, set one of either `source_names` or `source_ids`. Each policy can only have one entry. To create a policy from scratch, policy body is required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_snapshot_post_with_http_info(authorization, x_request_id, names, source_ids, source_names, policy, async_req=True)
        >>> result = thread.get()
        
        :param sources: A list of sources to query for. Overrides source_ids and source_names keyword arguments.
        :type sources: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param source_ids: Performs the operation on the source ID specified. Enter multiple source IDs in
                        comma-separated format.
        :type source_ids: List[str]
        :param source_names: Performs the operation on the source name specified. Enter multiple source names
                            in comma-separated format. For example, `name01,name02`.
        :type source_names: List[str]
        :param policy:
        :type policy: PolicyPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            source_ids=source_ids,
            source_names=source_names,
            policy=policy,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _process_references(sources, ['source_ids', 'source_names'], kwargs)
        _fixup_list_type_params(['names', 'source_ids', 'source_names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_snapshot_post_with_http_info', kwargs)

    def delete_policies_snapshot_rules(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete snapshot policy rules  # noqa: E501
        
        Deletes one or more snapshot policy rules. The `policy_ids` or `policy_names` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_snapshot_rules_delete_with_http_info(authorization, x_request_id, names, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_snapshot_rules_delete_with_http_info', kwargs)

    def get_policies_snapshot_rules(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List snapshot policy rules  # noqa: E501
        
        Displays a list of snapshot policy rules.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_snapshot_rules_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, limit, names, offset, policy_ids, policy_names, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_snapshot_rules_get_with_http_info', kwargs)

    def post_policies_snapshot_rules(
        self,
        rules: 'models.PolicyRuleSnapshotPost',
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create snapshot policy rules  # noqa: E501
        
        Creates one or more snapshot policy rules. The `policy_ids` or `policy_names` parameter is required, but cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_policies_snapshot_rules_post_with_http_info(rules, authorization, x_request_id, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param rules: (required)
        :type rules: models.PolicyRuleSnapshotPost
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy
                        IDs in comma-separated format. The `policy_ids` or `policy_names` parameter
                        is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy
                            names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            rules=rules,
            authorization=authorization,
            x_request_id=x_request_id,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesApi', 'api232_policies_snapshot_rules_post_with_http_info', kwargs)

    def get_ports(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List ports  # noqa: E501
        
        Displays host name, iSCSI Qualified Names (IQNs), NVMe Qualified Names (NQNs), IPv4 address of the portal, Fibre Channel World Wide Names (WWNs), and failover ports, including those that were discovered by Purity//FA and those that have been manually assigned by system administrators.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_ports_get_with_http_info(authorization, x_request_id, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('PortsApi', 'api232_ports_get_with_http_info', kwargs)

    def get_ports_initiators(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List port initiators  # noqa: E501
        
        Displays host iSCSI Qualified Names (IQNs), NVMe Qualified Names (NQNs), and Fibre Channel World Wide Names (WWNs), including those that were discovered by Purity//FA and those that have been manually assigned by system administrators, along with the array ports (targets) on which they are eligible to communicate.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_ports_initiators_get_with_http_info(authorization, x_request_id, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('PortsApi', 'api232_ports_initiators_get_with_http_info', kwargs)

    def delete_protection_group_snapshots(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a protection group snapshot  # noqa: E501
        
        Deletes a protection group snapshot that has been destroyed and is pending eradication. Eradicating a protection group snapshot eradicates all of its protection group snapshots and cannot be recovered. Protection group snapshots are destroyed through the `PATCH` method. The `names` or `ids` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_protection_group_snapshots_delete_with_http_info(authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('ProtectionGroupSnapshotsApi', 'api232_protection_group_snapshots_delete_with_http_info', kwargs)

    def get_protection_group_snapshots(
        self,
        sources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        source_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source ID specified. Enter multiple source IDs in comma-separated format.")] = None,
        source_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source name specified. Enter multiple source names in comma-separated format. For example, `name01,name02`.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List protection group snapshots  # noqa: E501
        
        Displays a list of protection group snapshots, including those pending eradication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_protection_group_snapshots_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, ids, limit, names, offset, sort, source_ids, source_names, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param sources: A list of sources to query for. Overrides source_ids and source_names keyword arguments.
        :type sources: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param source_ids: Performs the operation on the source ID specified. Enter multiple source IDs in
                        comma-separated format.
        :type source_ids: List[str]
        :param source_names: Performs the operation on the source name specified. Enter multiple source names
                            in comma-separated format. For example, `name01,name02`.
        :type source_names: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            source_ids=source_ids,
            source_names=source_names,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _process_references(sources, ['source_ids', 'source_names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort', 'source_ids', 'source_names'], kwargs)
        return self._call_api('ProtectionGroupSnapshotsApi', 'api232_protection_group_snapshots_get_with_http_info', kwargs)

    def patch_protection_group_snapshots(
        self,
        protection_group_snapshot: 'models.ProtectionGroupSnapshotPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify a protection group snapshot  # noqa: E501
        
        Modifies a protection group snapshot so that it can be destroyed. To destroy a volume, set `destroyed=true`. To recover a volume that has been destroyed and is pending eradication, set `destroyed=false`. The `names` or `ids` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_protection_group_snapshots_patch_with_http_info(protection_group_snapshot, authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param protection_group_snapshot: (required)
        :type protection_group_snapshot: models.ProtectionGroupSnapshotPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            protection_group_snapshot=protection_group_snapshot,
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('ProtectionGroupSnapshotsApi', 'api232_protection_group_snapshots_patch_with_http_info', kwargs)

    def post_protection_group_snapshots(
        self,
        sources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_throttle: Annotated[Optional[StrictBool], Field(description="If set to `true`, allows snapshot to fail if array health is not optimal.")] = None,
        apply_retention: Annotated[Optional[StrictBool], Field(description="If `true`, applies the local and remote retention policy to the snapshots.")] = None,
        for_replication: Annotated[Optional[StrictBool], Field(description="If `true`, destroys and eradicates the snapshot after 1 hour.")] = None,
        replicate: Annotated[Optional[StrictBool], Field(description="If set to `true`, queues up and begins replicating to each allowed target after all earlier replication sessions for the same protection group have been completed to that target. The `replicate` and `replicate_now` parameters cannot be used together.")] = None,
        replicate_now: Annotated[Optional[StrictBool], Field(description="If set to `true`, replicates the snapshots to each allowed target. The `replicate` and `replicate_now` parameters cannot be used together.")] = None,
        source_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source ID specified. Enter multiple source IDs in comma-separated format.")] = None,
        source_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source name specified. Enter multiple source names in comma-separated format. For example, `name01,name02`.")] = None,
        protection_group_snapshot: Optional['models.ProtectionGroupSnapshotPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a protection group snapshot  # noqa: E501
        
        Creates a point-in-time snapshot of the contents of a protection group. The `source_ids` or `source_names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_protection_group_snapshots_post_with_http_info(authorization, x_request_id, allow_throttle, apply_retention, for_replication, replicate, replicate_now, source_ids, source_names, protection_group_snapshot, async_req=True)
        >>> result = thread.get()
        
        :param sources: A list of sources to query for. Overrides source_ids and source_names keyword arguments.
        :type sources: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_throttle: If set to `true`, allows snapshot to fail if array health is not optimal.
        :type allow_throttle: bool
        :param apply_retention: If `true`, applies the local and remote retention policy to the snapshots.
        :type apply_retention: bool
        :param for_replication: If `true`, destroys and eradicates the snapshot after 1 hour.
        :type for_replication: bool
        :param replicate: If set to `true`, queues up and begins replicating to each allowed target after
                        all earlier replication sessions for the same protection group have been
                        completed to that target. The `replicate` and `replicate_now` parameters
                        cannot be used together.
        :type replicate: bool
        :param replicate_now: If set to `true`, replicates the snapshots to each allowed target. The
                            `replicate` and `replicate_now` parameters cannot be used together.
        :type replicate_now: bool
        :param source_ids: Performs the operation on the source ID specified. Enter multiple source IDs in
                        comma-separated format.
        :type source_ids: List[str]
        :param source_names: Performs the operation on the source name specified. Enter multiple source names
                            in comma-separated format. For example, `name01,name02`.
        :type source_names: List[str]
        :param protection_group_snapshot:
        :type protection_group_snapshot: ProtectionGroupSnapshotPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            allow_throttle=allow_throttle,
            apply_retention=apply_retention,
            for_replication=for_replication,
            replicate=replicate,
            replicate_now=replicate_now,
            source_ids=source_ids,
            source_names=source_names,
            protection_group_snapshot=protection_group_snapshot,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(sources, ['source_ids', 'source_names'], kwargs)
        _fixup_list_type_params(['source_ids', 'source_names'], kwargs)
        return self._call_api('ProtectionGroupSnapshotsApi', 'api232_protection_group_snapshots_post_with_http_info', kwargs)

    def post_protection_group_snapshots_replica(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        convert_source_to_baseline: Annotated[Optional[StrictBool], Field(description="Set to `true` to have the snapshot be eradicated when it is no longer baseline on source.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        on: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation locally with the target names specified as the destinations of the operation. Enter multiple target names in comma-separated format. For example, `targetName01,targetName02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create an action to send protection group snapshots  # noqa: E501
        
        Creates an action to send protection group snapshots to protection pgroup targets. When the `on` option is used, only specified targets will recieve the protection group snapshots.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_protection_group_snapshots_replica_post_with_http_info(authorization, x_request_id, convert_source_to_baseline, ids, names, on, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param convert_source_to_baseline: Set to `true` to have the snapshot be eradicated when it is no longer baseline
                                        on source.
        :type convert_source_to_baseline: bool
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param on: Performs the operation locally with the target names specified as the
                destinations of the operation. Enter multiple target names in comma-separated
                format. For example, `targetName01,targetName02`.
        :type on: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            convert_source_to_baseline=convert_source_to_baseline,
            ids=ids,
            names=names,
            on=on,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'on'], kwargs)
        return self._call_api('ProtectionGroupSnapshotsApi', 'api232_protection_group_snapshots_replica_post_with_http_info', kwargs)

    def post_protection_group_snapshots_test(
        self,
        sources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_throttle: Annotated[Optional[StrictBool], Field(description="If set to `true`, allows snapshot to fail if array health is not optimal.")] = None,
        apply_retention: Annotated[Optional[StrictBool], Field(description="If `true`, applies the local and remote retention policy to the snapshots.")] = None,
        for_replication: Annotated[Optional[StrictBool], Field(description="If `true`, destroys and eradicates the snapshot after 1 hour.")] = None,
        replicate: Annotated[Optional[StrictBool], Field(description="If set to `true`, queues up and begins replicating to each allowed target after all earlier replication sessions for the same protection group have been completed to that target. The `replicate` and `replicate_now` parameters cannot be used together.")] = None,
        replicate_now: Annotated[Optional[StrictBool], Field(description="If set to `true`, replicates the snapshots to each allowed target. The `replicate` and `replicate_now` parameters cannot be used together.")] = None,
        source_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source ID specified. Enter multiple source IDs in comma-separated format.")] = None,
        source_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source name specified. Enter multiple source names in comma-separated format. For example, `name01,name02`.")] = None,
        protection_group_snapshot: Optional['models.ProtectionGroupSnapshotPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create an attempt to take protection group snapshot  # noqa: E501
        
        Creates an attempt to take the protection group snapshot, without actually taking it, to test if the snapshot can be successfully taken.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_protection_group_snapshots_test_post_with_http_info(authorization, x_request_id, allow_throttle, apply_retention, for_replication, replicate, replicate_now, source_ids, source_names, protection_group_snapshot, async_req=True)
        >>> result = thread.get()
        
        :param sources: A list of sources to query for. Overrides source_ids and source_names keyword arguments.
        :type sources: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_throttle: If set to `true`, allows snapshot to fail if array health is not optimal.
        :type allow_throttle: bool
        :param apply_retention: If `true`, applies the local and remote retention policy to the snapshots.
        :type apply_retention: bool
        :param for_replication: If `true`, destroys and eradicates the snapshot after 1 hour.
        :type for_replication: bool
        :param replicate: If set to `true`, queues up and begins replicating to each allowed target after
                        all earlier replication sessions for the same protection group have been
                        completed to that target. The `replicate` and `replicate_now` parameters
                        cannot be used together.
        :type replicate: bool
        :param replicate_now: If set to `true`, replicates the snapshots to each allowed target. The
                            `replicate` and `replicate_now` parameters cannot be used together.
        :type replicate_now: bool
        :param source_ids: Performs the operation on the source ID specified. Enter multiple source IDs in
                        comma-separated format.
        :type source_ids: List[str]
        :param source_names: Performs the operation on the source name specified. Enter multiple source names
                            in comma-separated format. For example, `name01,name02`.
        :type source_names: List[str]
        :param protection_group_snapshot:
        :type protection_group_snapshot: ProtectionGroupSnapshotPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            allow_throttle=allow_throttle,
            apply_retention=apply_retention,
            for_replication=for_replication,
            replicate=replicate,
            replicate_now=replicate_now,
            source_ids=source_ids,
            source_names=source_names,
            protection_group_snapshot=protection_group_snapshot,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(sources, ['source_ids', 'source_names'], kwargs)
        _fixup_list_type_params(['source_ids', 'source_names'], kwargs)
        return self._call_api('ProtectionGroupSnapshotsApi', 'api232_protection_group_snapshots_test_post_with_http_info', kwargs)

    def get_protection_group_snapshots_transfer(
        self,
        sources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        source_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source ID specified. Enter multiple source IDs in comma-separated format.")] = None,
        source_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source name specified. Enter multiple source names in comma-separated format. For example, `name01,name02`.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List protection group snapshots with transfer statistics  # noqa: E501
        
        Displays a list of protection group snapshots and corresponding transfer statistics.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_protection_group_snapshots_transfer_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, ids, limit, names, offset, sort, source_ids, source_names, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param sources: A list of sources to query for. Overrides source_ids and source_names keyword arguments.
        :type sources: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param source_ids: Performs the operation on the source ID specified. Enter multiple source IDs in
                        comma-separated format.
        :type source_ids: List[str]
        :param source_names: Performs the operation on the source name specified. Enter multiple source names
                            in comma-separated format. For example, `name01,name02`.
        :type source_names: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            source_ids=source_ids,
            source_names=source_names,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _process_references(sources, ['source_ids', 'source_names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort', 'source_ids', 'source_names'], kwargs)
        return self._call_api('ProtectionGroupSnapshotsApi', 'api232_protection_group_snapshots_transfer_get_with_http_info', kwargs)

    def delete_protection_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a protection group  # noqa: E501
        
        Deletes a protection group that has been destroyed and is pending eradication. Eradicated protection groups cannot be recovered. Protection groups are destroyed through the `PATCH` method. The `names` parameter is required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_protection_groups_delete_with_http_info(authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('ProtectionGroupsApi', 'api232_protection_groups_delete_with_http_info', kwargs)

    def get_protection_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List protection groups  # noqa: E501
        
        Displays a list of protection groups, including their associated source arrays, replication targets, hosts, host groups, and volumes. The list includes protection groups that were created on the local array to replicate snapshot data to other arrays or offload targets, created on a remote array and replicated asynchronously to this array, or created inside a pod on a remote array and stretched to the local array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_protection_groups_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, ids, limit, names, offset, sort, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('ProtectionGroupsApi', 'api232_protection_groups_get_with_http_info', kwargs)

    def delete_protection_groups_host_groups(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a host group from a protection group  # noqa: E501
        
        Deletes a host group member from a protection group. After the member has been removed, it is no longer protected by the group. Protection group snapshots taken before the member was removed will not be affected. Removing a member from a protection group does not delete the member from the array, and the member can be added back to the protection group at any time. The `group_names` parameter represents the name of the protection group, and the `member_names` parameter represents the name of the host group. The `group_names` and `member_names` parameters are required and must be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_protection_groups_host_groups_delete_with_http_info(authorization, x_request_id, group_ids, group_names, member_names, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_names keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_ids and group_names keyword arguments.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param group_ids: A comma-separated list of group IDs.
        :type group_ids: List[str]
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            group_ids=group_ids,
            group_names=group_names,
            member_names=member_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_ids', 'group_names'], kwargs)
        _process_references(members, ['member_names'], kwargs)
        _fixup_list_type_params(['group_ids', 'group_names', 'member_names'], kwargs)
        return self._call_api('ProtectionGroupsApi', 'api232_protection_groups_host_groups_delete_with_http_info', kwargs)

    def get_protection_groups_host_groups(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List protection groups with host group members  # noqa: E501
        
        Displays a list of protection groups that have host group members.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_protection_groups_host_groups_get_with_http_info(authorization, x_request_id, continuation_token, filter, group_ids, group_names, limit, member_names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_names keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_ids and group_names keyword arguments.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param group_ids: A comma-separated list of group IDs.
        :type group_ids: List[str]
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            group_ids=group_ids,
            group_names=group_names,
            limit=limit,
            member_names=member_names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_ids', 'group_names'], kwargs)
        _process_references(members, ['member_names'], kwargs)
        _fixup_list_type_params(['group_ids', 'group_names', 'member_names', 'sort'], kwargs)
        return self._call_api('ProtectionGroupsApi', 'api232_protection_groups_host_groups_get_with_http_info', kwargs)

    def post_protection_groups_host_groups(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Creates an action to add a host group to a protection group  # noqa: E501
        
        Creates an action to add a host group member to a protection group. Members that are already in the protection group are not affected. For asynchronous replication, only members of the same type can belong to a protection group. The `group_names` parameter represents the name of the protection group, and the `member_names` parameter represents the name of the host group. The `group_names` and `member_names` parameters are required and must be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_protection_groups_host_groups_post_with_http_info(authorization, x_request_id, group_ids, group_names, member_names, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_names keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_ids and group_names keyword arguments.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param group_ids: A comma-separated list of group IDs.
        :type group_ids: List[str]
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            group_ids=group_ids,
            group_names=group_names,
            member_names=member_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_ids', 'group_names'], kwargs)
        _process_references(members, ['member_names'], kwargs)
        _fixup_list_type_params(['group_ids', 'group_names', 'member_names'], kwargs)
        return self._call_api('ProtectionGroupsApi', 'api232_protection_groups_host_groups_post_with_http_info', kwargs)

    def delete_protection_groups_hosts(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a host from a protection group  # noqa: E501
        
        Deletes a host member from a protection group. After the member has been removed, it is no longer protected by the group. Any protection group snapshots that were taken before the member was removed will not be affected. Removing a member from a protection group does not delete the member from the array, and the member can be added back to the protection group at any time. The `group_names` parameter represents the name of the protection group, and the `member_names` parameter represents the name of the host. The `group_names` and `member_names` parameters are required and must be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_protection_groups_hosts_delete_with_http_info(authorization, x_request_id, group_ids, group_names, member_names, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_names keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_ids and group_names keyword arguments.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param group_ids: A comma-separated list of group IDs.
        :type group_ids: List[str]
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            group_ids=group_ids,
            group_names=group_names,
            member_names=member_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_ids', 'group_names'], kwargs)
        _process_references(members, ['member_names'], kwargs)
        _fixup_list_type_params(['group_ids', 'group_names', 'member_names'], kwargs)
        return self._call_api('ProtectionGroupsApi', 'api232_protection_groups_hosts_delete_with_http_info', kwargs)

    def get_protection_groups_hosts(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List protection groups with host members  # noqa: E501
        
        Displays a list of protection groups that have host members.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_protection_groups_hosts_get_with_http_info(authorization, x_request_id, continuation_token, filter, group_ids, group_names, limit, member_names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_names keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_ids and group_names keyword arguments.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param group_ids: A comma-separated list of group IDs.
        :type group_ids: List[str]
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            group_ids=group_ids,
            group_names=group_names,
            limit=limit,
            member_names=member_names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_ids', 'group_names'], kwargs)
        _process_references(members, ['member_names'], kwargs)
        _fixup_list_type_params(['group_ids', 'group_names', 'member_names', 'sort'], kwargs)
        return self._call_api('ProtectionGroupsApi', 'api232_protection_groups_hosts_get_with_http_info', kwargs)

    def post_protection_groups_hosts(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create an action to add a host to a protection group  # noqa: E501
        
        Creates an action to add a host member to a protection group. Members that are already in the protection group are not affected. For asynchronous replication, only members of the same type can belong to a protection group. The `group_names` parameter represents the name of the protection group, and the `member_names` parameter represents the name of the host. The `group_names` and `member_names` parameters are required and must be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_protection_groups_hosts_post_with_http_info(authorization, x_request_id, group_ids, group_names, member_names, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_names keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_ids and group_names keyword arguments.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param group_ids: A comma-separated list of group IDs.
        :type group_ids: List[str]
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            group_ids=group_ids,
            group_names=group_names,
            member_names=member_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_ids', 'group_names'], kwargs)
        _process_references(members, ['member_names'], kwargs)
        _fixup_list_type_params(['group_ids', 'group_names', 'member_names'], kwargs)
        return self._call_api('ProtectionGroupsApi', 'api232_protection_groups_hosts_post_with_http_info', kwargs)

    def patch_protection_groups(
        self,
        protection_group: 'models.ProtectionGroup',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify a protection group  # noqa: E501
        
        Modifies the protection group schedules to generate and replicate snapshots to another array or to an external storage system. Renames or destroys a protection group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_protection_groups_patch_with_http_info(protection_group, authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param protection_group: (required)
        :type protection_group: models.ProtectionGroup
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            protection_group=protection_group,
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('ProtectionGroupsApi', 'api232_protection_groups_patch_with_http_info', kwargs)

    def get_protection_groups_performance_replication_by_array(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The number of milliseconds between samples of historical data. For array-wide performance metrics (`/arrays/performance` endpoint), valid values are `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For performance metrics on storage objects (`<object name>/performance` endpoint), such as volumes, valid values are `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For space metrics, (`<object name>/space` endpoint), valid values are `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). Include the `start_time` parameter to display the performance data starting at the specified start time. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. Include the `end_time` parameter to display the performance data until the specified end time. If `end_time`is not specified, the end time will default to the current time. If the `resolution` parameter is not specified but either the `start_time` or `end_time` parameter is, then `resolution` will default to the lowest valid resolution.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List protection group replication performance data with array details  # noqa: E501
        
        Displays the total number of bytes of replication data transmitted and received per second. The data is grouped by protection group and includes the names of the source array and targets for each protection group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_protection_groups_performance_replication_by_array_get_with_http_info(authorization, x_request_id, destroyed, end_time, filter, ids, limit, names, offset, resolution, sort, start_time, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param end_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type end_time: int
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param resolution: The number of milliseconds between samples of historical data. For array-wide
                        performance metrics (`/arrays/performance` endpoint), valid values are
                        `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30
                        minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24
                        hours). For performance metrics on storage objects (`<object
                        name>/performance` endpoint), such as volumes, valid values are `30000` (30
                        seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours),
                        `28800000` (8 hours), and `86400000` (24 hours). For space metrics,
                        (`<object name>/space` endpoint), valid values are `300000` (5 minutes),
                        `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and
                        `86400000` (24 hours). Include the `start_time` parameter to display the
                        performance data starting at the specified start time. If `start_time` is
                        not specified, the start time will default to one resolution before the end
                        time, meaning that the most recent sample of performance data will be
                        displayed. Include the `end_time` parameter to display the performance data
                        until the specified end time. If `end_time`is not specified, the end time
                        will default to the current time. If the `resolution` parameter is not
                        specified but either the `start_time` or `end_time` parameter is, then
                        `resolution` will default to the lowest valid resolution.
        :type resolution: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param start_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type start_time: int
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            destroyed=destroyed,
            end_time=end_time,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('ProtectionGroupsApi', 'api232_protection_groups_performance_replication_by_array_get_with_http_info', kwargs)

    def get_protection_groups_performance_replication(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The number of milliseconds between samples of historical data. For array-wide performance metrics (`/arrays/performance` endpoint), valid values are `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For performance metrics on storage objects (`<object name>/performance` endpoint), such as volumes, valid values are `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For space metrics, (`<object name>/space` endpoint), valid values are `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). Include the `start_time` parameter to display the performance data starting at the specified start time. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. Include the `end_time` parameter to display the performance data until the specified end time. If `end_time`is not specified, the end time will default to the current time. If the `resolution` parameter is not specified but either the `start_time` or `end_time` parameter is, then `resolution` will default to the lowest valid resolution.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List protection group replication performance data  # noqa: E501
        
        Displays the total number of bytes of replication data transmitted and received per second. The data is grouped by protection group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_protection_groups_performance_replication_get_with_http_info(authorization, x_request_id, destroyed, end_time, filter, ids, limit, names, offset, resolution, sort, start_time, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param end_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type end_time: int
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param resolution: The number of milliseconds between samples of historical data. For array-wide
                        performance metrics (`/arrays/performance` endpoint), valid values are
                        `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30
                        minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24
                        hours). For performance metrics on storage objects (`<object
                        name>/performance` endpoint), such as volumes, valid values are `30000` (30
                        seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours),
                        `28800000` (8 hours), and `86400000` (24 hours). For space metrics,
                        (`<object name>/space` endpoint), valid values are `300000` (5 minutes),
                        `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and
                        `86400000` (24 hours). Include the `start_time` parameter to display the
                        performance data starting at the specified start time. If `start_time` is
                        not specified, the start time will default to one resolution before the end
                        time, meaning that the most recent sample of performance data will be
                        displayed. Include the `end_time` parameter to display the performance data
                        until the specified end time. If `end_time`is not specified, the end time
                        will default to the current time. If the `resolution` parameter is not
                        specified but either the `start_time` or `end_time` parameter is, then
                        `resolution` will default to the lowest valid resolution.
        :type resolution: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param start_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type start_time: int
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            destroyed=destroyed,
            end_time=end_time,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('ProtectionGroupsApi', 'api232_protection_groups_performance_replication_get_with_http_info', kwargs)

    def post_protection_groups(
        self,
        sources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        overwrite: Annotated[Optional[StrictBool], Field(description="If set to `true`, overwrites an existing object during an object copy operation. If set to `false` or not set at all and the target name is an existing object, the copy operation fails. Required if the `source` body parameter is set and the source overwrites an existing object during the copy operation.")] = None,
        source_ids: Annotated[Optional[conlist(StrictStr)], Field(description="The id of the protection group or protection group snapshot to be copied into a new or existing protection group. If the destination protection group and all of its volumes already exist, include the `overwrite` parameter to overwrite all of the existing volumes with the snapshot contents. If including the `overwrite` parameter, the names of the volumes that are being overwritten must match the names of the volumes that are being restored. If the source is a protection group, the latest snapshot of the protection group will be used as the source during the copy operation.")] = None,
        source_names: Annotated[Optional[conlist(StrictStr)], Field(description="The name of the protection group or protection group snapshot to be copied into a new or existing protection group. If the destination protection group and all of its volumes already exist, include the `overwrite` parameter to overwrite all of the existing volumes with the snapshot contents. If including the `overwrite` parameter, the names of the volumes that are being overwritten must match the names of the volumes that are being restored. If the source is a protection group, the latest snapshot of the protection group will be used as the source during the copy operation.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a protection group  # noqa: E501
        
        Creates a protection group on the local array for asynchronous replication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_protection_groups_post_with_http_info(authorization, x_request_id, names, overwrite, source_ids, source_names, async_req=True)
        >>> result = thread.get()
        
        :param sources: A list of sources to query for. Overrides source_ids and source_names keyword arguments.
        :type sources: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param overwrite: If set to `true`, overwrites an existing object during an object copy operation.
                        If set to `false` or not set at all and the target name is an existing
                        object, the copy operation fails. Required if the `source` body parameter is
                        set and the source overwrites an existing object during the copy operation.
        :type overwrite: bool
        :param source_ids: The id of the protection group or protection group snapshot to be copied into a
                        new or existing protection group. If the destination protection group and
                        all of its volumes already exist, include the `overwrite` parameter to
                        overwrite all of the existing volumes with the snapshot contents. If
                        including the `overwrite` parameter, the names of the volumes that are being
                        overwritten must match the names of the volumes that are being restored. If
                        the source is a protection group, the latest snapshot of the protection
                        group will be used as the source during the copy operation.
        :type source_ids: List[str]
        :param source_names: The name of the protection group or protection group snapshot to be copied into
                            a new or existing protection group. If the destination protection group and
                            all of its volumes already exist, include the `overwrite` parameter to
                            overwrite all of the existing volumes with the snapshot contents. If
                            including the `overwrite` parameter, the names of the volumes that are
                            being overwritten must match the names of the volumes that are being
                            restored. If the source is a protection group, the latest snapshot of the
                            protection group will be used as the source during the copy operation.
        :type source_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            overwrite=overwrite,
            source_ids=source_ids,
            source_names=source_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _process_references(sources, ['source_ids', 'source_names'], kwargs)
        _fixup_list_type_params(['names', 'source_ids', 'source_names'], kwargs)
        return self._call_api('ProtectionGroupsApi', 'api232_protection_groups_post_with_http_info', kwargs)

    def get_protection_groups_space(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List protection group space information  # noqa: E501
        
        Displays provisioned size and physical storage consumption data for each protection group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_protection_groups_space_get_with_http_info(authorization, x_request_id, destroyed, filter, ids, limit, names, offset, sort, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            destroyed=destroyed,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('ProtectionGroupsApi', 'api232_protection_groups_space_get_with_http_info', kwargs)

    def delete_protection_groups_targets(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a target from a protection group  # noqa: E501
        
        Deletes an array or offload target from a protection group. The `group_names` parameter represents the name of the protection group. The `member_names` parameter represents the name of the array or offload target that is being removed from the protection group. The `group_names` and `member_names` parameters are required and must be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_protection_groups_targets_delete_with_http_info(authorization, x_request_id, group_ids, group_names, member_names, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_names keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_ids and group_names keyword arguments.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param group_ids: A comma-separated list of group IDs.
        :type group_ids: List[str]
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            group_ids=group_ids,
            group_names=group_names,
            member_names=member_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_ids', 'group_names'], kwargs)
        _process_references(members, ['member_names'], kwargs)
        _fixup_list_type_params(['group_ids', 'group_names', 'member_names'], kwargs)
        return self._call_api('ProtectionGroupsApi', 'api232_protection_groups_targets_delete_with_http_info', kwargs)

    def get_protection_groups_targets(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List protection groups with targets  # noqa: E501
        
        Displays a list of protection groups that have target arrays or offload targets.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_protection_groups_targets_get_with_http_info(authorization, x_request_id, continuation_token, filter, group_ids, group_names, limit, member_names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_names keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_ids and group_names keyword arguments.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param group_ids: A comma-separated list of group IDs.
        :type group_ids: List[str]
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            group_ids=group_ids,
            group_names=group_names,
            limit=limit,
            member_names=member_names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_ids', 'group_names'], kwargs)
        _process_references(members, ['member_names'], kwargs)
        _fixup_list_type_params(['group_ids', 'group_names', 'member_names', 'sort'], kwargs)
        return self._call_api('ProtectionGroupsApi', 'api232_protection_groups_targets_get_with_http_info', kwargs)

    def patch_protection_groups_targets(
        self,
        target: 'models.TargetProtectionGroupPostPatch',
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify a protection group target  # noqa: E501
        
        Modifies the source array to replicate protection group data to the target array, or disallows the source array from replicating protection group data to the target array. The `allowed` parameter must be set from the target array. The `group_names` parameter represents the name of the protection group. The `allowed` and `group_names` parameters are required and must be set together. Offload targets do not support the `allowed` parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_protection_groups_targets_patch_with_http_info(target, authorization, x_request_id, group_ids, group_names, member_names, async_req=True)
        >>> result = thread.get()
        
        :param target: (required)
        :type target: models.TargetProtectionGroupPostPatch
        :param members: A list of members to query for. Overrides member_names keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_ids and group_names keyword arguments.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param group_ids: A comma-separated list of group IDs.
        :type group_ids: List[str]
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            target=target,
            authorization=authorization,
            x_request_id=x_request_id,
            group_ids=group_ids,
            group_names=group_names,
            member_names=member_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_ids', 'group_names'], kwargs)
        _process_references(members, ['member_names'], kwargs)
        _fixup_list_type_params(['group_ids', 'group_names', 'member_names'], kwargs)
        return self._call_api('ProtectionGroupsApi', 'api232_protection_groups_targets_patch_with_http_info', kwargs)

    def post_protection_groups_targets(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create an action to add a target to a protection group  # noqa: E501
        
        Creates an action to add an array or offload target to a protection group. The `group_names` parameter represents the name of the protection group. The `member_names` parameter represents the name of the array or offload target that is being added to the protection group. The `group_names` and `member_names` parameters are required and must be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_protection_groups_targets_post_with_http_info(authorization, x_request_id, group_ids, group_names, member_names, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_names keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_ids and group_names keyword arguments.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param group_ids: A comma-separated list of group IDs.
        :type group_ids: List[str]
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            group_ids=group_ids,
            group_names=group_names,
            member_names=member_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_ids', 'group_names'], kwargs)
        _process_references(members, ['member_names'], kwargs)
        _fixup_list_type_params(['group_ids', 'group_names', 'member_names'], kwargs)
        return self._call_api('ProtectionGroupsApi', 'api232_protection_groups_targets_post_with_http_info', kwargs)

    def delete_protection_groups_volumes(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a volume from a protection group  # noqa: E501
        
        Deletes a volume member from a protection group. After the member has been deleted, it is no longer protected by the group. Any protection group snapshots that were taken before the member was deleted are not affected. Deleting a member from a protection group does not delete the member from the array, and the member can be added back to the protection group at any time. The `group_names` parameter represents the name of the protection group, and the `member_names` and `member_ids` parameters represent the names or IDs of the volume. The `group_names` parameter, and either the `member_names` or `member_ids` parameters are required and must be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_protection_groups_volumes_delete_with_http_info(authorization, x_request_id, group_ids, group_names, member_ids, member_names, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_ids and group_names keyword arguments.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param group_ids: A comma-separated list of group IDs.
        :type group_ids: List[str]
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            group_ids=group_ids,
            group_names=group_names,
            member_ids=member_ids,
            member_names=member_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_ids', 'group_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _fixup_list_type_params(['group_ids', 'group_names', 'member_ids', 'member_names'], kwargs)
        return self._call_api('ProtectionGroupsApi', 'api232_protection_groups_volumes_delete_with_http_info', kwargs)

    def get_protection_groups_volumes(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group id specified. Provide multiple resource IDs in comma-separated format. The group_ids or names parameter is required, but they cannot be set together.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_destroyed: Annotated[Optional[StrictBool], Field(description="If true, returns only destroyed member objects. Returns an error if a name of a live member object is specified in the member_names query param. If false, returns only live member objects. Returns an error if a name of a destroyed member object is specified in the member_names query param.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List protection groups with volume members  # noqa: E501
        
        Displays a list of protection groups that have volume members.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_protection_groups_volumes_get_with_http_info(authorization, x_request_id, continuation_token, filter, group_ids, group_names, limit, member_destroyed, member_ids, member_names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_ids and group_names keyword arguments.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param group_ids: Performs the operation on the unique group id specified. Provide multiple
                        resource IDs in comma-separated format. The group_ids or names parameter is
                        required, but they cannot be set together.
        :type group_ids: List[str]
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_destroyed: If true, returns only destroyed member objects. Returns an error if a name of a
                                live member object is specified in the member_names query param. If false,
                                returns only live member objects. Returns an error if a name of a
                                destroyed member object is specified in the member_names query param.
        :type member_destroyed: bool
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            group_ids=group_ids,
            group_names=group_names,
            limit=limit,
            member_destroyed=member_destroyed,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_ids', 'group_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _fixup_list_type_params(['group_ids', 'group_names', 'member_ids', 'member_names', 'sort'], kwargs)
        return self._call_api('ProtectionGroupsApi', 'api232_protection_groups_volumes_get_with_http_info', kwargs)

    def post_protection_groups_volumes(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a volume and add it to a protection group  # noqa: E501
        
        Creates a volume member and adds it to a protection group. Members that are already in the protection group are not affected. For asynchronous replication, only members of the same type can belong to a protection group. The `group_names` parameter represents the name of the protection group, and the `member_names` and `member_ids` parameters represent the names or IDs of the volume. The `group_names` parameter, and either the `member_names` or `member_ids` parameters are required and must be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_protection_groups_volumes_post_with_http_info(authorization, x_request_id, group_ids, group_names, member_ids, member_names, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_ids and group_names keyword arguments.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param group_ids: A comma-separated list of group IDs.
        :type group_ids: List[str]
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            group_ids=group_ids,
            group_names=group_names,
            member_ids=member_ids,
            member_names=member_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_ids', 'group_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _fixup_list_type_params(['group_ids', 'group_names', 'member_ids', 'member_names'], kwargs)
        return self._call_api('ProtectionGroupsApi', 'api232_protection_groups_volumes_post_with_http_info', kwargs)

    def get_remote_pods(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        on: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the target name specified. Enter multiple target names in comma-separated format. For example, `targetName01,targetName02`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List remote pods  # noqa: E501
        
        Returns a list of pods that that are on connected arrays but not stretched to this array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_remote_pods_get_with_http_info(authorization, x_request_id, filter, ids, limit, names, offset, on, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param on: Performs the operation on the target name specified. Enter multiple target names
                in comma-separated format. For example, `targetName01,targetName02`.
        :type on: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            on=on,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'on', 'sort'], kwargs)
        return self._call_api('RemotePodsApi', 'api232_remote_pods_get_with_http_info', kwargs)

    def delete_remote_protection_group_snapshots(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        on: Annotated[Optional[StrictStr], Field(description="Performs the operation on the target name specified. For example, `targetName01`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a remote protection group snapshot  # noqa: E501
        
        Deletes a remote protection group snapshot that has been destroyed and is pending eradication. Eradicated remote protection group snapshots cannot be recovered. Remote protection group snapshots are destroyed using the `PATCH` method. The `names` parameter represents the name of the protection group snapshot. The `on` parameter represents the name of the offload target. The `names` and `on` parameters are required and must be used together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_remote_protection_group_snapshots_delete_with_http_info(authorization, x_request_id, ids, names, on, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param on: Performs the operation on the target name specified. For example,
                `targetName01`.
        :type on: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            on=on,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('RemoteProtectionGroupSnapshotsApi', 'api232_remote_protection_group_snapshots_delete_with_http_info', kwargs)

    def get_remote_protection_group_snapshots(
        self,
        sources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        on: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the target name specified. Enter multiple target names in comma-separated format. For example, `targetName01,targetName02`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        source_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source ID specified. Enter multiple source IDs in comma-separated format.")] = None,
        source_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source name specified. Enter multiple source names in comma-separated format. For example, `name01,name02`.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List remote protection group snapshots  # noqa: E501
        
        Displays a list of remote protection group snapshots.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_remote_protection_group_snapshots_get_with_http_info(authorization, x_request_id, destroyed, filter, ids, limit, names, offset, on, sort, source_ids, source_names, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param sources: A list of sources to query for. Overrides source_ids and source_names keyword arguments.
        :type sources: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param on: Performs the operation on the target name specified. Enter multiple target names
                in comma-separated format. For example, `targetName01,targetName02`.
        :type on: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param source_ids: Performs the operation on the source ID specified. Enter multiple source IDs in
                        comma-separated format.
        :type source_ids: List[str]
        :param source_names: Performs the operation on the source name specified. Enter multiple source names
                            in comma-separated format. For example, `name01,name02`.
        :type source_names: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            destroyed=destroyed,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            on=on,
            sort=sort,
            source_ids=source_ids,
            source_names=source_names,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _process_references(sources, ['source_ids', 'source_names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'on', 'sort', 'source_ids', 'source_names'], kwargs)
        return self._call_api('RemoteProtectionGroupSnapshotsApi', 'api232_remote_protection_group_snapshots_get_with_http_info', kwargs)

    def patch_remote_protection_group_snapshots(
        self,
        remote_protection_group_snapshot: 'models.DestroyedPatchPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        on: Annotated[Optional[StrictStr], Field(description="Performs the operation on the target name specified. For example, `targetName01`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify a remote protection group snapshot  # noqa: E501
        
        Modifies a remote protection group snapshot, removing it from the offload target and destroying the snapshot. The `on` parameter represents the name of the offload target. The `ids` or `names` parameter and the `on` parameter are required and must be used together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_remote_protection_group_snapshots_patch_with_http_info(remote_protection_group_snapshot, authorization, x_request_id, ids, names, on, async_req=True)
        >>> result = thread.get()
        
        :param remote_protection_group_snapshot: (required)
        :type remote_protection_group_snapshot: models.DestroyedPatchPost
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param on: Performs the operation on the target name specified. For example,
                `targetName01`.
        :type on: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            remote_protection_group_snapshot=remote_protection_group_snapshot,
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            on=on,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('RemoteProtectionGroupSnapshotsApi', 'api232_remote_protection_group_snapshots_patch_with_http_info', kwargs)

    def post_remote_protection_group_snapshots(
        self,
        sources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_throttle: Annotated[Optional[StrictBool], Field(description="If set to `true`, allows snapshot to fail if array health is not optimal.")] = None,
        apply_retention: Annotated[Optional[StrictBool], Field(description="If `true`, applies the local and remote retention policy to the snapshots.")] = None,
        convert_source_to_baseline: Annotated[Optional[StrictBool], Field(description="Set to `true` to have the snapshot be eradicated when it is no longer baseline on source.")] = None,
        for_replication: Annotated[Optional[StrictBool], Field(description="If `true`, destroys and eradicates the snapshot after 1 hour.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        on: Annotated[Optional[StrictStr], Field(description="Performs the operation on the target name specified. For example, `targetName01`.")] = None,
        replicate: Annotated[Optional[StrictBool], Field(description="If set to `true`, queues up and begins replicating to each allowed target after all earlier replication sessions for the same protection group have been completed to that target. The `replicate` and `replicate_now` parameters cannot be used together.")] = None,
        replicate_now: Annotated[Optional[StrictBool], Field(description="If set to `true`, replicates the snapshots to each allowed target. The `replicate` and `replicate_now` parameters cannot be used together.")] = None,
        source_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source ID specified. Enter multiple source IDs in comma-separated format.")] = None,
        source_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source name specified. Enter multiple source names in comma-separated format. For example, `name01,name02`.")] = None,
        remote_protection_group_snapshot: Optional['models.RemoteProtectionGroupSnapshotPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create remote protection group snapshot  # noqa: E501
        
        Creates remote protection group snapshots.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_remote_protection_group_snapshots_post_with_http_info(authorization, x_request_id, allow_throttle, apply_retention, convert_source_to_baseline, for_replication, ids, names, on, replicate, replicate_now, source_ids, source_names, remote_protection_group_snapshot, async_req=True)
        >>> result = thread.get()
        
        :param sources: A list of sources to query for. Overrides source_ids and source_names keyword arguments.
        :type sources: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_throttle: If set to `true`, allows snapshot to fail if array health is not optimal.
        :type allow_throttle: bool
        :param apply_retention: If `true`, applies the local and remote retention policy to the snapshots.
        :type apply_retention: bool
        :param convert_source_to_baseline: Set to `true` to have the snapshot be eradicated when it is no longer baseline
                                        on source.
        :type convert_source_to_baseline: bool
        :param for_replication: If `true`, destroys and eradicates the snapshot after 1 hour.
        :type for_replication: bool
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param on: Performs the operation on the target name specified. For example,
                `targetName01`.
        :type on: str
        :param replicate: If set to `true`, queues up and begins replicating to each allowed target after
                        all earlier replication sessions for the same protection group have been
                        completed to that target. The `replicate` and `replicate_now` parameters
                        cannot be used together.
        :type replicate: bool
        :param replicate_now: If set to `true`, replicates the snapshots to each allowed target. The
                            `replicate` and `replicate_now` parameters cannot be used together.
        :type replicate_now: bool
        :param source_ids: Performs the operation on the source ID specified. Enter multiple source IDs in
                        comma-separated format.
        :type source_ids: List[str]
        :param source_names: Performs the operation on the source name specified. Enter multiple source names
                            in comma-separated format. For example, `name01,name02`.
        :type source_names: List[str]
        :param remote_protection_group_snapshot:
        :type remote_protection_group_snapshot: RemoteProtectionGroupSnapshotPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            allow_throttle=allow_throttle,
            apply_retention=apply_retention,
            convert_source_to_baseline=convert_source_to_baseline,
            for_replication=for_replication,
            ids=ids,
            names=names,
            on=on,
            replicate=replicate,
            replicate_now=replicate_now,
            source_ids=source_ids,
            source_names=source_names,
            remote_protection_group_snapshot=remote_protection_group_snapshot,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _process_references(sources, ['source_ids', 'source_names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'source_ids', 'source_names'], kwargs)
        return self._call_api('RemoteProtectionGroupSnapshotsApi', 'api232_remote_protection_group_snapshots_post_with_http_info', kwargs)

    def post_remote_protection_group_snapshots_test(
        self,
        sources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_throttle: Annotated[Optional[StrictBool], Field(description="If set to `true`, allows snapshot to fail if array health is not optimal.")] = None,
        apply_retention: Annotated[Optional[StrictBool], Field(description="If `true`, applies the local and remote retention policy to the snapshots.")] = None,
        convert_source_to_baseline: Annotated[Optional[StrictBool], Field(description="Set to `true` to have the snapshot be eradicated when it is no longer baseline on source.")] = None,
        for_replication: Annotated[Optional[StrictBool], Field(description="If `true`, destroys and eradicates the snapshot after 1 hour.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        on: Annotated[Optional[StrictStr], Field(description="Performs the operation on the target name specified. For example, `targetName01`.")] = None,
        replicate: Annotated[Optional[StrictBool], Field(description="If set to `true`, queues up and begins replicating to each allowed target after all earlier replication sessions for the same protection group have been completed to that target. The `replicate` and `replicate_now` parameters cannot be used together.")] = None,
        replicate_now: Annotated[Optional[StrictBool], Field(description="If set to `true`, replicates the snapshots to each allowed target. The `replicate` and `replicate_now` parameters cannot be used together.")] = None,
        source_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source ID specified. Enter multiple source IDs in comma-separated format.")] = None,
        source_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source name specified. Enter multiple source names in comma-separated format. For example, `name01,name02`.")] = None,
        remote_protection_group_snapshot: Optional['models.RemoteProtectionGroupSnapshotPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create an attempt to take remote protection group snapshot  # noqa: E501
        
        Create an attempt to take a remote protection group snapshot without actually taking it, to test if the snapshot can be successfully taken.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_remote_protection_group_snapshots_test_post_with_http_info(authorization, x_request_id, allow_throttle, apply_retention, convert_source_to_baseline, for_replication, ids, names, on, replicate, replicate_now, source_ids, source_names, remote_protection_group_snapshot, async_req=True)
        >>> result = thread.get()
        
        :param sources: A list of sources to query for. Overrides source_ids and source_names keyword arguments.
        :type sources: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_throttle: If set to `true`, allows snapshot to fail if array health is not optimal.
        :type allow_throttle: bool
        :param apply_retention: If `true`, applies the local and remote retention policy to the snapshots.
        :type apply_retention: bool
        :param convert_source_to_baseline: Set to `true` to have the snapshot be eradicated when it is no longer baseline
                                        on source.
        :type convert_source_to_baseline: bool
        :param for_replication: If `true`, destroys and eradicates the snapshot after 1 hour.
        :type for_replication: bool
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param on: Performs the operation on the target name specified. For example,
                `targetName01`.
        :type on: str
        :param replicate: If set to `true`, queues up and begins replicating to each allowed target after
                        all earlier replication sessions for the same protection group have been
                        completed to that target. The `replicate` and `replicate_now` parameters
                        cannot be used together.
        :type replicate: bool
        :param replicate_now: If set to `true`, replicates the snapshots to each allowed target. The
                            `replicate` and `replicate_now` parameters cannot be used together.
        :type replicate_now: bool
        :param source_ids: Performs the operation on the source ID specified. Enter multiple source IDs in
                        comma-separated format.
        :type source_ids: List[str]
        :param source_names: Performs the operation on the source name specified. Enter multiple source names
                            in comma-separated format. For example, `name01,name02`.
        :type source_names: List[str]
        :param remote_protection_group_snapshot:
        :type remote_protection_group_snapshot: RemoteProtectionGroupSnapshotPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            allow_throttle=allow_throttle,
            apply_retention=apply_retention,
            convert_source_to_baseline=convert_source_to_baseline,
            for_replication=for_replication,
            ids=ids,
            names=names,
            on=on,
            replicate=replicate,
            replicate_now=replicate_now,
            source_ids=source_ids,
            source_names=source_names,
            remote_protection_group_snapshot=remote_protection_group_snapshot,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _process_references(sources, ['source_ids', 'source_names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'source_ids', 'source_names'], kwargs)
        return self._call_api('RemoteProtectionGroupSnapshotsApi', 'api232_remote_protection_group_snapshots_test_post_with_http_info', kwargs)

    def get_remote_protection_group_snapshots_transfer(
        self,
        sources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        on: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the target name specified. Enter multiple target names in comma-separated format. For example, `targetName01,targetName02`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        source_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source ID specified. Enter multiple source IDs in comma-separated format.")] = None,
        source_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source name specified. Enter multiple source names in comma-separated format. For example, `name01,name02`.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List remote protection groups with transfer statistics  # noqa: E501
        
        Displays a list of remote protection groups and their transfer statistics.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_remote_protection_group_snapshots_transfer_get_with_http_info(authorization, x_request_id, destroyed, filter, ids, limit, names, offset, on, sort, source_ids, source_names, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param sources: A list of sources to query for. Overrides source_ids and source_names keyword arguments.
        :type sources: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param on: Performs the operation on the target name specified. Enter multiple target names
                in comma-separated format. For example, `targetName01,targetName02`.
        :type on: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param source_ids: Performs the operation on the source ID specified. Enter multiple source IDs in
                        comma-separated format.
        :type source_ids: List[str]
        :param source_names: Performs the operation on the source name specified. Enter multiple source names
                            in comma-separated format. For example, `name01,name02`.
        :type source_names: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            destroyed=destroyed,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            on=on,
            sort=sort,
            source_ids=source_ids,
            source_names=source_names,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _process_references(sources, ['source_ids', 'source_names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'on', 'sort', 'source_ids', 'source_names'], kwargs)
        return self._call_api('RemoteProtectionGroupSnapshotsApi', 'api232_remote_protection_group_snapshots_transfer_get_with_http_info', kwargs)

    def delete_remote_protection_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        on: Annotated[Optional[StrictStr], Field(description="Performs the operation on the target name specified. For example, `targetName01`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Eradicate a remote protection group  # noqa: E501
        
        Eradicates a remote protection group that has been destroyed and is pending eradication. Eradicated remote protection groups cannot be recovered. Remote protection groups are destroyed through the `PATCH` method. The `on` parameter represents the name of the offload target. The `ids` or `names` parameter and the `on` parameter are required and must be used together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_remote_protection_groups_delete_with_http_info(authorization, x_request_id, ids, names, on, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param on: Performs the operation on the target name specified. For example,
                `targetName01`.
        :type on: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            on=on,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('RemoteProtectionGroupsApi', 'api232_remote_protection_groups_delete_with_http_info', kwargs)

    def get_remote_protection_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        on: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the target name specified. Enter multiple target names in comma-separated format. For example, `targetName01,targetName02`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List remote protection groups  # noqa: E501
        
        Returns a list of remote protection groups.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_remote_protection_groups_get_with_http_info(authorization, x_request_id, destroyed, filter, ids, limit, names, offset, on, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param on: Performs the operation on the target name specified. Enter multiple target names
                in comma-separated format. For example, `targetName01,targetName02`.
        :type on: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            destroyed=destroyed,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            on=on,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'on', 'sort'], kwargs)
        return self._call_api('RemoteProtectionGroupsApi', 'api232_remote_protection_groups_get_with_http_info', kwargs)

    def patch_remote_protection_groups(
        self,
        remote_protection_group: 'models.RemoteProtectionGroup',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        on: Annotated[Optional[StrictStr], Field(description="Performs the operation on the target name specified. For example, `targetName01`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Manage a remote protection group  # noqa: E501
        
        Configures the snapshot retention schedule of a remote protection group. Also destroys a remote protection group from the offload target. Before the remote protection group can be destroyed, the offload target must first be removed from the protection group via the source array. The `on` parameter represents the name of the offload target. The `ids` or `names` parameter and the `on` parameter are required and must be used together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_remote_protection_groups_patch_with_http_info(remote_protection_group, authorization, x_request_id, ids, names, on, async_req=True)
        >>> result = thread.get()
        
        :param remote_protection_group: (required)
        :type remote_protection_group: models.RemoteProtectionGroup
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param on: Performs the operation on the target name specified. For example,
                `targetName01`.
        :type on: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            remote_protection_group=remote_protection_group,
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            on=on,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('RemoteProtectionGroupsApi', 'api232_remote_protection_groups_patch_with_http_info', kwargs)

    def delete_remote_volume_snapshots(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        on: Annotated[Optional[StrictStr], Field(description="Performs the operation on the target name specified. For example, `targetName01`.")] = None,
        replication_snapshot: Annotated[Optional[StrictBool], Field(description="If set to `true`, allow destruction/eradication of snapshots in use by replication. If set to `false`, allow destruction/eradication of snapshots not in use by replication. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a remote volume snapshot  # noqa: E501
        
        Deletes (eradicates) a remote volume snapshot that has been destroyed and is pending eradication. Eradicated remote volume snapshots cannot be recovered. Remote volume snapshots are destroyed through the `PATCH` method. The `names` parameter represents the name of the volume snapshot. The `on` parameter represents the name of the offload target. The `names` and `on` parameters are required and must be used together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_remote_volume_snapshots_delete_with_http_info(authorization, x_request_id, names, on, replication_snapshot, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param on: Performs the operation on the target name specified. For example,
                `targetName01`.
        :type on: str
        :param replication_snapshot: If set to `true`, allow destruction/eradication of snapshots in use by
                                    replication. If set to `false`, allow destruction/eradication of
                                    snapshots not in use by replication. If not specified, defaults to
                                    `false`.
        :type replication_snapshot: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            on=on,
            replication_snapshot=replication_snapshot,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('RemoteVolumeSnapshotsApi', 'api232_remote_volume_snapshots_delete_with_http_info', kwargs)

    def get_remote_volume_snapshots(
        self,
        sources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        on: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the target name specified. Enter multiple target names in comma-separated format. For example, `targetName01,targetName02`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        source_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source ID specified. Enter multiple source IDs in comma-separated format.")] = None,
        source_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source name specified. Enter multiple source names in comma-separated format. For example, `name01,name02`.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List remote volume snapshots  # noqa: E501
        
        Displays a list of remote volume snapshots.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_remote_volume_snapshots_get_with_http_info(authorization, x_request_id, destroyed, filter, ids, limit, names, offset, on, sort, source_ids, source_names, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param sources: A list of sources to query for. Overrides source_ids and source_names keyword arguments.
        :type sources: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param on: Performs the operation on the target name specified. Enter multiple target names
                in comma-separated format. For example, `targetName01,targetName02`.
        :type on: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param source_ids: Performs the operation on the source ID specified. Enter multiple source IDs in
                        comma-separated format.
        :type source_ids: List[str]
        :param source_names: Performs the operation on the source name specified. Enter multiple source names
                            in comma-separated format. For example, `name01,name02`.
        :type source_names: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            destroyed=destroyed,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            on=on,
            sort=sort,
            source_ids=source_ids,
            source_names=source_names,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _process_references(sources, ['source_ids', 'source_names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'on', 'sort', 'source_ids', 'source_names'], kwargs)
        return self._call_api('RemoteVolumeSnapshotsApi', 'api232_remote_volume_snapshots_get_with_http_info', kwargs)

    def patch_remote_volume_snapshots(
        self,
        remote_volume_snapshot: 'models.DestroyedPatchPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        on: Annotated[Optional[StrictStr], Field(description="Performs the operation on the target name specified. For example, `targetName01`.")] = None,
        replication_snapshot: Annotated[Optional[StrictBool], Field(description="If set to `true`, allow destruction/eradication of snapshots in use by replication. If set to `false`, allow destruction/eradication of snapshots not in use by replication. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify a remote volume snapshot  # noqa: E501
        
        Modifies a remote volume snapshot by destroying or recovering it from the offload target. The `on` parameter represents the name of the offload target. The `names` parameter and the `on` parameter are required and must be used together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_remote_volume_snapshots_patch_with_http_info(remote_volume_snapshot, authorization, x_request_id, names, on, replication_snapshot, async_req=True)
        >>> result = thread.get()
        
        :param remote_volume_snapshot: (required)
        :type remote_volume_snapshot: models.DestroyedPatchPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param on: Performs the operation on the target name specified. For example,
                `targetName01`.
        :type on: str
        :param replication_snapshot: If set to `true`, allow destruction/eradication of snapshots in use by
                                    replication. If set to `false`, allow destruction/eradication of
                                    snapshots not in use by replication. If not specified, defaults to
                                    `false`.
        :type replication_snapshot: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            remote_volume_snapshot=remote_volume_snapshot,
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            on=on,
            replication_snapshot=replication_snapshot,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('RemoteVolumeSnapshotsApi', 'api232_remote_volume_snapshots_patch_with_http_info', kwargs)

    def post_remote_volume_snapshots(
        self,
        remote_volume_snapshot: 'models.RemoteVolumeSnapshotPost',
        sources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        on: Annotated[Optional[StrictStr], Field(description="Performs the operation on the target name specified. For example, `targetName01`.")] = None,
        source_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source ID specified. Enter multiple source IDs in comma-separated format.")] = None,
        source_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source name specified. Enter multiple source names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a volume snapshot on a connected remote target or offload target  # noqa: E501
        
        Creates a volume snapshot on the specified connected remote target or offload target.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_remote_volume_snapshots_post_with_http_info(remote_volume_snapshot, authorization, x_request_id, on, source_ids, source_names, async_req=True)
        >>> result = thread.get()
        
        :param remote_volume_snapshot: (required)
        :type remote_volume_snapshot: models.RemoteVolumeSnapshotPost
        :param sources: A list of sources to query for. Overrides source_ids and source_names keyword arguments.
        :type sources: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param on: Performs the operation on the target name specified. For example,
                `targetName01`.
        :type on: str
        :param source_ids: Performs the operation on the source ID specified. Enter multiple source IDs in
                        comma-separated format.
        :type source_ids: List[str]
        :param source_names: Performs the operation on the source name specified. Enter multiple source names
                            in comma-separated format. For example, `name01,name02`.
        :type source_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            remote_volume_snapshot=remote_volume_snapshot,
            authorization=authorization,
            x_request_id=x_request_id,
            on=on,
            source_ids=source_ids,
            source_names=source_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(sources, ['source_ids', 'source_names'], kwargs)
        _fixup_list_type_params(['source_ids', 'source_names'], kwargs)
        return self._call_api('RemoteVolumeSnapshotsApi', 'api232_remote_volume_snapshots_post_with_http_info', kwargs)

    def get_remote_volume_snapshots_transfer(
        self,
        sources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        on: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the target name specified. Enter multiple target names in comma-separated format. For example, `targetName01,targetName02`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        source_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source ID specified. Enter multiple source IDs in comma-separated format.")] = None,
        source_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source name specified. Enter multiple source names in comma-separated format. For example, `name01,name02`.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List remote volume snapshots with transfer statistics  # noqa: E501
        
        Returns a list of remote volume snapshots and their transfer statistics.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_remote_volume_snapshots_transfer_get_with_http_info(authorization, x_request_id, destroyed, filter, ids, limit, names, offset, on, sort, source_ids, source_names, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param sources: A list of sources to query for. Overrides source_ids and source_names keyword arguments.
        :type sources: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param on: Performs the operation on the target name specified. Enter multiple target names
                in comma-separated format. For example, `targetName01,targetName02`.
        :type on: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param source_ids: Performs the operation on the source ID specified. Enter multiple source IDs in
                        comma-separated format.
        :type source_ids: List[str]
        :param source_names: Performs the operation on the source name specified. Enter multiple source names
                            in comma-separated format. For example, `name01,name02`.
        :type source_names: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            destroyed=destroyed,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            on=on,
            sort=sort,
            source_ids=source_ids,
            source_names=source_names,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _process_references(sources, ['source_ids', 'source_names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'on', 'sort', 'source_ids', 'source_names'], kwargs)
        return self._call_api('RemoteVolumeSnapshotsApi', 'api232_remote_volume_snapshots_transfer_get_with_http_info', kwargs)

    def delete_sso_saml2_idps(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete SAML2 SSO configurations  # noqa: E501
        
        Deletes SAML2 SSO configurations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_sso_saml2_idps_delete_with_http_info(authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SAML2SSOApi', 'api232_sso_saml2_idps_delete_with_http_info', kwargs)

    def get_sso_saml2_idps(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List SAML2 SSO configurations  # noqa: E501
        
        Displays the SAML2 SSO service provider and identity provider configuration settings in the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_sso_saml2_idps_get_with_http_info(authorization, x_request_id, continuation_token, filter, ids, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SAML2SSOApi', 'api232_sso_saml2_idps_get_with_http_info', kwargs)

    def patch_sso_saml2_idps(
        self,
        idp: 'models.Saml2SsoPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify SAML2 SSO configurations  # noqa: E501
        
        Modifies one or more attributes of SAML2 SSO configurations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_sso_saml2_idps_patch_with_http_info(idp, authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param idp: (required)
        :type idp: models.Saml2SsoPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            idp=idp,
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SAML2SSOApi', 'api232_sso_saml2_idps_patch_with_http_info', kwargs)

    def post_sso_saml2_idps(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="Performs the operation on the unique name specified. For example, `name01`. Enter multiple names in comma-separated format.")],
        idp: 'models.Saml2SsoPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create SAML2 SSO configurations  # noqa: E501
        
        Creates SAML2 SSO configurations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_sso_saml2_idps_post_with_http_info(names, idp, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param names: Performs the operation on the unique name specified. For example, `name01`.
                    Enter multiple names in comma-separated format. (required)
        :type names: List[str]
        :param idp: (required)
        :type idp: models.Saml2SsoPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            idp=idp,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('SAML2SSOApi', 'api232_sso_saml2_idps_post_with_http_info', kwargs)

    def get_sso_saml2_idps_test(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List existing SAML2 SSO configurations  # noqa: E501
        
        Displays the existing SAML2 SSO configurations in the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_sso_saml2_idps_test_get_with_http_info(authorization, x_request_id, continuation_token, filter, ids, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SAML2SSOApi', 'api232_sso_saml2_idps_test_get_with_http_info', kwargs)

    def patch_sso_saml2_idps_test(
        self,
        idp: 'models.Saml2SsoPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify provided SAML2 SSO configurations  # noqa: E501
        
        Modifies the provided SAML2 SSO configurations. If the configurations with the specified `ids` or `names` exist, the provided configurations will overwrite the existing configurations, but will not be persisted in the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_sso_saml2_idps_test_patch_with_http_info(idp, authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param idp: (required)
        :type idp: models.Saml2SsoPost
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            idp=idp,
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SAML2SSOApi', 'api232_sso_saml2_idps_test_patch_with_http_info', kwargs)

    def get_smi_s(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List SMI-S settings  # noqa: E501
        
        Displays the SMI-S settings, including whether SLP and WBEM-HTTPS are enabled.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_smi_s_get_with_http_info(authorization, x_request_id, filter, limit, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('SMISApi', 'api232_smi_s_get_with_http_info', kwargs)

    def patch_smi_s(
        self,
        smi_s: 'models.Smis',
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify SLP and SMI-S  # noqa: E501
        
        Modifies the Service Location Protocol (SLP) and the SMI-S provider, enabling or disabling them.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_smi_s_patch_with_http_info(smi_s, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param smi_s: (required)
        :type smi_s: models.Smis
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            smi_s=smi_s,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('SMISApi', 'api232_smi_s_patch_with_http_info', kwargs)

    def get_smtp_servers(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List SMTP server attributes  # noqa: E501
        
        Displays SMTP server attributes. Values include `user_name`, `password`, `relay_host`, `sender_domain`, and `name`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_smtp_servers_get_with_http_info(authorization, x_request_id, filter, limit, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('SMTPApi', 'api232_smtp_servers_get_with_http_info', kwargs)

    def patch_smtp_servers(
        self,
        smtp: 'models.SmtpServer',
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify SMTP server attributes  # noqa: E501
        
        Modifies SMTP server attributes. Values include `user_name`, `password`, `relay_host`, `sender_domain`, and `name`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_smtp_servers_patch_with_http_info(smtp, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param smtp: (required)
        :type smtp: models.SmtpServer
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            smtp=smtp,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('SMTPApi', 'api232_smtp_servers_patch_with_http_info', kwargs)

    def get_snmp_agents(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List SNMP agent  # noqa: E501
        
        Displays the SNMP agent name and protocol attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_snmp_agents_get_with_http_info(authorization, x_request_id, filter, limit, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('SNMPAgentsApi', 'api232_snmp_agents_get_with_http_info', kwargs)

    def get_snmp_agents_mib(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List SNMP agent MIB text  # noqa: E501
        
        Displays the SNMP MIB text.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_snmp_agents_mib_get_with_http_info(authorization, x_request_id, filter, limit, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('SNMPAgentsApi', 'api232_snmp_agents_mib_get_with_http_info', kwargs)

    def patch_snmp_agents(
        self,
        snmp_agent: 'models.SnmpAgentPatch',
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify SNMP agent  # noqa: E501
        
        Modifies the name or the protocol attributes of the SNMP agent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_snmp_agents_patch_with_http_info(snmp_agent, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param snmp_agent: (required)
        :type snmp_agent: models.SnmpAgentPatch
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            snmp_agent=snmp_agent,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('SNMPAgentsApi', 'api232_snmp_agents_patch_with_http_info', kwargs)

    def delete_snmp_managers(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete SNMP manager  # noqa: E501
        
        Deletes the SNMP manager object and stops communication with specified managers.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_snmp_managers_delete_with_http_info(authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('SNMPManagersApi', 'api232_snmp_managers_delete_with_http_info', kwargs)

    def get_snmp_managers(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List SNMP managers  # noqa: E501
        
        Displays designated SNMP managers and their communication and security attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_snmp_managers_get_with_http_info(authorization, x_request_id, continuation_token, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('SNMPManagersApi', 'api232_snmp_managers_get_with_http_info', kwargs)

    def patch_snmp_managers(
        self,
        snmp_manager: 'models.SnmpManagerPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify SNMP manager  # noqa: E501
        
        Modifies the name or the protocol attributes of the specified SNMP manager.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_snmp_managers_patch_with_http_info(snmp_manager, authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param snmp_manager: (required)
        :type snmp_manager: models.SnmpManagerPatch
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            snmp_manager=snmp_manager,
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('SNMPManagersApi', 'api232_snmp_managers_patch_with_http_info', kwargs)

    def post_snmp_managers(
        self,
        snmp_manager: 'models.SnmpManagerPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create SNMP manager  # noqa: E501
        
        Creates a Purity SNMP manager object that identifies a host (SNMP manager) and specifies the protocol attributes for communicating with it. Once a manager object is created, the transmission of SNMP traps is immediately enabled.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_snmp_managers_post_with_http_info(snmp_manager, authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param snmp_manager: (required)
        :type snmp_manager: models.SnmpManagerPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            snmp_manager=snmp_manager,
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('SNMPManagersApi', 'api232_snmp_managers_post_with_http_info', kwargs)

    def get_snmp_managers_test(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List SNMP manager test results  # noqa: E501
        
        Displays SNMP manager test results (traps or informs).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_snmp_managers_test_get_with_http_info(authorization, x_request_id, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('SNMPManagersApi', 'api232_snmp_managers_test_get_with_http_info', kwargs)

    def get_sessions(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List session data  # noqa: E501
        
        Displays session data for user login events performed in the Purity//FA GUI, CLI, and REST API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_sessions_get_with_http_info(authorization, x_request_id, continuation_token, filter, ids, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SessionsApi', 'api232_sessions_get_with_http_info', kwargs)

    def get_software_bundle(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List software-bundle  # noqa: E501
        
        Displays a list of software bundles.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_software_bundle_get_with_http_info(x_request_id, filter, ids, limit, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            filter=filter,
            ids=ids,
            limit=limit,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids'], kwargs)
        _fixup_list_type_params(['ids', 'sort'], kwargs)
        return self._call_api('SoftwareApi', 'api232_software_bundle_get_with_http_info', kwargs)

    def post_software_bundle(
        self,
        source: 'models.SoftwareBundlePost',
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create software-bundle  # noqa: E501
        
        Creates and initiates a software bundle download.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_software_bundle_post_with_http_info(source, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param source: (required)
        :type source: models.SoftwareBundlePost
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            source=source,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('SoftwareApi', 'api232_software_bundle_post_with_http_info', kwargs)

    def delete_software_check(
        self,
        softwares: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        software_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of software names.")] = None,
        software_versions: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of target software versions.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a software check task  # noqa: E501
        
        Deletes a software check task specified by software name and version. The check task must be queued. If the check task is running or passed/failed then the task cannot be deleted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_software_check_delete_with_http_info(authorization, x_request_id, software_names, software_versions, async_req=True)
        >>> result = thread.get()
        
        :param softwares: A list of softwares to query for. Overrides software_names keyword argument.
        :type softwares: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param software_names: A comma-separated list of software names.
        :type software_names: List[str]
        :param software_versions: A comma-separated list of target software versions.
        :type software_versions: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            software_names=software_names,
            software_versions=software_versions,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(softwares, ['software_names'], kwargs)
        _fixup_list_type_params(['software_names', 'software_versions'], kwargs)
        return self._call_api('SoftwareApi', 'api232_software_check_delete_with_http_info', kwargs)

    def get_software_check(
        self,
        softwares: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        software_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of software names.")] = None,
        software_versions: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of target software versions.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List software check tasks  # noqa: E501
        
        Displays a list of software check tasks.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_software_check_get_with_http_info(authorization, x_request_id, filter, ids, limit, names, offset, software_names, software_versions, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param softwares: A list of softwares to query for. Overrides software_names keyword argument.
        :type softwares: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param software_names: A comma-separated list of software names.
        :type software_names: List[str]
        :param software_versions: A comma-separated list of target software versions.
        :type software_versions: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            software_names=software_names,
            software_versions=software_versions,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _process_references(softwares, ['software_names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'software_names', 'software_versions', 'sort'], kwargs)
        return self._call_api('SoftwareApi', 'api232_software_check_get_with_http_info', kwargs)

    def post_software_check(
        self,
        softwares: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        software_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of software names.")] = None,
        software_versions: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of target software versions.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a software check task  # noqa: E501
        
        Creates a software check task. If there are no previously queued or running software check tasks, the new task immediately starts. Otherwise, it is queued and starts once all previously queued or running software check tasks finish. To create a task, use a software name and version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_software_check_post_with_http_info(authorization, x_request_id, software_names, software_versions, async_req=True)
        >>> result = thread.get()
        
        :param softwares: A list of softwares to query for. Overrides software_names keyword argument.
        :type softwares: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param software_names: A comma-separated list of software names.
        :type software_names: List[str]
        :param software_versions: A comma-separated list of target software versions.
        :type software_versions: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            software_names=software_names,
            software_versions=software_versions,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(softwares, ['software_names'], kwargs)
        _fixup_list_type_params(['software_names', 'software_versions'], kwargs)
        return self._call_api('SoftwareApi', 'api232_software_check_post_with_http_info', kwargs)

    def delete_software(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        software_versions: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of target software versions.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a software package  # noqa: E501
        
        Deletes a software package specified by software name and version. A software package being used for an installation can be deleted if the installation is `downloading`, `downloaded`, `aborted`, or `finished`. If the software package is currently `downloading`, the download will be cancelled.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_software_delete_with_http_info(authorization, x_request_id, names, software_versions, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param software_versions: A comma-separated list of target software versions.
        :type software_versions: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            software_versions=software_versions,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'software_versions'], kwargs)
        return self._call_api('SoftwareApi', 'api232_software_delete_with_http_info', kwargs)

    def get_software(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        versions: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of versions.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List software packages  # noqa: E501
        
        Displays a list of available software packages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_software_get_with_http_info(authorization, x_request_id, filter, ids, limit, names, offset, sort, total_item_count, versions, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param versions: A comma-separated list of versions.
        :type versions: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            versions=versions,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort', 'versions'], kwargs)
        return self._call_api('SoftwareApi', 'api232_software_get_with_http_info', kwargs)

    def get_software_installation_steps(
        self,
        software_installations: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        software_installation_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of software installation IDs.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List software upgrade steps  # noqa: E501
        
        Displays a list of currently running and completed software upgrade steps.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_software_installation_steps_get_with_http_info(authorization, x_request_id, continuation_token, filter, ids, limit, names, offset, software_installation_ids, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param software_installations: A list of software_installations to query for. Overrides software_installation_ids keyword argument.
        :type software_installations: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param software_installation_ids: A comma-separated list of software installation IDs.
        :type software_installation_ids: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            software_installation_ids=software_installation_ids,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _process_references(software_installations, ['software_installation_ids'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'software_installation_ids', 'sort'], kwargs)
        return self._call_api('SoftwareApi', 'api232_software_installation_steps_get_with_http_info', kwargs)

    def get_software_installations(
        self,
        softwares: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        software_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of software IDs.")] = None,
        software_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of software names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List software upgrades  # noqa: E501
        
        Displays a list of software upgrades, including currently running and past upgrades.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_software_installations_get_with_http_info(authorization, x_request_id, continuation_token, filter, ids, limit, names, offset, software_ids, software_names, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param softwares: A list of softwares to query for. Overrides software_ids and software_names keyword arguments.
        :type softwares: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param software_ids: A comma-separated list of software IDs.
        :type software_ids: List[str]
        :param software_names: A comma-separated list of software names.
        :type software_names: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            software_ids=software_ids,
            software_names=software_names,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _process_references(softwares, ['software_ids', 'software_names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'software_ids', 'software_names', 'sort'], kwargs)
        return self._call_api('SoftwareApi', 'api232_software_installations_get_with_http_info', kwargs)

    def patch_software_installations(
        self,
        command: Annotated[StrictStr, Field(..., description="A user command that interacts with the upgrade. Commands may only be issued when the upgrade is paused. Valid values are `continue`, `retry`, and `abort`. The `continue` command continues a `paused` upgrade. The `retry` command retries the previous step. The `abort` command aborts the upgrade.")],
        current_step_id: Annotated[StrictStr, Field(..., description="The current step `id` of the installation.")],
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        software_installations: Optional['models.SoftwareInstallationPatch'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify software upgrade  # noqa: E501
        
        Modifies a software upgrade by continuing, retrying, or aborting it. All `override_checks` are updated before the command being issued if `add_override_checks` is present. The `override_checks` parameter is valid when `command` is `continue` or `retry`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_software_installations_patch_with_http_info(command, current_step_id, authorization, x_request_id, software_installations, async_req=True)
        >>> result = thread.get()
        
        :param command: A user command that interacts with the upgrade. Commands may only be issued when
                        the upgrade is paused. Valid values are `continue`, `retry`, and `abort`.
                        The `continue` command continues a `paused` upgrade. The `retry` command
                        retries the previous step. The `abort` command aborts the upgrade.
                        (required)
        :type command: str
        :param current_step_id: The current step `id` of the installation. (required)
        :type current_step_id: str
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param software_installations:
        :type software_installations: SoftwareInstallationPatch
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            command=command,
            current_step_id=current_step_id,
            authorization=authorization,
            x_request_id=x_request_id,
            software_installations=software_installations,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('SoftwareApi', 'api232_software_installations_patch_with_http_info', kwargs)

    def post_software_installations(
        self,
        software_ids: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of software IDs.")],
        software_installations: 'models.SoftwareInstallationPost',
        softwares: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a software upgrade  # noqa: E501
        
        Creates and initiates a software upgrade.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_software_installations_post_with_http_info(software_ids, software_installations, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param software_ids: A comma-separated list of software IDs. (required)
        :type software_ids: List[str]
        :param software_installations: (required)
        :type software_installations: models.SoftwareInstallationPost
        :param softwares: A list of softwares to query for. Overrides software_ids keyword argument.
        :type softwares: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            software_ids=software_ids,
            software_installations=software_installations,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(softwares, ['software_ids'], kwargs)
        _fixup_list_type_params(['software_ids'], kwargs)
        return self._call_api('SoftwareApi', 'api232_software_installations_post_with_http_info', kwargs)

    def get_software_patches_catalog(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List available software patches  # noqa: E501
        
        Displays a list of available software patches.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_software_patches_catalog_get_with_http_info(authorization, x_request_id, filter, limit, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('SoftwareApi', 'api232_software_patches_catalog_get_with_http_info', kwargs)

    def get_software_patches(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List software patches  # noqa: E501
        
        Displays a list of software patches.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_software_patches_get_with_http_info(authorization, x_request_id, filter, ids, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SoftwareApi', 'api232_software_patches_get_with_http_info', kwargs)

    def post_software_patches(
        self,
        name: Annotated[StrictStr, Field(..., description="Name of software patch to install")],
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_ha_reduction: Annotated[Optional[StrictBool], Field(description="If Software Patch has ha_reduction_required set to true, `allow_ha_reduction` must be set to `true` for Software Patch installation.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a software patch  # noqa: E501
        
        Creates software patch download and installation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_software_patches_post_with_http_info(name, authorization, x_request_id, allow_ha_reduction, async_req=True)
        >>> result = thread.get()
        
        :param name: Name of software patch to install (required)
        :type name: str
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_ha_reduction: If Software Patch has ha_reduction_required set to true, `allow_ha_reduction`
                                must be set to `true` for Software Patch installation.
        :type allow_ha_reduction: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            name=name,
            authorization=authorization,
            x_request_id=x_request_id,
            allow_ha_reduction=allow_ha_reduction,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('SoftwareApi', 'api232_software_patches_post_with_http_info', kwargs)

    def post_software(
        self,
        software: 'models.SoftwarePost',
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a software package  # noqa: E501
        
        Creates a software package download.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_software_post_with_http_info(software, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param software: (required)
        :type software: models.SoftwarePost
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            software=software,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('SoftwareApi', 'api232_software_post_with_http_info', kwargs)

    def get_software_versions(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List software versions  # noqa: E501
        
        Displays a list of software versions.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_software_versions_get_with_http_info(authorization, x_request_id, filter, limit, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('SoftwareApi', 'api232_software_versions_get_with_http_info', kwargs)

    def delete_subnets(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete subnet  # noqa: E501
        
        Deletes subnets. A subnet can only be deleted if it has no interfaces. Interfaces must be removed by using the `network-interfaces` endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_subnets_delete_with_http_info(authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('SubnetsApi', 'api232_subnets_delete_with_http_info', kwargs)

    def get_subnets(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List subnets  # noqa: E501
        
        Displays a list of subnets with statuses and attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_subnets_get_with_http_info(authorization, x_request_id, continuation_token, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('SubnetsApi', 'api232_subnets_get_with_http_info', kwargs)

    def patch_subnets(
        self,
        subnet: 'models.SubnetPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify subnet  # noqa: E501
        
        Modifies one or more specified subnet properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_subnets_patch_with_http_info(subnet, authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param subnet: (required)
        :type subnet: models.SubnetPatch
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            subnet=subnet,
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('SubnetsApi', 'api232_subnets_patch_with_http_info', kwargs)

    def post_subnets(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="Performs the operation on the unique name specified. For example, `name01`. Enter multiple names in comma-separated format.")],
        subnet: 'models.SubnetPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create subnet  # noqa: E501
        
        Creates a subnet with the specified parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_subnets_post_with_http_info(names, subnet, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param names: Performs the operation on the unique name specified. For example, `name01`.
                    Enter multiple names in comma-separated format. (required)
        :type names: List[str]
        :param subnet: (required)
        :type subnet: models.SubnetPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            subnet=subnet,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('SubnetsApi', 'api232_subnets_post_with_http_info', kwargs)

    def get_subscription_assets(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List subscription assets  # noqa: E501
        
        Displays information about subscription assets.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_subscription_assets_get_with_http_info(authorization, x_request_id, continuation_token, filter, ids, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SubscriptionAssetsApi', 'api232_subscription_assets_get_with_http_info', kwargs)

    def get_subscriptions(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List subscriptions  # noqa: E501
        
        Displays information about subscriptions.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_subscriptions_get_with_http_info(authorization, x_request_id, continuation_token, filter, ids, limit, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids'], kwargs)
        _fixup_list_type_params(['ids', 'sort'], kwargs)
        return self._call_api('SubscriptionsApi', 'api232_subscriptions_get_with_http_info', kwargs)

    def get_support(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List connection paths  # noqa: E501
        
        Displays connection paths between the current array and each connected array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_support_get_with_http_info(authorization, x_request_id, continuation_token, filter, limit, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('SupportApi', 'api232_support_get_with_http_info', kwargs)

    def patch_support(
        self,
        support: 'models.SupportPatch',
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create connection path  # noqa: E501
        
        Creates a connection path from the array to another array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_support_patch_with_http_info(support, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param support: (required)
        :type support: models.SupportPatch
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            support=support,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('SupportApi', 'api232_support_patch_with_http_info', kwargs)

    def get_support_test(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        test_type: Annotated[Optional[StrictStr], Field(description="Specifies the type of test. Valid values are `all`, `phonehome`, and `remote-assist`. If not specified, defaults to `all`.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List Pure Storage Support connection data  # noqa: E501
        
        Displays information about whether the array can connect to Pure Storage Support by establishing a secure shell or secure HTTP connection and verifies that messages can be exchanged.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_support_test_get_with_http_info(authorization, x_request_id, filter, limit, offset, sort, test_type, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param test_type: Specifies the type of test. Valid values are `all`, `phonehome`, and `remote-
                        assist`. If not specified, defaults to `all`.
        :type test_type: str
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            test_type=test_type,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('SupportApi', 'api232_support_test_get_with_http_info', kwargs)

    def delete_syslog_servers(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete syslog server  # noqa: E501
        
        Deletes a configured syslog server and stop forwarding syslog messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_syslog_servers_delete_with_http_info(authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('SyslogApi', 'api232_syslog_servers_delete_with_http_info', kwargs)

    def get_syslog_servers(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List syslog servers  # noqa: E501
        
        Displays a list of configured syslog servers.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_syslog_servers_get_with_http_info(authorization, x_request_id, continuation_token, filter, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('SyslogApi', 'api232_syslog_servers_get_with_http_info', kwargs)

    def patch_syslog_servers(
        self,
        syslog_server: 'models.SyslogServer',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify syslog server  # noqa: E501
        
        Modifies the URI of a configured syslog server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_syslog_servers_patch_with_http_info(syslog_server, authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param syslog_server: (required)
        :type syslog_server: models.SyslogServer
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            syslog_server=syslog_server,
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('SyslogApi', 'api232_syslog_servers_patch_with_http_info', kwargs)

    def post_syslog_servers(
        self,
        syslog_server: 'models.SyslogServer',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create syslog server  # noqa: E501
        
        Creates a new syslog server. Transmission of syslog messages is enabled immediately.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_syslog_servers_post_with_http_info(syslog_server, authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param syslog_server: (required)
        :type syslog_server: models.SyslogServer
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            syslog_server=syslog_server,
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('SyslogApi', 'api232_syslog_servers_post_with_http_info', kwargs)

    def get_syslog_servers_settings(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List syslog settings  # noqa: E501
        
        Displays syslog settings. Values include `continuation_token`, `items`, `more_items_remaining`, and `total_item_count`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_syslog_servers_settings_get_with_http_info(authorization, x_request_id, filter, limit, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('SyslogApi', 'api232_syslog_servers_settings_get_with_http_info', kwargs)

    def patch_syslog_servers_settings(
        self,
        syslog_server_settings: 'models.SyslogServerSettings',
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify syslog settings  # noqa: E501
        
        Modifies syslog settings. Values include `continuation_token`, `items`, `more_items_remaining`, and `total_item_count`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_syslog_servers_settings_patch_with_http_info(syslog_server_settings, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param syslog_server_settings: (required)
        :type syslog_server_settings: models.SyslogServerSettings
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            syslog_server_settings=syslog_server_settings,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('SyslogApi', 'api232_syslog_servers_settings_patch_with_http_info', kwargs)

    def get_syslog_servers_test(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List syslog server test results  # noqa: E501
        
        Displays syslog server test results, which indicate whether the syslog is working and configured correctly.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_syslog_servers_test_get_with_http_info(authorization, x_request_id, filter, limit, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('SyslogApi', 'api232_syslog_servers_test_get_with_http_info', kwargs)

    def delete_vchosts_certificates(
        self,
        vchosts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificates: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        certificate_names: Annotated[Optional[conlist(StrictStr)], Field(description="The names of one or more certificates. Enter multiple names in comma-separated format. For example, `cert01,cert02`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        vchost_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique vchost IDs specified. Enter multiple vchost IDs in a comma-separated format. For example, `vchostid01,vchostid02`.")] = None,
        vchost_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique vchost name specified. Enter multiple names in a comma-separated format. For example, `vchost01,vchost02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a vchost certificate  # noqa: E501
        
        Deletes an existing vchost certificate. The `ids` query parameter alone, or the `certificate_names` query parameter together with one of `vchost_names` or `vchost_ids`, is required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_vchosts_certificates_delete_with_http_info(authorization, x_request_id, certificate_names, ids, vchost_ids, vchost_names, async_req=True)
        >>> result = thread.get()
        
        :param vchosts: A list of vchosts to query for. Overrides vchost_ids and vchost_names keyword arguments.
        :type vchosts: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param certificates: A list of certificates to query for. Overrides certificate_names keyword argument.
        :type certificates: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param certificate_names: The names of one or more certificates. Enter multiple names in comma-separated
                                format. For example, `cert01,cert02`.
        :type certificate_names: List[str]
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param vchost_ids: Performs the operation on the unique vchost IDs specified. Enter multiple vchost
                        IDs in a comma-separated format. For example, `vchostid01,vchostid02`.
        :type vchost_ids: List[str]
        :param vchost_names: Performs the operation on the unique vchost name specified. Enter multiple names
                            in a comma-separated format. For example, `vchost01,vchost02`.
        :type vchost_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            certificate_names=certificate_names,
            ids=ids,
            vchost_ids=vchost_ids,
            vchost_names=vchost_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(certificates, ['certificate_names'], kwargs)
        _process_references(references, ['ids'], kwargs)
        _process_references(vchosts, ['vchost_ids', 'vchost_names'], kwargs)
        _fixup_list_type_params(['certificate_names', 'ids', 'vchost_ids', 'vchost_names'], kwargs)
        return self._call_api('VchostsApi', 'api232_vchosts_certificates_delete_with_http_info', kwargs)

    def get_vchosts_certificates(
        self,
        vchosts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificates: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        certificate_names: Annotated[Optional[conlist(StrictStr)], Field(description="The names of one or more certificates. Enter multiple names in comma-separated format. For example, `cert01,cert02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        vchost_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique vchost IDs specified. Enter multiple vchost IDs in a comma-separated format. For example, `vchostid01,vchostid02`.")] = None,
        vchost_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique vchost name specified. Enter multiple names in a comma-separated format. For example, `vchost01,vchost02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List vchost certificates  # noqa: E501
        
        Displays certificates that are attached to configured vchosts on at least one endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_vchosts_certificates_get_with_http_info(authorization, x_request_id, certificate_names, continuation_token, filter, ids, limit, offset, sort, total_item_count, vchost_ids, vchost_names, async_req=True)
        >>> result = thread.get()
        
        :param vchosts: A list of vchosts to query for. Overrides vchost_ids and vchost_names keyword arguments.
        :type vchosts: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param certificates: A list of certificates to query for. Overrides certificate_names keyword argument.
        :type certificates: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param certificate_names: The names of one or more certificates. Enter multiple names in comma-separated
                                format. For example, `cert01,cert02`.
        :type certificate_names: List[str]
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param vchost_ids: Performs the operation on the unique vchost IDs specified. Enter multiple vchost
                        IDs in a comma-separated format. For example, `vchostid01,vchostid02`.
        :type vchost_ids: List[str]
        :param vchost_names: Performs the operation on the unique vchost name specified. Enter multiple names
                            in a comma-separated format. For example, `vchost01,vchost02`.
        :type vchost_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            certificate_names=certificate_names,
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            vchost_ids=vchost_ids,
            vchost_names=vchost_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(certificates, ['certificate_names'], kwargs)
        _process_references(references, ['ids'], kwargs)
        _process_references(vchosts, ['vchost_ids', 'vchost_names'], kwargs)
        _fixup_list_type_params(['certificate_names', 'ids', 'sort', 'vchost_ids', 'vchost_names'], kwargs)
        return self._call_api('VchostsApi', 'api232_vchosts_certificates_get_with_http_info', kwargs)

    def patch_vchosts_certificates(
        self,
        certificate: 'models.VchostCertificatePatch',
        vchosts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificates: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        certificate_names: Annotated[Optional[conlist(StrictStr)], Field(description="The names of one or more certificates. Enter multiple names in comma-separated format. For example, `cert01,cert02`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        vchost_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique vchost IDs specified. Enter multiple vchost IDs in a comma-separated format. For example, `vchostid01,vchostid02`.")] = None,
        vchost_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique vchost name specified. Enter multiple names in a comma-separated format. For example, `vchost01,vchost02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify a vchost certificate  # noqa: E501
        
        Modifies an existing vchost certificate. The `ids` query parameter alone, or the `certificate_names` query parameter together with one of `vchost_names` or `vchost_ids`, is required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_vchosts_certificates_patch_with_http_info(certificate, authorization, x_request_id, certificate_names, ids, vchost_ids, vchost_names, async_req=True)
        >>> result = thread.get()
        
        :param certificate: (required)
        :type certificate: models.VchostCertificatePatch
        :param vchosts: A list of vchosts to query for. Overrides vchost_ids and vchost_names keyword arguments.
        :type vchosts: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param certificates: A list of certificates to query for. Overrides certificate_names keyword argument.
        :type certificates: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param certificate_names: The names of one or more certificates. Enter multiple names in comma-separated
                                format. For example, `cert01,cert02`.
        :type certificate_names: List[str]
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param vchost_ids: Performs the operation on the unique vchost IDs specified. Enter multiple vchost
                        IDs in a comma-separated format. For example, `vchostid01,vchostid02`.
        :type vchost_ids: List[str]
        :param vchost_names: Performs the operation on the unique vchost name specified. Enter multiple names
                            in a comma-separated format. For example, `vchost01,vchost02`.
        :type vchost_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            certificate=certificate,
            authorization=authorization,
            x_request_id=x_request_id,
            certificate_names=certificate_names,
            ids=ids,
            vchost_ids=vchost_ids,
            vchost_names=vchost_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(certificates, ['certificate_names'], kwargs)
        _process_references(references, ['ids'], kwargs)
        _process_references(vchosts, ['vchost_ids', 'vchost_names'], kwargs)
        _fixup_list_type_params(['certificate_names', 'ids', 'vchost_ids', 'vchost_names'], kwargs)
        return self._call_api('VchostsApi', 'api232_vchosts_certificates_patch_with_http_info', kwargs)

    def post_vchosts_certificates(
        self,
        certificate: 'models.VchostCertificatePost',
        vchosts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        vchost_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique vchost IDs specified. Enter multiple vchost IDs in a comma-separated format. For example, `vchostid01,vchostid02`.")] = None,
        vchost_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique vchost name specified. Enter multiple names in a comma-separated format. For example, `vchost01,vchost02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a vchost certificate  # noqa: E501
        
        Creates an association between a certificate and vchost on one or more endpoints. The `vchost_names` or `vchost_ids` query parameter is required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_vchosts_certificates_post_with_http_info(certificate, authorization, x_request_id, vchost_ids, vchost_names, async_req=True)
        >>> result = thread.get()
        
        :param certificate: (required)
        :type certificate: models.VchostCertificatePost
        :param vchosts: A list of vchosts to query for. Overrides vchost_ids and vchost_names keyword arguments.
        :type vchosts: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param vchost_ids: Performs the operation on the unique vchost IDs specified. Enter multiple vchost
                        IDs in a comma-separated format. For example, `vchostid01,vchostid02`.
        :type vchost_ids: List[str]
        :param vchost_names: Performs the operation on the unique vchost name specified. Enter multiple names
                            in a comma-separated format. For example, `vchost01,vchost02`.
        :type vchost_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            certificate=certificate,
            authorization=authorization,
            x_request_id=x_request_id,
            vchost_ids=vchost_ids,
            vchost_names=vchost_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(vchosts, ['vchost_ids', 'vchost_names'], kwargs)
        _fixup_list_type_params(['vchost_ids', 'vchost_names'], kwargs)
        return self._call_api('VchostsApi', 'api232_vchosts_certificates_post_with_http_info', kwargs)

    def delete_vchosts(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a vchost  # noqa: E501
        
        Deletes an existing vchost. The `names` or `ids` query parameter is required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_vchosts_delete_with_http_info(authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('VchostsApi', 'api232_vchosts_delete_with_http_info', kwargs)

    def delete_vchosts_endpoints(
        self,
        vchosts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        endpoints: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique endpoints specified. Enter multiple endpoints in a comma-separated format.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        vchost_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique vchost IDs specified. Enter multiple vchost IDs in a comma-separated format. For example, `vchostid01,vchostid02`.")] = None,
        vchost_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique vchost name specified. Enter multiple names in a comma-separated format. For example, `vchost01,vchost02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a vchost endpoint  # noqa: E501
        
        Deletes an existing vchost endpoint The `ids` query parameter alone, or the `endpoints` query parameter together with one of `vchost_names` or `vchost_ids`, is required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_vchosts_endpoints_delete_with_http_info(authorization, x_request_id, endpoints, ids, vchost_ids, vchost_names, async_req=True)
        >>> result = thread.get()
        
        :param vchosts: A list of vchosts to query for. Overrides vchost_ids and vchost_names keyword arguments.
        :type vchosts: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param endpoints: Performs the operation on the unique endpoints specified. Enter multiple
                        endpoints in a comma-separated format.
        :type endpoints: List[str]
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param vchost_ids: Performs the operation on the unique vchost IDs specified. Enter multiple vchost
                        IDs in a comma-separated format. For example, `vchostid01,vchostid02`.
        :type vchost_ids: List[str]
        :param vchost_names: Performs the operation on the unique vchost name specified. Enter multiple names
                            in a comma-separated format. For example, `vchost01,vchost02`.
        :type vchost_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            endpoints=endpoints,
            ids=ids,
            vchost_ids=vchost_ids,
            vchost_names=vchost_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids'], kwargs)
        _process_references(vchosts, ['vchost_ids', 'vchost_names'], kwargs)
        _fixup_list_type_params(['endpoints', 'ids', 'vchost_ids', 'vchost_names'], kwargs)
        return self._call_api('VchostsApi', 'api232_vchosts_endpoints_delete_with_http_info', kwargs)

    def get_vchosts_endpoints(
        self,
        vchosts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        endpoints: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique endpoints specified. Enter multiple endpoints in a comma-separated format.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        vchost_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique vchost IDs specified. Enter multiple vchost IDs in a comma-separated format. For example, `vchostid01,vchostid02`.")] = None,
        vchost_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique vchost name specified. Enter multiple names in a comma-separated format. For example, `vchost01,vchost02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List vchost endpoints  # noqa: E501
        
        Displays a list of vchost endpoints with their associated vchosts and certificates.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_vchosts_endpoints_get_with_http_info(authorization, x_request_id, continuation_token, endpoints, filter, ids, limit, offset, sort, total_item_count, vchost_ids, vchost_names, async_req=True)
        >>> result = thread.get()
        
        :param vchosts: A list of vchosts to query for. Overrides vchost_ids and vchost_names keyword arguments.
        :type vchosts: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param endpoints: Performs the operation on the unique endpoints specified. Enter multiple
                        endpoints in a comma-separated format.
        :type endpoints: List[str]
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param vchost_ids: Performs the operation on the unique vchost IDs specified. Enter multiple vchost
                        IDs in a comma-separated format. For example, `vchostid01,vchostid02`.
        :type vchost_ids: List[str]
        :param vchost_names: Performs the operation on the unique vchost name specified. Enter multiple names
                            in a comma-separated format. For example, `vchost01,vchost02`.
        :type vchost_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            endpoints=endpoints,
            filter=filter,
            ids=ids,
            limit=limit,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            vchost_ids=vchost_ids,
            vchost_names=vchost_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids'], kwargs)
        _process_references(vchosts, ['vchost_ids', 'vchost_names'], kwargs)
        _fixup_list_type_params(['endpoints', 'ids', 'sort', 'vchost_ids', 'vchost_names'], kwargs)
        return self._call_api('VchostsApi', 'api232_vchosts_endpoints_get_with_http_info', kwargs)

    def patch_vchosts_endpoints(
        self,
        endpoint: 'models.VchostEndpointPatch',
        vchosts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        endpoints: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique endpoints specified. Enter multiple endpoints in a comma-separated format.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        vchost_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique vchost IDs specified. Enter multiple vchost IDs in a comma-separated format. For example, `vchostid01,vchostid02`.")] = None,
        vchost_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique vchost name specified. Enter multiple names in a comma-separated format. For example, `vchost01,vchost02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify a vchost endpoint  # noqa: E501
        
        Modifies an existing vchost endpoint. The `ids` query parameter alone, or the `endpoints` query parameter together with one of `vchost_names` or `vchost_ids`, is required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_vchosts_endpoints_patch_with_http_info(endpoint, authorization, x_request_id, endpoints, ids, vchost_ids, vchost_names, async_req=True)
        >>> result = thread.get()
        
        :param endpoint: (required)
        :type endpoint: models.VchostEndpointPatch
        :param vchosts: A list of vchosts to query for. Overrides vchost_ids and vchost_names keyword arguments.
        :type vchosts: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param endpoints: Performs the operation on the unique endpoints specified. Enter multiple
                        endpoints in a comma-separated format.
        :type endpoints: List[str]
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param vchost_ids: Performs the operation on the unique vchost IDs specified. Enter multiple vchost
                        IDs in a comma-separated format. For example, `vchostid01,vchostid02`.
        :type vchost_ids: List[str]
        :param vchost_names: Performs the operation on the unique vchost name specified. Enter multiple names
                            in a comma-separated format. For example, `vchost01,vchost02`.
        :type vchost_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            endpoint=endpoint,
            authorization=authorization,
            x_request_id=x_request_id,
            endpoints=endpoints,
            ids=ids,
            vchost_ids=vchost_ids,
            vchost_names=vchost_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids'], kwargs)
        _process_references(vchosts, ['vchost_ids', 'vchost_names'], kwargs)
        _fixup_list_type_params(['endpoints', 'ids', 'vchost_ids', 'vchost_names'], kwargs)
        return self._call_api('VchostsApi', 'api232_vchosts_endpoints_patch_with_http_info', kwargs)

    def post_vchosts_endpoints(
        self,
        endpoint: 'models.VchostEndpointPost',
        vchosts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        vchost_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique vchost IDs specified. Enter multiple vchost IDs in a comma-separated format. For example, `vchostid01,vchostid02`.")] = None,
        vchost_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique vchost name specified. Enter multiple names in a comma-separated format. For example, `vchost01,vchost02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a vchost endpoint  # noqa: E501
        
        Creates a vchost endpoint. Either the `vchost_names` or `vchost_ids` query parameter is required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_vchosts_endpoints_post_with_http_info(endpoint, authorization, x_request_id, vchost_ids, vchost_names, async_req=True)
        >>> result = thread.get()
        
        :param endpoint: (required)
        :type endpoint: models.VchostEndpointPost
        :param vchosts: A list of vchosts to query for. Overrides vchost_ids and vchost_names keyword arguments.
        :type vchosts: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param vchost_ids: Performs the operation on the unique vchost IDs specified. Enter multiple vchost
                        IDs in a comma-separated format. For example, `vchostid01,vchostid02`.
        :type vchost_ids: List[str]
        :param vchost_names: Performs the operation on the unique vchost name specified. Enter multiple names
                            in a comma-separated format. For example, `vchost01,vchost02`.
        :type vchost_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            endpoint=endpoint,
            authorization=authorization,
            x_request_id=x_request_id,
            vchost_ids=vchost_ids,
            vchost_names=vchost_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(vchosts, ['vchost_ids', 'vchost_names'], kwargs)
        _fixup_list_type_params(['vchost_ids', 'vchost_names'], kwargs)
        return self._call_api('VchostsApi', 'api232_vchosts_endpoints_post_with_http_info', kwargs)

    def get_vchosts(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List vchosts  # noqa: E501
        
        Displays a list of vchosts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_vchosts_get_with_http_info(authorization, x_request_id, continuation_token, filter, ids, limit, names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('VchostsApi', 'api232_vchosts_get_with_http_info', kwargs)

    def patch_vchosts(
        self,
        vchost: 'models.VchostPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify a vchost  # noqa: E501
        
        Modifies an existing vchost. The `names` or `ids` query parameter is required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_vchosts_patch_with_http_info(vchost, authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param vchost: (required)
        :type vchost: models.VchostPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            vchost=vchost,
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('VchostsApi', 'api232_vchosts_patch_with_http_info', kwargs)

    def post_vchosts(
        self,
        vchost: 'models.VchostPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a vchost  # noqa: E501
        
        Creates a vchost. The `names` query parameter is required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_vchosts_post_with_http_info(vchost, authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param vchost: (required)
        :type vchost: models.VchostPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            vchost=vchost,
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('VchostsApi', 'api232_vchosts_post_with_http_info', kwargs)

    def get_virtual_machine_snapshots(
        self,
        vms: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        vm_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique virtual machine IDs specified. Enter multiple resource IDs in a comma-separated format.")] = None,
        vm_type: Annotated[Optional[StrictStr], Field(description="The type of virtual machine. The only valid value is `vvol`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List Virtual Machine Snapshots  # noqa: E501
        
        Displays a list of virtual machine snapshots, including those pending eradication. If `vm_type` is `vvol`, the `recovery_context` in the response will represent a protection group snapshot containing the virtual machine. This must be used as the `source` in the `POST /virtual-machine` method when recovering or overwriting a virtual machine from a snapshot.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_virtual_machine_snapshots_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, limit, offset, sort, total_item_count, vm_ids, vm_type, async_req=True)
        >>> result = thread.get()
        
        :param vms: A list of vms to query for. Overrides vm_ids keyword argument.
        :type vms: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param vm_ids: Performs the operation on the unique virtual machine IDs specified. Enter
                    multiple resource IDs in a comma-separated format.
        :type vm_ids: List[str]
        :param vm_type: The type of virtual machine. The only valid value is `vvol`.
        :type vm_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            vm_ids=vm_ids,
            vm_type=vm_type,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(vms, ['vm_ids'], kwargs)
        _fixup_list_type_params(['sort', 'vm_ids'], kwargs)
        return self._call_api('VirtualMachinesApi', 'api232_virtual_machine_snapshots_get_with_http_info', kwargs)

    def get_virtual_machines(
        self,
        vms: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        vm_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique virtual machine IDs specified. Enter multiple virtual machine IDs in a comma-separated format.")] = None,
        vm_type: Annotated[Optional[StrictStr], Field(description="The type of virtual machine. The only valid value is `vvol`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List Virtual Machines  # noqa: E501
        
        Displays a list of virtual machines, including those pending eradication. If `vm_type` is `vvol`, the `recovery_context` in the response will represent the most recent snapshot of the config vVol. This must be used as the `source` in the `PATCH` method when recovering a virtual machine from the destroyed state.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_virtual_machines_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, limit, offset, sort, total_item_count, vm_ids, vm_type, async_req=True)
        >>> result = thread.get()
        
        :param vms: A list of vms to query for. Overrides vm_ids keyword argument.
        :type vms: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param vm_ids: Performs the operation on the unique virtual machine IDs specified. Enter
                    multiple virtual machine IDs in a comma-separated format.
        :type vm_ids: List[str]
        :param vm_type: The type of virtual machine. The only valid value is `vvol`.
        :type vm_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            vm_ids=vm_ids,
            vm_type=vm_type,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(vms, ['vm_ids'], kwargs)
        _fixup_list_type_params(['sort', 'vm_ids'], kwargs)
        return self._call_api('VirtualMachinesApi', 'api232_virtual_machines_get_with_http_info', kwargs)

    def patch_virtual_machines(
        self,
        virtual_machine: 'models.VirtualMachinePost',
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Update a virtual machine  # noqa: E501
        
        Updates a virtual machine, recovering it from the destroyed state. If the virtual machine is of type `vvol`, the `source` property of the request body must be a `recovery_context` value retrieved from the `GET /virtual-machines` endpoint. If recovering the virtual machine will cause a conflict with an existing virtual machine, the operation will fail.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_virtual_machines_patch_with_http_info(virtual_machine, authorization, x_request_id, async_req=True)
        >>> result = thread.get()
        
        :param virtual_machine: (required)
        :type virtual_machine: models.VirtualMachinePost
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            virtual_machine=virtual_machine,
            authorization=authorization,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('VirtualMachinesApi', 'api232_virtual_machines_patch_with_http_info', kwargs)

    def post_virtual_machines(
        self,
        virtual_machine: 'models.VirtualMachinePost',
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        overwrite: Annotated[Optional[StrictBool], Field(description="If set to `true`, overwrites an existing object during an object copy operation. If set to `false` or not set at all and the target name is an existing object, the copy operation fails. Required if the `source` body parameter is set and the source overwrites an existing object during the copy operation.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a virtual machine  # noqa: E501
        
        Creates one or more virtual machines from a protection group snapshot. If the virtual machine is of type `vvol`, the `source` property of the request body must be a `recovery_context` value retrieved from the `GET /virtual-machine-snapshots` endpoint. If `overwrite` is specified, an existing virtual machine will have its volumes overwritten by the snapshot. Otherwise, a new virtual machine will be created from the snapshot. If creating the new virtual machine will cause a conflict with an existing virtual machine, the operation will fail.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_virtual_machines_post_with_http_info(virtual_machine, authorization, x_request_id, overwrite, async_req=True)
        >>> result = thread.get()
        
        :param virtual_machine: (required)
        :type virtual_machine: models.VirtualMachinePost
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param overwrite: If set to `true`, overwrites an existing object during an object copy operation.
                        If set to `false` or not set at all and the target name is an existing
                        object, the copy operation fails. Required if the `source` body parameter is
                        set and the source overwrites an existing object during the copy operation.
        :type overwrite: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            virtual_machine=virtual_machine,
            authorization=authorization,
            x_request_id=x_request_id,
            overwrite=overwrite,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('VirtualMachinesApi', 'api232_virtual_machines_post_with_http_info', kwargs)

    def delete_volume_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        eradicate_contents: Annotated[Optional[StrictBool], Field(description="Set to `true` to eradicate contents (e.g., volumes, protection groups, snapshots) and containers (e.g., pods, volume groups). This enables you to eradicate containers with contents.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a volume group  # noqa: E501
        
        Deletes a volume group that has been destroyed and is pending eradication. Eradicated volume groups cannot be recovered. Volume groups are destroyed through the PATCH method. The `ids` or `names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volume_groups_delete_with_http_info(authorization, x_request_id, eradicate_contents, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param eradicate_contents: Set to `true` to eradicate contents (e.g., volumes, protection groups,
                                snapshots) and containers (e.g., pods, volume groups). This enables you to
                                eradicate containers with contents.
        :type eradicate_contents: bool
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            eradicate_contents=eradicate_contents,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('VolumeGroupsApi', 'api232_volume_groups_delete_with_http_info', kwargs)

    def get_volume_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List volume groups  # noqa: E501
        
        Displays a list of volume groups, including those pending eradication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volume_groups_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, ids, limit, names, offset, sort, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('VolumeGroupsApi', 'api232_volume_groups_get_with_http_info', kwargs)

    def patch_volume_groups(
        self,
        volume_group: 'models.VolumeGroupPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        destroy_contents: Annotated[Optional[StrictBool], Field(description="Set to `true` to destroy contents (e.g., volumes, protection groups, snapshots) and containers (e.g., pods, volume groups). This enables you to destroy containers with contents.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify a volume group  # noqa: E501
        
        Modifies a volume group. You can rename, destroy, recover, or set QoS limits for a volume group. To rename a volume group, set `name` to the new name. To destroy a volume group, set `destroyed=true`. To recover a volume group that has been destroyed and is pending eradication, set `destroyed=false`. Sets the bandwidth and IOPs limits of a volume group through the respective `bandwidth_limit` and `iops_limit` parameter. The `ids` or `names` parameter is required, but they cannot be set together. Sets the priority adjustment for a volume group using the `priority_adjustment_operator` and `priority_adjustment_value` fields.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volume_groups_patch_with_http_info(volume_group, authorization, x_request_id, destroy_contents, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param volume_group: (required)
        :type volume_group: models.VolumeGroupPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param destroy_contents: Set to `true` to destroy contents (e.g., volumes, protection groups, snapshots)
                                and containers (e.g., pods, volume groups). This enables you to destroy
                                containers with contents.
        :type destroy_contents: bool
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            volume_group=volume_group,
            authorization=authorization,
            x_request_id=x_request_id,
            destroy_contents=destroy_contents,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('VolumeGroupsApi', 'api232_volume_groups_patch_with_http_info', kwargs)

    def get_volume_groups_performance(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The number of milliseconds between samples of historical data. For array-wide performance metrics (`/arrays/performance` endpoint), valid values are `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For performance metrics on storage objects (`<object name>/performance` endpoint), such as volumes, valid values are `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For space metrics, (`<object name>/space` endpoint), valid values are `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). Include the `start_time` parameter to display the performance data starting at the specified start time. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. Include the `end_time` parameter to display the performance data until the specified end time. If `end_time`is not specified, the end time will default to the current time. If the `resolution` parameter is not specified but either the `start_time` or `end_time` parameter is, then `resolution` will default to the lowest valid resolution.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List volume group performance data  # noqa: E501
        
        Returns real-time and historical performance data, real-time latency data, and average I/O sizes for each volume group and and as a total of all volume groups across the entire array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volume_groups_performance_get_with_http_info(authorization, x_request_id, destroyed, end_time, filter, ids, limit, names, offset, resolution, sort, start_time, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param end_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type end_time: int
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param resolution: The number of milliseconds between samples of historical data. For array-wide
                        performance metrics (`/arrays/performance` endpoint), valid values are
                        `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30
                        minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24
                        hours). For performance metrics on storage objects (`<object
                        name>/performance` endpoint), such as volumes, valid values are `30000` (30
                        seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours),
                        `28800000` (8 hours), and `86400000` (24 hours). For space metrics,
                        (`<object name>/space` endpoint), valid values are `300000` (5 minutes),
                        `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and
                        `86400000` (24 hours). Include the `start_time` parameter to display the
                        performance data starting at the specified start time. If `start_time` is
                        not specified, the start time will default to one resolution before the end
                        time, meaning that the most recent sample of performance data will be
                        displayed. Include the `end_time` parameter to display the performance data
                        until the specified end time. If `end_time`is not specified, the end time
                        will default to the current time. If the `resolution` parameter is not
                        specified but either the `start_time` or `end_time` parameter is, then
                        `resolution` will default to the lowest valid resolution.
        :type resolution: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param start_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type start_time: int
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            destroyed=destroyed,
            end_time=end_time,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('VolumeGroupsApi', 'api232_volume_groups_performance_get_with_http_info', kwargs)

    def post_volume_groups(
        self,
        volume_group: 'models.VolumeGroupPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a volume group  # noqa: E501
        
        Creates a volume group. The volume group itself does not contain any meaningful content; instead, it acts as a container that is used to organize volumes. Once a volume group has been created, volumes can be created inside the volume group or moved into and out of the volume group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volume_groups_post_with_http_info(volume_group, authorization, x_request_id, names, async_req=True)
        >>> result = thread.get()
        
        :param volume_group: (required)
        :type volume_group: models.VolumeGroupPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            volume_group=volume_group,
            authorization=authorization,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('VolumeGroupsApi', 'api232_volume_groups_post_with_http_info', kwargs)

    def get_volume_groups_space(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The number of milliseconds between samples of historical data. For array-wide performance metrics (`/arrays/performance` endpoint), valid values are `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For performance metrics on storage objects (`<object name>/performance` endpoint), such as volumes, valid values are `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For space metrics, (`<object name>/space` endpoint), valid values are `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). Include the `start_time` parameter to display the performance data starting at the specified start time. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. Include the `end_time` parameter to display the performance data until the specified end time. If `end_time`is not specified, the end time will default to the current time. If the `resolution` parameter is not specified but either the `start_time` or `end_time` parameter is, then `resolution` will default to the lowest valid resolution.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List volume group space information  # noqa: E501
        
        Displays the provisioned size and physical storage consumption data for each volume group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volume_groups_space_get_with_http_info(authorization, x_request_id, destroyed, end_time, filter, ids, limit, names, offset, resolution, sort, start_time, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param end_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type end_time: int
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param resolution: The number of milliseconds between samples of historical data. For array-wide
                        performance metrics (`/arrays/performance` endpoint), valid values are
                        `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30
                        minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24
                        hours). For performance metrics on storage objects (`<object
                        name>/performance` endpoint), such as volumes, valid values are `30000` (30
                        seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours),
                        `28800000` (8 hours), and `86400000` (24 hours). For space metrics,
                        (`<object name>/space` endpoint), valid values are `300000` (5 minutes),
                        `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and
                        `86400000` (24 hours). Include the `start_time` parameter to display the
                        performance data starting at the specified start time. If `start_time` is
                        not specified, the start time will default to one resolution before the end
                        time, meaning that the most recent sample of performance data will be
                        displayed. Include the `end_time` parameter to display the performance data
                        until the specified end time. If `end_time`is not specified, the end time
                        will default to the current time. If the `resolution` parameter is not
                        specified but either the `start_time` or `end_time` parameter is, then
                        `resolution` will default to the lowest valid resolution.
        :type resolution: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param start_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type start_time: int
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            destroyed=destroyed,
            end_time=end_time,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('VolumeGroupsApi', 'api232_volume_groups_space_get_with_http_info', kwargs)

    def get_volume_groups_volumes(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List volume groups with volumes  # noqa: E501
        
        Returns a list of volume groups that contain volumes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volume_groups_volumes_get_with_http_info(authorization, x_request_id, continuation_token, filter, group_ids, group_names, limit, member_ids, member_names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_ids and group_names keyword arguments.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param group_ids: A comma-separated list of group IDs.
        :type group_ids: List[str]
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            group_ids=group_ids,
            group_names=group_names,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_ids', 'group_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _fixup_list_type_params(['group_ids', 'group_names', 'member_ids', 'member_names', 'sort'], kwargs)
        return self._call_api('VolumeGroupsApi', 'api232_volume_groups_volumes_get_with_http_info', kwargs)

    def delete_volume_snapshots(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        replication_snapshot: Annotated[Optional[StrictBool], Field(description="If set to `true`, allow destruction/eradication of snapshots in use by replication. If set to `false`, allow destruction/eradication of snapshots not in use by replication. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a volume snapshot  # noqa: E501
        
        Deletes a volume snapshot that has been destroyed and is pending eradication. Eradicated volume snapshots cannot be recovered. Volume snapshots are destroyed by using the `PATCH` method. The `ids` or `names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volume_snapshots_delete_with_http_info(authorization, x_request_id, ids, names, replication_snapshot, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param replication_snapshot: If set to `true`, allow destruction/eradication of snapshots in use by
                                    replication. If set to `false`, allow destruction/eradication of
                                    snapshots not in use by replication. If not specified, defaults to
                                    `false`.
        :type replication_snapshot: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            replication_snapshot=replication_snapshot,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('VolumeSnapshotsApi', 'api232_volume_snapshots_delete_with_http_info', kwargs)

    def get_volume_snapshots(
        self,
        sources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        source_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source ID specified. Enter multiple source IDs in comma-separated format.")] = None,
        source_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source name specified. Enter multiple source names in comma-separated format. For example, `name01,name02`.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List volume snapshots  # noqa: E501
        
        Displays a list of volume snapshots, including those pending eradication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volume_snapshots_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, ids, limit, names, offset, sort, source_ids, source_names, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param sources: A list of sources to query for. Overrides source_ids and source_names keyword arguments.
        :type sources: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param source_ids: Performs the operation on the source ID specified. Enter multiple source IDs in
                        comma-separated format.
        :type source_ids: List[str]
        :param source_names: Performs the operation on the source name specified. Enter multiple source names
                            in comma-separated format. For example, `name01,name02`.
        :type source_names: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            source_ids=source_ids,
            source_names=source_names,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _process_references(sources, ['source_ids', 'source_names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort', 'source_ids', 'source_names'], kwargs)
        return self._call_api('VolumeSnapshotsApi', 'api232_volume_snapshots_get_with_http_info', kwargs)

    def patch_volume_snapshots(
        self,
        volume_snapshot: 'models.VolumeSnapshotPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        replication_snapshot: Annotated[Optional[StrictBool], Field(description="If set to `true`, allow destruction/eradication of snapshots in use by replication. If set to `false`, allow destruction/eradication of snapshots not in use by replication. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify a volume snapshot  # noqa: E501
        
        Modifies a volume snapshot by renaming, destroying, or recovering it. To rename the suffix of a volume snapshot, set `name` to the new suffix name. To recover a volume snapshot that has been destroyed and is pending eradication, set `destroyed=true`. The `ids` or `names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volume_snapshots_patch_with_http_info(volume_snapshot, authorization, x_request_id, ids, names, replication_snapshot, async_req=True)
        >>> result = thread.get()
        
        :param volume_snapshot: (required)
        :type volume_snapshot: models.VolumeSnapshotPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param replication_snapshot: If set to `true`, allow destruction/eradication of snapshots in use by
                                    replication. If set to `false`, allow destruction/eradication of
                                    snapshots not in use by replication. If not specified, defaults to
                                    `false`.
        :type replication_snapshot: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            volume_snapshot=volume_snapshot,
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            replication_snapshot=replication_snapshot,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('VolumeSnapshotsApi', 'api232_volume_snapshots_patch_with_http_info', kwargs)

    def post_volume_snapshots(
        self,
        volume_snapshot: 'models.VolumeSnapshotPost',
        sources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_throttle: Annotated[Optional[StrictBool], Field(description="If set to `true`, allows snapshot to fail if array health is not optimal.")] = None,
        on: Annotated[Optional[StrictStr], Field(description="Performs the operation on the target name specified. For example, `targetName01`.")] = None,
        source_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source ID specified. Enter multiple source IDs in comma-separated format.")] = None,
        source_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source name specified. Enter multiple source names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a volume snapshot  # noqa: E501
        
        Creates a point-in-time snapshot of the contents of a volume. The `source_ids` or `source_names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volume_snapshots_post_with_http_info(volume_snapshot, authorization, x_request_id, allow_throttle, on, source_ids, source_names, async_req=True)
        >>> result = thread.get()
        
        :param volume_snapshot: (required)
        :type volume_snapshot: models.VolumeSnapshotPost
        :param sources: A list of sources to query for. Overrides source_ids and source_names keyword arguments.
        :type sources: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_throttle: If set to `true`, allows snapshot to fail if array health is not optimal.
        :type allow_throttle: bool
        :param on: Performs the operation on the target name specified. For example,
                `targetName01`.
        :type on: str
        :param source_ids: Performs the operation on the source ID specified. Enter multiple source IDs in
                        comma-separated format.
        :type source_ids: List[str]
        :param source_names: Performs the operation on the source name specified. Enter multiple source names
                            in comma-separated format. For example, `name01,name02`.
        :type source_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            volume_snapshot=volume_snapshot,
            authorization=authorization,
            x_request_id=x_request_id,
            allow_throttle=allow_throttle,
            on=on,
            source_ids=source_ids,
            source_names=source_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(sources, ['source_ids', 'source_names'], kwargs)
        _fixup_list_type_params(['source_ids', 'source_names'], kwargs)
        return self._call_api('VolumeSnapshotsApi', 'api232_volume_snapshots_post_with_http_info', kwargs)

    def put_volume_snapshots_tags_batch(
        self,
        tag: Annotated[conlist('models.Tag', max_items=30, min_items=1, unique_items=True), Field(..., description="A list of tags to be created or modified.")],
        resources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        resource_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. The `resource_ids` or `resource_names` parameter is required, but they cannot be set together.")] = None,
        resource_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. The `resource_ids` or `resource_names` parameter is required, but they cannot be set together.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Update tags  # noqa: E501
        
        Updates tags.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volume_snapshots_tags_batch_put_with_http_info(tag, authorization, x_request_id, resource_ids, resource_names, async_req=True)
        >>> result = thread.get()
        
        :param tag: A list of tags to be created or modified. (required)
        :type tag: List[models.Tag]
        :param resources: A list of resources to query for. Overrides resource_ids and resource_names keyword arguments.
        :type resources: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param resource_ids: A comma-separated list of resource IDs. The `resource_ids` or `resource_names`
                            parameter is required, but they cannot be set together.
        :type resource_ids: List[str]
        :param resource_names: A comma-separated list of resource names. The `resource_ids` or `resource_names`
                            parameter is required, but they cannot be set together.
        :type resource_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            tag=tag,
            authorization=authorization,
            x_request_id=x_request_id,
            resource_ids=resource_ids,
            resource_names=resource_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(resources, ['resource_ids', 'resource_names'], kwargs)
        _fixup_list_type_params(['tag', 'resource_ids', 'resource_names'], kwargs)
        return self._call_api('VolumeSnapshotsApi', 'api232_volume_snapshots_tags_batch_put_with_http_info', kwargs)

    def delete_volume_snapshots_tags(
        self,
        resources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        keys: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of tag keys.")] = None,
        namespaces: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of namespaces. Only one namespace is allowed per delete request.")] = None,
        resource_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. The `resource_ids` or `resource_names` parameter is required, but they cannot be set together.")] = None,
        resource_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. The `resource_ids` or `resource_names` parameter is required, but they cannot be set together.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete tags  # noqa: E501
        
        Deletes specified tags.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volume_snapshots_tags_delete_with_http_info(authorization, x_request_id, keys, namespaces, resource_ids, resource_names, async_req=True)
        >>> result = thread.get()
        
        :param resources: A list of resources to query for. Overrides resource_ids and resource_names keyword arguments.
        :type resources: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param keys: A comma-separated list of tag keys.
        :type keys: List[str]
        :param namespaces: A comma-separated list of namespaces. Only one namespace is allowed per delete
                        request.
        :type namespaces: List[str]
        :param resource_ids: A comma-separated list of resource IDs. The `resource_ids` or `resource_names`
                            parameter is required, but they cannot be set together.
        :type resource_ids: List[str]
        :param resource_names: A comma-separated list of resource names. The `resource_ids` or `resource_names`
                            parameter is required, but they cannot be set together.
        :type resource_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            keys=keys,
            namespaces=namespaces,
            resource_ids=resource_ids,
            resource_names=resource_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(resources, ['resource_ids', 'resource_names'], kwargs)
        _fixup_list_type_params(['keys', 'namespaces', 'resource_ids', 'resource_names'], kwargs)
        return self._call_api('VolumeSnapshotsApi', 'api232_volume_snapshots_tags_delete_with_http_info', kwargs)

    def get_volume_snapshots_tags(
        self,
        resources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        namespaces: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of namespaces.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        resource_destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns only objects from destroyed resources. Returns an error if the name of a live resource is specified in the `resource_names` query parameter. If set to `false`, returns only objects from live resources. Returns an error if the name of a destroyed resource is specified in the `resource_names` query parameter.")] = None,
        resource_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. The `resource_ids` or `resource_names` parameter is required, but they cannot be set together.")] = None,
        resource_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. The `resource_ids` or `resource_names` parameter is required, but they cannot be set together.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List tags  # noqa: E501
        
        Displays the list of tags.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volume_snapshots_tags_get_with_http_info(authorization, x_request_id, continuation_token, filter, limit, namespaces, offset, resource_destroyed, resource_ids, resource_names, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param resources: A list of resources to query for. Overrides resource_ids and resource_names keyword arguments.
        :type resources: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param namespaces: A comma-separated list of namespaces.
        :type namespaces: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param resource_destroyed: If set to `true`, returns only objects from destroyed resources. Returns an
                                error if the name of a live resource is specified in the `resource_names`
                                query parameter. If set to `false`, returns only objects from live
                                resources. Returns an error if the name of a destroyed resource is
                                specified in the `resource_names` query parameter.
        :type resource_destroyed: bool
        :param resource_ids: A comma-separated list of resource IDs. The `resource_ids` or `resource_names`
                            parameter is required, but they cannot be set together.
        :type resource_ids: List[str]
        :param resource_names: A comma-separated list of resource names. The `resource_ids` or `resource_names`
                            parameter is required, but they cannot be set together.
        :type resource_names: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            namespaces=namespaces,
            offset=offset,
            resource_destroyed=resource_destroyed,
            resource_ids=resource_ids,
            resource_names=resource_names,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(resources, ['resource_ids', 'resource_names'], kwargs)
        _fixup_list_type_params(['namespaces', 'resource_ids', 'resource_names', 'sort'], kwargs)
        return self._call_api('VolumeSnapshotsApi', 'api232_volume_snapshots_tags_get_with_http_info', kwargs)

    def post_volume_snapshots_test(
        self,
        volume_snapshot: 'models.VolumeSnapshotPost',
        sources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_throttle: Annotated[Optional[StrictBool], Field(description="If set to `true`, allows snapshot to fail if array health is not optimal.")] = None,
        on: Annotated[Optional[StrictStr], Field(description="Performs the operation on the target name specified. For example, `targetName01`.")] = None,
        source_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source ID specified. Enter multiple source IDs in comma-separated format.")] = None,
        source_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source name specified. Enter multiple source names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create the volume snapshot path  # noqa: E501
        
        Creates the volume snapshot path without actually taking a volume snapshot.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volume_snapshots_test_post_with_http_info(volume_snapshot, authorization, x_request_id, allow_throttle, on, source_ids, source_names, async_req=True)
        >>> result = thread.get()
        
        :param volume_snapshot: (required)
        :type volume_snapshot: models.VolumeSnapshotPost
        :param sources: A list of sources to query for. Overrides source_ids and source_names keyword arguments.
        :type sources: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_throttle: If set to `true`, allows snapshot to fail if array health is not optimal.
        :type allow_throttle: bool
        :param on: Performs the operation on the target name specified. For example,
                `targetName01`.
        :type on: str
        :param source_ids: Performs the operation on the source ID specified. Enter multiple source IDs in
                        comma-separated format.
        :type source_ids: List[str]
        :param source_names: Performs the operation on the source name specified. Enter multiple source names
                            in comma-separated format. For example, `name01,name02`.
        :type source_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            volume_snapshot=volume_snapshot,
            authorization=authorization,
            x_request_id=x_request_id,
            allow_throttle=allow_throttle,
            on=on,
            source_ids=source_ids,
            source_names=source_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(sources, ['source_ids', 'source_names'], kwargs)
        _fixup_list_type_params(['source_ids', 'source_names'], kwargs)
        return self._call_api('VolumeSnapshotsApi', 'api232_volume_snapshots_test_post_with_http_info', kwargs)

    def get_volume_snapshots_transfer(
        self,
        sources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        source_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source ID specified. Enter multiple source IDs in comma-separated format.")] = None,
        source_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the source name specified. Enter multiple source names in comma-separated format. For example, `name01,name02`.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List volume snapshots with transfer statistics  # noqa: E501
        
        Displays a list of volume snapshots and their transfer statistics.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volume_snapshots_transfer_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, ids, limit, names, offset, sort, source_ids, source_names, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param sources: A list of sources to query for. Overrides source_ids and source_names keyword arguments.
        :type sources: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param source_ids: Performs the operation on the source ID specified. Enter multiple source IDs in
                        comma-separated format.
        :type source_ids: List[str]
        :param source_names: Performs the operation on the source name specified. Enter multiple source names
                            in comma-separated format. For example, `name01,name02`.
        :type source_names: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            source_ids=source_ids,
            source_names=source_names,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _process_references(sources, ['source_ids', 'source_names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort', 'source_ids', 'source_names'], kwargs)
        return self._call_api('VolumeSnapshotsApi', 'api232_volume_snapshots_transfer_get_with_http_info', kwargs)

    def post_volumes_batch(
        self,
        volume: Annotated[conlist('models.VolumeBatchPost'), Field(..., description="A list of volumes to be created or copied.")],
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_throttle: Annotated[Optional[StrictBool], Field(description="If set to `true`, allows operation to fail if array health is not optimal.")] = None,
        overwrite: Annotated[Optional[StrictBool], Field(description="If set to `true`, overwrites an existing object during an object copy operation. If set to `false` or not set at all and the target name is an existing object, the copy operation fails. Required if the `source` body parameter is set and the source overwrites an existing object during the copy operation.")] = None,
        with_default_protection: Annotated[Optional[StrictBool], Field(description="If specified as `true`, the initial protection of the newly created volumes will be the union of the container default protection configuration and `add_to_protection_group_names`. If specified as `false`, the default protection of the container will not be applied automatically. The initial protection of the newly created volumes will be configured by `add_to_protection_group_names`. If not specified, defaults to `true`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create or copy volumes and upsert tags  # noqa: E501
        
        Creates or copies virtual storage volumes of different sizes in different vgroups and upserts tags.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volumes_batch_post_with_http_info(volume, authorization, x_request_id, allow_throttle, overwrite, with_default_protection, async_req=True)
        >>> result = thread.get()
        
        :param volume: A list of volumes to be created or copied. (required)
        :type volume: List[models.VolumeBatchPost]
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_throttle: If set to `true`, allows operation to fail if array health is not optimal.
        :type allow_throttle: bool
        :param overwrite: If set to `true`, overwrites an existing object during an object copy operation.
                        If set to `false` or not set at all and the target name is an existing
                        object, the copy operation fails. Required if the `source` body parameter is
                        set and the source overwrites an existing object during the copy operation.
        :type overwrite: bool
        :param with_default_protection: If specified as `true`, the initial protection of the newly created volumes will
                                        be the union of the container default protection configuration and
                                        `add_to_protection_group_names`. If specified as `false`, the default
                                        protection of the container will not be applied automatically. The
                                        initial protection of the newly created volumes will be configured by
                                        `add_to_protection_group_names`. If not specified, defaults to `true`.
        :type with_default_protection: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            volume=volume,
            authorization=authorization,
            x_request_id=x_request_id,
            allow_throttle=allow_throttle,
            overwrite=overwrite,
            with_default_protection=with_default_protection,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params(['volume'], kwargs)
        return self._call_api('VolumesApi', 'api232_volumes_batch_post_with_http_info', kwargs)

    def delete_volumes(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a volume  # noqa: E501
        
        Deletes a volume that has been destroyed and is pending eradication. Eradicated volumes cannot be recovered. Volumes are destroyed using the `PATCH` method. The `ids` or `names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volumes_delete_with_http_info(authorization, x_request_id, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('VolumesApi', 'api232_volumes_delete_with_http_info', kwargs)

    def get_volumes_diff(
        self,
        block_size: Annotated[StrictInt, Field(..., description="Granularity at which to compare, in bytes. Must be a multiple of 512.")],
        segment_length: Annotated[StrictInt, Field(..., description="Length of the segment, in bytes, to compare.")],
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        base_id: Annotated[Optional[StrictStr], Field(description="ID of the volume or volume snapshot that the diff comparison is based on. If a base volume or volume snapshot is not specified, all mapped blocks for the volume or volume snapshot are displayed. The `base_name` or `base_id` parameter is required, but they cannot be set together.")] = None,
        base_name: Annotated[Optional[StrictStr], Field(description="Name of the volume or volume snapshot that the diff comparison is based on. If a base volume or volume snapshot is not specified, all mapped blocks for the volume or volume snapshot are displayed. The `base_name` or `base_id` parameter is required, but they cannot be set together.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        next_allocated_block_hint: Annotated[Optional[StrictBool], Field(description="If set to `true`, appends offset of the next allocated block in bytes for the volume specified in `names` or `ids` to the output `items`. `base_name` or `base_id` must not be specified if this is set to `true`. If not specified, defaults to `false`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        segment_offset: Annotated[Optional[StrictInt], Field(description="Absolute offset, in bytes, of the segment to compare. Must be a multiple of block_size.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List volume diffs  # noqa: E501
        
        Displays block differences for the specified volumes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volumes_diff_get_with_http_info(block_size, segment_length, authorization, x_request_id, base_id, base_name, filter, ids, limit, names, next_allocated_block_hint, offset, segment_offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param block_size: Granularity at which to compare, in bytes. Must be a multiple of 512. (required)
        :type block_size: int
        :param segment_length: Length of the segment, in bytes, to compare. (required)
        :type segment_length: int
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param base_id: ID of the volume or volume snapshot that the diff comparison is based on. If a
                        base volume or volume snapshot is not specified, all mapped blocks for the
                        volume or volume snapshot are displayed. The `base_name` or `base_id`
                        parameter is required, but they cannot be set together.
        :type base_id: str
        :param base_name: Name of the volume or volume snapshot that the diff comparison is based on. If a
                        base volume or volume snapshot is not specified, all mapped blocks for the
                        volume or volume snapshot are displayed. The `base_name` or `base_id`
                        parameter is required, but they cannot be set together.
        :type base_name: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param next_allocated_block_hint: If set to `true`, appends offset of the next allocated block in bytes for the
                                        volume specified in `names` or `ids` to the output `items`. `base_name`
                                        or `base_id` must not be specified if this is set to `true`. If not
                                        specified, defaults to `false`.
        :type next_allocated_block_hint: bool
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param segment_offset: Absolute offset, in bytes, of the segment to compare. Must be a multiple of
                            block_size.
        :type segment_offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            block_size=block_size,
            segment_length=segment_length,
            authorization=authorization,
            x_request_id=x_request_id,
            base_id=base_id,
            base_name=base_name,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            next_allocated_block_hint=next_allocated_block_hint,
            offset=offset,
            segment_offset=segment_offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('VolumesApi', 'api232_volumes_diff_get_with_http_info', kwargs)

    def get_volumes(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List volumes  # noqa: E501
        
        Displays a list of volumes, including those pending eradication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volumes_get_with_http_info(authorization, x_request_id, continuation_token, destroyed, filter, ids, limit, names, offset, sort, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('VolumesApi', 'api232_volumes_get_with_http_info', kwargs)

    def patch_volumes(
        self,
        volume: 'models.VolumePatch',
        remove_from_protection_groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        add_to_protection_groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        add_to_protection_group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="The volumes will be added to the specified protection groups along with creation or movement across pods and array. When a volume is moved, the specified protection groups must be in the target pod or array. Enter multiple ids in comma-separated format.")] = None,
        add_to_protection_group_names: Annotated[Optional[conlist(StrictStr)], Field(description="The volumes will be added to the specified protection groups along with creation or movement across pods and array. When a volume is moved, the specified protection groups must be in the target pod or array. Enter multiple names in a comma-separated format.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        remove_from_protection_group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="The volumes will be removed from the specified protection groups in the source pod or array along with the move. This can only be used when moving volumes across pods and arrays and must include all protection groups that the volumes are members of before the move. Enter multiple ids in a comma-separated format.")] = None,
        remove_from_protection_group_names: Annotated[Optional[conlist(StrictStr)], Field(description="The volumes will be removed from the specified protection groups in the source pod or array along with the move. This can only be used when moving volumes across pods and arrays and must include all protection groups that the volumes are members of before the move. Enter multiple names in a comma-separated format.")] = None,
        truncate: Annotated[Optional[StrictBool], Field(description="If set to `true`, reduces the size of a volume during a volume resize operation. When a volume is truncated, Purity automatically takes an undo snapshot, providing a 24-hour window during which the previous contents can be retrieved. After truncating a volume, its provisioned size can be subsequently increased, but the data in truncated sectors cannot be retrieved. If set to `false` or not set at all and the volume is being reduced in size, the volume copy operation fails. Required if the `provisioned` parameter is set to a volume size that is smaller than the original size.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify a volume  # noqa: E501
        
        Modifies a volume by renaming, destroying, or resizing it. To rename a volume, set `name` to the new name. To destroy a volume, set `destroyed=true`. To recover a volume that has been destroyed and is pending eradication, set `destroyed=false`. Set the bandwidth and IOPs limits of a volume through the respective `bandwidth_limit` and `iops_limit` parameter. This moves the volume into a pod or volume group through the respective `pod` or `volume_group` parameter. The `ids` or `names` parameter is required, but they cannot be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volumes_patch_with_http_info(volume, authorization, x_request_id, add_to_protection_group_ids, add_to_protection_group_names, ids, names, remove_from_protection_group_ids, remove_from_protection_group_names, truncate, async_req=True)
        >>> result = thread.get()
        
        :param volume: (required)
        :type volume: models.VolumePatch
        :param remove_from_protection_groups: A list of remove_from_protection_groups to query for. Overrides remove_from_protection_group_ids and remove_from_protection_group_names keyword arguments.
        :type remove_from_protection_groups: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param add_to_protection_groups: A list of add_to_protection_groups to query for. Overrides add_to_protection_group_ids and add_to_protection_group_names keyword arguments.
        :type add_to_protection_groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param add_to_protection_group_ids: The volumes will be added to the specified protection groups along with creation
                                            or movement across pods and array. When a volume is moved, the
                                            specified protection groups must be in the target pod or array. Enter
                                            multiple ids in comma-separated format.
        :type add_to_protection_group_ids: List[str]
        :param add_to_protection_group_names: The volumes will be added to the specified protection groups along with creation
                                            or movement across pods and array. When a volume is moved, the
                                            specified protection groups must be in the target pod or array. Enter
                                            multiple names in a comma-separated format.
        :type add_to_protection_group_names: List[str]
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param remove_from_protection_group_ids: The volumes will be removed from the specified protection groups in the source
                                                pod or array along with the move. This can only be used when moving
                                                volumes across pods and arrays and must include all protection groups
                                                that the volumes are members of before the move. Enter multiple ids in
                                                a comma-separated format.
        :type remove_from_protection_group_ids: List[str]
        :param remove_from_protection_group_names: The volumes will be removed from the specified protection groups in the source
                                                pod or array along with the move. This can only be used when moving
                                                volumes across pods and arrays and must include all protection groups
                                                that the volumes are members of before the move. Enter multiple names
                                                in a comma-separated format.
        :type remove_from_protection_group_names: List[str]
        :param truncate: If set to `true`, reduces the size of a volume during a volume resize operation.
                        When a volume is truncated, Purity automatically takes an undo snapshot,
                        providing a 24-hour window during which the previous contents can be
                        retrieved. After truncating a volume, its provisioned size can be
                        subsequently increased, but the data in truncated sectors cannot be
                        retrieved. If set to `false` or not set at all and the volume is being
                        reduced in size, the volume copy operation fails. Required if the
                        `provisioned` parameter is set to a volume size that is smaller than the
                        original size.
        :type truncate: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            volume=volume,
            authorization=authorization,
            x_request_id=x_request_id,
            add_to_protection_group_ids=add_to_protection_group_ids,
            add_to_protection_group_names=add_to_protection_group_names,
            ids=ids,
            names=names,
            remove_from_protection_group_ids=remove_from_protection_group_ids,
            remove_from_protection_group_names=remove_from_protection_group_names,
            truncate=truncate,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(add_to_protection_groups, ['add_to_protection_group_ids', 'add_to_protection_group_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _process_references(remove_from_protection_groups, ['remove_from_protection_group_ids', 'remove_from_protection_group_names'], kwargs)
        _fixup_list_type_params(['add_to_protection_group_ids', 'add_to_protection_group_names', 'ids', 'names', 'remove_from_protection_group_ids', 'remove_from_protection_group_names'], kwargs)
        return self._call_api('VolumesApi', 'api232_volumes_patch_with_http_info', kwargs)

    def get_volumes_performance_by_array(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The number of milliseconds between samples of historical data. For array-wide performance metrics (`/arrays/performance` endpoint), valid values are `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For performance metrics on storage objects (`<object name>/performance` endpoint), such as volumes, valid values are `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For space metrics, (`<object name>/space` endpoint), valid values are `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). Include the `start_time` parameter to display the performance data starting at the specified start time. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. Include the `end_time` parameter to display the performance data until the specified end time. If `end_time`is not specified, the end time will default to the current time. If the `resolution` parameter is not specified but either the `start_time` or `end_time` parameter is, then `resolution` will default to the lowest valid resolution.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List volume performance data by array  # noqa: E501
        
        Return real-time and historical performance data, real-time latency data, and average I/O size data. The data returned is for each volume on the current array and for each volume on any remote arrays that are visible to the current array. The data is grouped by individual volumes and as a total across all volumes on each array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volumes_performance_by_array_get_with_http_info(authorization, x_request_id, destroyed, end_time, filter, ids, limit, names, offset, resolution, sort, start_time, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param end_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type end_time: int
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param resolution: The number of milliseconds between samples of historical data. For array-wide
                        performance metrics (`/arrays/performance` endpoint), valid values are
                        `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30
                        minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24
                        hours). For performance metrics on storage objects (`<object
                        name>/performance` endpoint), such as volumes, valid values are `30000` (30
                        seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours),
                        `28800000` (8 hours), and `86400000` (24 hours). For space metrics,
                        (`<object name>/space` endpoint), valid values are `300000` (5 minutes),
                        `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and
                        `86400000` (24 hours). Include the `start_time` parameter to display the
                        performance data starting at the specified start time. If `start_time` is
                        not specified, the start time will default to one resolution before the end
                        time, meaning that the most recent sample of performance data will be
                        displayed. Include the `end_time` parameter to display the performance data
                        until the specified end time. If `end_time`is not specified, the end time
                        will default to the current time. If the `resolution` parameter is not
                        specified but either the `start_time` or `end_time` parameter is, then
                        `resolution` will default to the lowest valid resolution.
        :type resolution: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param start_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type start_time: int
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            destroyed=destroyed,
            end_time=end_time,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('VolumesApi', 'api232_volumes_performance_by_array_get_with_http_info', kwargs)

    def get_volumes_performance(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The number of milliseconds between samples of historical data. For array-wide performance metrics (`/arrays/performance` endpoint), valid values are `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For performance metrics on storage objects (`<object name>/performance` endpoint), such as volumes, valid values are `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For space metrics, (`<object name>/space` endpoint), valid values are `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). Include the `start_time` parameter to display the performance data starting at the specified start time. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. Include the `end_time` parameter to display the performance data until the specified end time. If `end_time`is not specified, the end time will default to the current time. If the `resolution` parameter is not specified but either the `start_time` or `end_time` parameter is, then `resolution` will default to the lowest valid resolution.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List volume performance data  # noqa: E501
        
        Returns real-time and historical performance data, real-time latency data, and average I/O sizes for each volume and and as a total of all volumes across the entire array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volumes_performance_get_with_http_info(authorization, x_request_id, destroyed, end_time, filter, ids, limit, names, offset, resolution, sort, start_time, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param end_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type end_time: int
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param resolution: The number of milliseconds between samples of historical data. For array-wide
                        performance metrics (`/arrays/performance` endpoint), valid values are
                        `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30
                        minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24
                        hours). For performance metrics on storage objects (`<object
                        name>/performance` endpoint), such as volumes, valid values are `30000` (30
                        seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours),
                        `28800000` (8 hours), and `86400000` (24 hours). For space metrics,
                        (`<object name>/space` endpoint), valid values are `300000` (5 minutes),
                        `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and
                        `86400000` (24 hours). Include the `start_time` parameter to display the
                        performance data starting at the specified start time. If `start_time` is
                        not specified, the start time will default to one resolution before the end
                        time, meaning that the most recent sample of performance data will be
                        displayed. Include the `end_time` parameter to display the performance data
                        until the specified end time. If `end_time`is not specified, the end time
                        will default to the current time. If the `resolution` parameter is not
                        specified but either the `start_time` or `end_time` parameter is, then
                        `resolution` will default to the lowest valid resolution.
        :type resolution: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param start_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type start_time: int
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            destroyed=destroyed,
            end_time=end_time,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('VolumesApi', 'api232_volumes_performance_get_with_http_info', kwargs)

    def post_volumes(
        self,
        volume: 'models.VolumePost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        add_to_protection_groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        add_to_protection_group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="The volumes will be added to the specified protection groups along with creation or movement across pods and array. When a volume is moved, the specified protection groups must be in the target pod or array. Enter multiple ids in comma-separated format.")] = None,
        add_to_protection_group_names: Annotated[Optional[conlist(StrictStr)], Field(description="The volumes will be added to the specified protection groups along with creation or movement across pods and array. When a volume is moved, the specified protection groups must be in the target pod or array. Enter multiple names in a comma-separated format.")] = None,
        allow_throttle: Annotated[Optional[StrictBool], Field(description="If set to `true`, allows operation to fail if array health is not optimal.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        overwrite: Annotated[Optional[StrictBool], Field(description="If set to `true`, overwrites an existing object during an object copy operation. If set to `false` or not set at all and the target name is an existing object, the copy operation fails. Required if the `source` body parameter is set and the source overwrites an existing object during the copy operation.")] = None,
        with_default_protection: Annotated[Optional[StrictBool], Field(description="If specified as `true`, the initial protection of the newly created volumes will be the union of the container default protection configuration and `add_to_protection_group_names`. If specified as `false`, the default protection of the container will not be applied automatically. The initial protection of the newly created volumes will be configured by `add_to_protection_group_names`. If not specified, defaults to `true`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a volume  # noqa: E501
        
        Creates one or more virtual storage volumes of the specified size. If `provisioned` is not specified, the size of the new volume defaults to 1 MB. The `names` query parameter is required. The `add_to_protection_group_names` query parameter specifies a list of protection group names that will compose the initial protection for the volume. The `with_default_protection` query parameter specifies whether to use the container default protection configuration for the volume. The `add_to_protection_group_names` and `with_default_protection` query parameters cannot be provided when `overwrite` is `true`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volumes_post_with_http_info(volume, authorization, x_request_id, add_to_protection_group_ids, add_to_protection_group_names, allow_throttle, names, overwrite, with_default_protection, async_req=True)
        >>> result = thread.get()
        
        :param volume: (required)
        :type volume: models.VolumePost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param add_to_protection_groups: A list of add_to_protection_groups to query for. Overrides add_to_protection_group_ids and add_to_protection_group_names keyword arguments.
        :type add_to_protection_groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param add_to_protection_group_ids: The volumes will be added to the specified protection groups along with creation
                                            or movement across pods and array. When a volume is moved, the
                                            specified protection groups must be in the target pod or array. Enter
                                            multiple ids in comma-separated format.
        :type add_to_protection_group_ids: List[str]
        :param add_to_protection_group_names: The volumes will be added to the specified protection groups along with creation
                                            or movement across pods and array. When a volume is moved, the
                                            specified protection groups must be in the target pod or array. Enter
                                            multiple names in a comma-separated format.
        :type add_to_protection_group_names: List[str]
        :param allow_throttle: If set to `true`, allows operation to fail if array health is not optimal.
        :type allow_throttle: bool
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param overwrite: If set to `true`, overwrites an existing object during an object copy operation.
                        If set to `false` or not set at all and the target name is an existing
                        object, the copy operation fails. Required if the `source` body parameter is
                        set and the source overwrites an existing object during the copy operation.
        :type overwrite: bool
        :param with_default_protection: If specified as `true`, the initial protection of the newly created volumes will
                                        be the union of the container default protection configuration and
                                        `add_to_protection_group_names`. If specified as `false`, the default
                                        protection of the container will not be applied automatically. The
                                        initial protection of the newly created volumes will be configured by
                                        `add_to_protection_group_names`. If not specified, defaults to `true`.
        :type with_default_protection: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            volume=volume,
            authorization=authorization,
            x_request_id=x_request_id,
            add_to_protection_group_ids=add_to_protection_group_ids,
            add_to_protection_group_names=add_to_protection_group_names,
            allow_throttle=allow_throttle,
            names=names,
            overwrite=overwrite,
            with_default_protection=with_default_protection,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(add_to_protection_groups, ['add_to_protection_group_ids', 'add_to_protection_group_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['add_to_protection_group_ids', 'add_to_protection_group_names', 'names'], kwargs)
        return self._call_api('VolumesApi', 'api232_volumes_post_with_http_info', kwargs)

    def delete_volumes_protection_groups(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a volume from a protection group  # noqa: E501
        
        Deletes a volume member from a protection group. After the member has been deleted, it is no longer protected by the group. Any protection group snapshots that were taken before the member was deleted are not affected. Deleting a member from a protection group does not delete the member from the array, and the member can be added back to the protection group at any time. The `group_names` parameter represents the name of the protection group, and the `member_names` and `member_ids` parameters represent the names or IDs of the volume. The `group_names` and only one of `member_names` or `member_ids` parameters are required and must be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volumes_protection_groups_delete_with_http_info(authorization, x_request_id, group_ids, group_names, member_ids, member_names, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_ids and group_names keyword arguments.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param group_ids: A comma-separated list of group IDs.
        :type group_ids: List[str]
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            group_ids=group_ids,
            group_names=group_names,
            member_ids=member_ids,
            member_names=member_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_ids', 'group_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _fixup_list_type_params(['group_ids', 'group_names', 'member_ids', 'member_names'], kwargs)
        return self._call_api('VolumesApi', 'api232_volumes_protection_groups_delete_with_http_info', kwargs)

    def get_volumes_protection_groups(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_destroyed: Annotated[Optional[StrictBool], Field(description="If true, returns only destroyed member objects. Returns an error if a name of a live member object is specified in the member_names query param. If false, returns only live member objects. Returns an error if a name of a destroyed member object is specified in the member_names query param.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List volumes that are members of protection groups  # noqa: E501
        
        Displays a list of volume members that belong to one or more protection groups.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volumes_protection_groups_get_with_http_info(authorization, x_request_id, continuation_token, filter, group_ids, group_names, limit, member_destroyed, member_ids, member_names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_ids and group_names keyword arguments.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param group_ids: A comma-separated list of group IDs.
        :type group_ids: List[str]
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_destroyed: If true, returns only destroyed member objects. Returns an error if a name of a
                                live member object is specified in the member_names query param. If false,
                                returns only live member objects. Returns an error if a name of a
                                destroyed member object is specified in the member_names query param.
        :type member_destroyed: bool
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            group_ids=group_ids,
            group_names=group_names,
            limit=limit,
            member_destroyed=member_destroyed,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_ids', 'group_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _fixup_list_type_params(['group_ids', 'group_names', 'member_ids', 'member_names', 'sort'], kwargs)
        return self._call_api('VolumesApi', 'api232_volumes_protection_groups_get_with_http_info', kwargs)

    def post_volumes_protection_groups(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a volume and add it to a protection group  # noqa: E501
        
        Creates a volume member and adds it to a protection group. Members that are already in the protection group are not affected. For asynchronous replication, only members of the same type can belong to a protection group. The `group_names` parameter represents the name of the protection group, and the `member_names` and `member_ids` parameters represent the names or IDs of the volume. The `group_names` and only one of `member_names` or `member_ids` parameters are required and must be set together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volumes_protection_groups_post_with_http_info(authorization, x_request_id, group_ids, group_names, member_ids, member_names, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_ids and group_names keyword arguments.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param group_ids: A comma-separated list of group IDs.
        :type group_ids: List[str]
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            group_ids=group_ids,
            group_names=group_names,
            member_ids=member_ids,
            member_names=member_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_ids', 'group_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _fixup_list_type_params(['group_ids', 'group_names', 'member_ids', 'member_names'], kwargs)
        return self._call_api('VolumesApi', 'api232_volumes_protection_groups_post_with_http_info', kwargs)

    def get_volumes_space(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The number of milliseconds between samples of historical data. For array-wide performance metrics (`/arrays/performance` endpoint), valid values are `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For performance metrics on storage objects (`<object name>/performance` endpoint), such as volumes, valid values are `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For space metrics, (`<object name>/space` endpoint), valid values are `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). Include the `start_time` parameter to display the performance data starting at the specified start time. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. Include the `end_time` parameter to display the performance data until the specified end time. If `end_time`is not specified, the end time will default to the current time. If the `resolution` parameter is not specified but either the `start_time` or `end_time` parameter is, then `resolution` will default to the lowest valid resolution.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List volume space information  # noqa: E501
        
        Displays the provisioned size and physical storage consumption data for each volume.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volumes_space_get_with_http_info(authorization, x_request_id, destroyed, end_time, filter, ids, limit, names, offset, resolution, sort, start_time, total_item_count, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param end_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type end_time: int
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple
                    resource IDs in comma-separated format. The `ids` or `names` parameter is
                    required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param resolution: The number of milliseconds between samples of historical data. For array-wide
                        performance metrics (`/arrays/performance` endpoint), valid values are
                        `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30
                        minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24
                        hours). For performance metrics on storage objects (`<object
                        name>/performance` endpoint), such as volumes, valid values are `30000` (30
                        seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours),
                        `28800000` (8 hours), and `86400000` (24 hours). For space metrics,
                        (`<object name>/space` endpoint), valid values are `300000` (5 minutes),
                        `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and
                        `86400000` (24 hours). Include the `start_time` parameter to display the
                        performance data starting at the specified start time. If `start_time` is
                        not specified, the start time will default to one resolution before the end
                        time, meaning that the most recent sample of performance data will be
                        displayed. Include the `end_time` parameter to display the performance data
                        until the specified end time. If `end_time`is not specified, the end time
                        will default to the current time. If the `resolution` parameter is not
                        specified but either the `start_time` or `end_time` parameter is, then
                        `resolution` will default to the lowest valid resolution.
        :type resolution: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param start_time: Displays historical performance data for the specified time window, where
                        `start_time` is the beginning of the time window, and `end_time` is the end
                        of the time window. The `start_time` and `end_time` parameters are specified
                        in milliseconds since the UNIX epoch. If `start_time` is not specified, the
                        start time will default to one resolution before the end time, meaning that
                        the most recent sample of performance data will be displayed. If
                        `end_time`is not specified, the end time will default to the current time.
                        Include the `resolution` parameter to display the performance data at the
                        specified resolution. If not specified, `resolution` defaults to the lowest
                        valid resolution.
        :type start_time: int
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering.
                        Where it makes more sense, the average value is displayed instead. The
                        values are displayed for each name where meaningful. If `total_only=true`,
                        the `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            destroyed=destroyed,
            end_time=end_time,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_item_count=total_item_count,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('VolumesApi', 'api232_volumes_space_get_with_http_info', kwargs)

    def put_volumes_tags_batch(
        self,
        tag: Annotated[conlist('models.Tag', max_items=30, min_items=1, unique_items=True), Field(..., description="A list of tags to be created or, if already existing, updated.")],
        resources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        resource_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. The `resource_ids` or `resource_names` parameter is required, but they cannot be set together.")] = None,
        resource_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. The `resource_ids` or `resource_names` parameter is required, but they cannot be set together.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Update tags  # noqa: E501
        
        Updates tags.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volumes_tags_batch_put_with_http_info(tag, authorization, x_request_id, resource_ids, resource_names, async_req=True)
        >>> result = thread.get()
        
        :param tag: A list of tags to be created or, if already existing, updated. (required)
        :type tag: List[models.Tag]
        :param resources: A list of resources to query for. Overrides resource_ids and resource_names keyword arguments.
        :type resources: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param resource_ids: A comma-separated list of resource IDs. The `resource_ids` or `resource_names`
                            parameter is required, but they cannot be set together.
        :type resource_ids: List[str]
        :param resource_names: A comma-separated list of resource names. The `resource_ids` or `resource_names`
                            parameter is required, but they cannot be set together.
        :type resource_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            tag=tag,
            authorization=authorization,
            x_request_id=x_request_id,
            resource_ids=resource_ids,
            resource_names=resource_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(resources, ['resource_ids', 'resource_names'], kwargs)
        _fixup_list_type_params(['tag', 'resource_ids', 'resource_names'], kwargs)
        return self._call_api('VolumesApi', 'api232_volumes_tags_batch_put_with_http_info', kwargs)

    def delete_volumes_tags(
        self,
        resources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        keys: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of tag keys.")] = None,
        namespaces: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of namespaces. Only one namespace is allowed per delete request.")] = None,
        resource_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. The `resource_ids` or `resource_names` parameter is required, but they cannot be set together.")] = None,
        resource_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. The `resource_ids` or `resource_names` parameter is required, but they cannot be set together.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete tags  # noqa: E501
        
        Deletes specified tags.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volumes_tags_delete_with_http_info(authorization, x_request_id, keys, namespaces, resource_ids, resource_names, async_req=True)
        >>> result = thread.get()
        
        :param resources: A list of resources to query for. Overrides resource_ids and resource_names keyword arguments.
        :type resources: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param keys: A comma-separated list of tag keys.
        :type keys: List[str]
        :param namespaces: A comma-separated list of namespaces. Only one namespace is allowed per delete
                        request.
        :type namespaces: List[str]
        :param resource_ids: A comma-separated list of resource IDs. The `resource_ids` or `resource_names`
                            parameter is required, but they cannot be set together.
        :type resource_ids: List[str]
        :param resource_names: A comma-separated list of resource names. The `resource_ids` or `resource_names`
                            parameter is required, but they cannot be set together.
        :type resource_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            keys=keys,
            namespaces=namespaces,
            resource_ids=resource_ids,
            resource_names=resource_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(resources, ['resource_ids', 'resource_names'], kwargs)
        _fixup_list_type_params(['keys', 'namespaces', 'resource_ids', 'resource_names'], kwargs)
        return self._call_api('VolumesApi', 'api232_volumes_tags_delete_with_http_info', kwargs)

    def get_volumes_tags(
        self,
        resources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        namespaces: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of namespaces.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        resource_destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns only objects from destroyed resources. Returns an error if the name of a live resource is specified in the `resource_names` query parameter. If set to `false`, returns only objects from live resources. Returns an error if the name of a destroyed resource is specified in the `resource_names` query parameter.")] = None,
        resource_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. The `resource_ids` or `resource_names` parameter is required, but they cannot be set together.")] = None,
        resource_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. The `resource_ids` or `resource_names` parameter is required, but they cannot be set together.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List tags  # noqa: E501
        
        Displays the list of tags.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volumes_tags_get_with_http_info(authorization, x_request_id, continuation_token, filter, limit, namespaces, offset, resource_destroyed, resource_ids, resource_names, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param resources: A list of resources to query for. Overrides resource_ids and resource_names keyword arguments.
        :type resources: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param namespaces: A comma-separated list of namespaces.
        :type namespaces: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param resource_destroyed: If set to `true`, returns only objects from destroyed resources. Returns an
                                error if the name of a live resource is specified in the `resource_names`
                                query parameter. If set to `false`, returns only objects from live
                                resources. Returns an error if the name of a destroyed resource is
                                specified in the `resource_names` query parameter.
        :type resource_destroyed: bool
        :param resource_ids: A comma-separated list of resource IDs. The `resource_ids` or `resource_names`
                            parameter is required, but they cannot be set together.
        :type resource_ids: List[str]
        :param resource_names: A comma-separated list of resource names. The `resource_ids` or `resource_names`
                            parameter is required, but they cannot be set together.
        :type resource_names: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            namespaces=namespaces,
            offset=offset,
            resource_destroyed=resource_destroyed,
            resource_ids=resource_ids,
            resource_names=resource_names,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(resources, ['resource_ids', 'resource_names'], kwargs)
        _fixup_list_type_params(['namespaces', 'resource_ids', 'resource_names', 'sort'], kwargs)
        return self._call_api('VolumesApi', 'api232_volumes_tags_get_with_http_info', kwargs)

    def post_volumes_test(
        self,
        volume: 'models.VolumePost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        add_to_protection_groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        add_to_protection_group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="The volumes will be added to the specified protection groups along with creation or movement across pods and array. When a volume is moved, the specified protection groups must be in the target pod or array. Enter multiple ids in comma-separated format.")] = None,
        add_to_protection_group_names: Annotated[Optional[conlist(StrictStr)], Field(description="The volumes will be added to the specified protection groups along with creation or movement across pods and array. When a volume is moved, the specified protection groups must be in the target pod or array. Enter multiple names in a comma-separated format.")] = None,
        allow_throttle: Annotated[Optional[StrictBool], Field(description="If set to `true`, allows operation to fail if array health is not optimal.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        overwrite: Annotated[Optional[StrictBool], Field(description="If set to `true`, overwrites an existing object during an object copy operation. If set to `false` or not set at all and the target name is an existing object, the copy operation fails. Required if the `source` body parameter is set and the source overwrites an existing object during the copy operation.")] = None,
        with_default_protection: Annotated[Optional[StrictBool], Field(description="If specified as `true`, the initial protection of the newly created volumes will be the union of the container default protection configuration and `add_to_protection_group_names`. If specified as `false`, the default protection of the container will not be applied automatically. The initial protection of the newly created volumes will be configured by `add_to_protection_group_names`. If not specified, defaults to `true`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Make an attempt to copy a volume  # noqa: E501
        
        Makes an attempt to create a volume by copying it from a source volume on the local array without actually creating it, to test if the volume can be successfully created. Only available for creating a volume via a copy, not direct volume creation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volumes_test_post_with_http_info(volume, authorization, x_request_id, add_to_protection_group_ids, add_to_protection_group_names, allow_throttle, names, overwrite, with_default_protection, async_req=True)
        >>> result = thread.get()
        
        :param volume: (required)
        :type volume: models.VolumePost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param add_to_protection_groups: A list of add_to_protection_groups to query for. Overrides add_to_protection_group_ids and add_to_protection_group_names keyword arguments.
        :type add_to_protection_groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param add_to_protection_group_ids: The volumes will be added to the specified protection groups along with creation
                                            or movement across pods and array. When a volume is moved, the
                                            specified protection groups must be in the target pod or array. Enter
                                            multiple ids in comma-separated format.
        :type add_to_protection_group_ids: List[str]
        :param add_to_protection_group_names: The volumes will be added to the specified protection groups along with creation
                                            or movement across pods and array. When a volume is moved, the
                                            specified protection groups must be in the target pod or array. Enter
                                            multiple names in a comma-separated format.
        :type add_to_protection_group_names: List[str]
        :param allow_throttle: If set to `true`, allows operation to fail if array health is not optimal.
        :type allow_throttle: bool
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param overwrite: If set to `true`, overwrites an existing object during an object copy operation.
                        If set to `false` or not set at all and the target name is an existing
                        object, the copy operation fails. Required if the `source` body parameter is
                        set and the source overwrites an existing object during the copy operation.
        :type overwrite: bool
        :param with_default_protection: If specified as `true`, the initial protection of the newly created volumes will
                                        be the union of the container default protection configuration and
                                        `add_to_protection_group_names`. If specified as `false`, the default
                                        protection of the container will not be applied automatically. The
                                        initial protection of the newly created volumes will be configured by
                                        `add_to_protection_group_names`. If not specified, defaults to `true`.
        :type with_default_protection: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            volume=volume,
            authorization=authorization,
            x_request_id=x_request_id,
            add_to_protection_group_ids=add_to_protection_group_ids,
            add_to_protection_group_names=add_to_protection_group_names,
            allow_throttle=allow_throttle,
            names=names,
            overwrite=overwrite,
            with_default_protection=with_default_protection,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(add_to_protection_groups, ['add_to_protection_group_ids', 'add_to_protection_group_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['add_to_protection_group_ids', 'add_to_protection_group_names', 'names'], kwargs)
        return self._call_api('VolumesApi', 'api232_volumes_test_post_with_http_info', kwargs)

    def get_volumes_volume_groups(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique group name specified. Examples of groups include host groups, pods, protection groups, and volume groups. Enter multiple names in comma-separated format. For example, `hgroup01,hgroup02`.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List volumes that are in volume groups  # noqa: E501
        
        Returns a list of volumes that are in a volume group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api232_volumes_volume_groups_get_with_http_info(authorization, x_request_id, continuation_token, filter, group_ids, group_names, limit, member_ids, member_names, offset, sort, total_item_count, async_req=True)
        >>> result = thread.get()
        
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_ids and group_names keyword arguments.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param authorization: Deprecated. Please use Client level authorization
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed.
                                The token is a Base64 encoded value. Set `continuation_token` to the
                                system-generated token taken from the `x-next-token` header field of the
                                response. A query has reached its last page when the response does not
                                include a token. Pagination requires the `limit` and `continuation_token`
                                query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter
                    criteria.
        :type filter: str
        :param group_ids: A comma-separated list of group IDs.
        :type group_ids: List[str]
        :param group_names: Performs the operation on the unique group name specified. Examples of groups
                            include host groups, pods, protection groups, and volume groups. Enter
                            multiple names in comma-separated format. For example, `hgroup01,hgroup02`.
        :type group_names: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page.
                    To return the total number of resources, set `limit=0`. The total number of
                    resources is returned as a `total_item_count` value. If the page size
                    requested is larger than the system maximum limit, the server returns the
                    maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member
                        IDs in comma-separated format. The `member_ids` or `member_names` parameter
                        is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members
                            include volumes, hosts, host groups, and directories. Enter multiple names
                            in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full
                    set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in
                    the response by which to sort. Sorting can be performed on any of the names
                    in the response, and the objects can be sorted in ascending or descending
                    order. By default, the response objects are sorted in ascending order. To
                    sort in descending order, append the minus sign (`-`) to the name. A single
                    request can be sorted on multiple objects. For example, you can sort all
                    volumes from largest to smallest volume size, and then sort volumes of the
                    same size in ascending order by volume name. To sort on multiple names, list
                    the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            authorization=authorization,
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=filter,
            group_ids=group_ids,
            group_names=group_names,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(groups, ['group_ids', 'group_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _fixup_list_type_params(['group_ids', 'group_names', 'member_ids', 'member_names', 'sort'], kwargs)
        return self._call_api('VolumesApi', 'api232_volumes_volume_groups_get_with_http_info', kwargs)

    def _get_base_url(self, target):
        return 'https://{}'.format(target)

    def _get_api_token_endpoint(self, target):
        return self._get_base_url(target) + '/api/2.32/login'

    def _get_api_token_dispose_endpoint(self, target):
        return self._get_base_url(target) + '/api/2.32/logout'

    def _set_agent_header(self):
        """
        Set the user-agent header of the internal client.
        """
        self._api_client.set_default_header(Headers.user_agent, self._api_client.user_agent)

    def _set_auth_header(self, refresh=False):
        """
        Set the authorization or x-auth-token header of the internal client with the access
        token.

        Args:
            refresh (bool, optional): Whether to retrieve a new access token.
                Defaults to False.

        Raises:
            PureError: If there was an error retrieving the access token.
        """
        if isinstance(self._token_man, TokenManager):
            self._api_client.set_default_header(Headers.authorization,
                                                self._token_man.get_header(refresh=refresh))
        else:
            self._api_client.set_default_header(Headers.x_auth_token,
                                                self._token_man.get_session_token(refresh=refresh))

    def _call_api(self, api_class_name, api_function_name, kwargs):
        """
        Call the API function and process the response. May call the API
        repeatedly if the request failed for a reason that may not persist in
        the next call.

        Args:
            api_class_name (str): Swagger-generated api class to call.
            api_function_name (str): Swagger-generated function to call.
            kwargs (dict): kwargs to pass to the function.

        Returns:
            ValidResponse: If the call was successful.
            ErrorResponse: If the call was not successful.

        Raises:
            PureError: If calling the API fails.
            ValueError: If a parameter is of an invalid type.
            TypeError: If invalid or missing parameters are used.
        """
        kwargs['_request_timeout'] = self._timeout
        if kwargs.get('x_request_id') is None:
            kwargs['x_request_id'] = str(uuid.uuid4())

        if kwargs.get('authorization') is not None:
            warnings.warn("authorization parameter is deprecated, and will be removed soon.", DeprecationWarning)
        retries = self._retries
        api_function = getattr(self.__get_api_instance(api_class_name), api_function_name)
        while True:
            try:
                response = api_function(**kwargs)
                # Call was successful (200)
                return self._create_valid_response(response, api_function, kwargs)
            except ApiException as error:
                # If no chance for retries, return the error
                if retries == 0:
                    return self._create_error_response(error)
                # If bad request or not found, return the error (it will never work)
                elif error.status in [400, 404]:
                    return self._create_error_response(error)
                # If authentication error, reset access token and retry
                elif error.status in [401, 403]:
                    self._set_auth_header(refresh=True)
                # If rate limit error, wait the proper time and try again
                elif error.status == 429:
                    # If the the minute limit hit, wait that long
                    if (int(error.headers.get(Headers.x_ratelimit_remaining_min))
                            == int(error.headers.get(Headers.x_ratelimit_min))):
                        time.sleep(60)
                    # Otherwise it was the second limit and only wait a second
                    time.sleep(1)
                # If some internal server error we know nothing about, return
                elif error.status == 500:
                    return self._create_error_response(error)
                # If internal server errors that has to do with timeouts, try again
                elif error.status > 500:
                    pass
                # If error with the swagger client, raise the error
                else:
                    raise PureError(error)
            retries = retries - 1

    def __get_api_instance(self, api_class):
        """
        Get the API instance for the given class.

        Args:
            api_class (class): Swagger-generated api class.

        Returns:
            class: API instance for the given class.
        """
        if api_class not in self.__apis_instances:
            self.__apis_instances[api_class] = getattr(api, api_class)(self._api_client)
        return self.__apis_instances[api_class]

    def _create_valid_response(self, response: ApiResponse, endpoint, kwargs):
        """
        Create a ValidResponse from a Swagger response.

        Args:
            response (ApiResponse):
                Body, status, header tuple as returned from Swagger client.
            endpoint (function):
                The function of the Swagger client that was called.
            kwargs (dict):
                The processed kwargs that were passed to the endpoint function.

        Returns:
            ValidResponse
        """
        body = response.data
        headers = response.headers
        continuation_token = getattr(body, "continuation_token", None)
        total_item_count = getattr(body, "total_item_count", None)
        total = getattr(body, "total", None)
        more_items_remaining = getattr(body, "more_items_remaining", None)
        errors = getattr(body, "errors", None)
        items = None
        if body is not None:
            items = iter(ItemIterator(self, endpoint, kwargs,
                                      continuation_token, total_item_count,
                                      body.items,
                                      headers.get(Headers.x_request_id, None),
                                      more_items_remaining or False))
        return ValidResponse(response.status_code, continuation_token, total_item_count,
                             items, headers, total, more_items_remaining, errors=errors)

    def _create_error_response(self, error):
        """
        Create an ErrorResponse from a Swagger error.

        Args:
            error (ApiException):
                Error returned by Swagger client.

        Returns:
            ErrorResponse
        """
        status = error.status
        try:
            body = json.loads(error.body)
        except Exception:
            body = {}
        if status in [403, 429]:
            # Parse differently if the error message came from kong
            errors = [ApiError(None, body.get(Responses.message, None), None)]
        else:
            errors = [ApiError(err.get(Responses.context, None),
                               err.get(Responses.message, None),
                               err.get(Responses.location_context, None))
                      for err in body.get(Responses.errors, {})]
        return ErrorResponse(status, errors, headers=error.headers)


def _process_references(
    references: Optional[Union[ReferenceType, List[ReferenceType]]],
    params: List[str],
    kwargs: Dict[str, Any]
) -> None:

    """Process reference objects into a list of ids or names.
    Removes ids and names arguments.

    :param references: The references from which to extract ids or names.
    :type references: ReferenceType or List[ReferenceType], optional

    :param params: The parameters to be overridden.
    :type params: List[str]

    :param kwargs: The kwargs to process.
    :type kwargs: Dict[str, Any]

    :raise PureError: If a reference does not have an id or name.

    """
    if references is not None:
        if not isinstance(references, list):
            references = [references]
        for param in params:
            kwargs.pop(param, None)
        all_have_id = all(ref.id is not None for ref in references)
        all_have_name = all(ref.name is not None for ref in references)
        id_param = [param for param in params if param.endswith("ids")]
        name_param = [param for param in params if param.endswith("names")]
        if all_have_id and len(id_param) > 0:
            kwargs[id_param[0]] = [ref.id for ref in references]
        elif all_have_name and len(name_param) > 0:
            kwargs[name_param[0]] = [ref.name for ref in references]
        else:
            raise PureError('Invalid reference for {}'.format(", ".join(params)))


def _fixup_list_type_params(
    params: List[str],
    kwargs: Dict[str, Any]
) -> None:

    """Process object into a list if it expected to be list type.

    :param params: The parameters to be overridden.
    :type params: List[str]

    :param kwargs: The kwargs to process.
    :type kwargs: Dict[str, Any]

    """
    for _param in params:
        _value = kwargs.get(_param, None)
        if _value is not None and not isinstance(_value, list):
            _param_type = type(_value).__name__.replace("'", '')
            warnings.warn(f"'{_param}' parameter, invalid type: expected List[{_param_type}] but received {_param_type}, converting to list. Please revisit code.", SyntaxWarning)
            kwargs[_param] = [_value]

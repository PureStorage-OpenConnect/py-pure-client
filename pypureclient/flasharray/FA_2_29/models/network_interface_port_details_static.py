# coding: utf-8

"""
    FlashArray REST API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 2.29
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from pypureclient.flasharray.FA_2_29.models.network_interface_port_details_static_rx_power_thresholds import NetworkInterfacePortDetailsStaticRxPowerThresholds
from pypureclient.flasharray.FA_2_29.models.network_interface_port_details_static_temperature_thresholds import NetworkInterfacePortDetailsStaticTemperatureThresholds
from pypureclient.flasharray.FA_2_29.models.network_interface_port_details_static_tx_bias_thresholds import NetworkInterfacePortDetailsStaticTxBiasThresholds
from pypureclient.flasharray.FA_2_29.models.network_interface_port_details_static_tx_power_thresholds import NetworkInterfacePortDetailsStaticTxPowerThresholds
from pypureclient.flasharray.FA_2_29.models.network_interface_port_details_static_voltage_thresholds import NetworkInterfacePortDetailsStaticVoltageThresholds
from typing import Optional, Set
from typing_extensions import Self

class NetworkInterfacePortDetailsStatic(BaseModel):
    """
    Static module identity and capabilities information for the specified network interface or Fibre Channel port.
    """ # noqa: E501
    identifier: Optional[StrictStr] = Field(default=None, description="The transceiver type.")
    extended_identifier: Optional[StrictStr] = Field(default=None, description="The extended identifier of the transceiver type.")
    connector_type: Optional[StrictStr] = Field(default=None, description="The media connector type of the transceiver.")
    encoding: Optional[StrictStr] = Field(default=None, description="The serial encoding algorithm of the transceiver.")
    rate_identifier: Optional[StrictStr] = Field(default=None, description="The type of rate select functionality of the transceiver.")
    specifications: Optional[List[StrictStr]] = Field(default=None, description="The Ethernet, 10G Ethernet, ESCON, Infiniband, SONET, and other specifications supported by the transceiver.")
    fc_link_lengths: Optional[List[StrictStr]] = Field(default=None, description="The Fibre Channel distance capabilities supported by the transceiver.")
    fc_technology: Optional[List[StrictStr]] = Field(default=None, description="The Fibre Channel technologies supported by the transceiver.")
    cable_technology: Optional[List[StrictStr]] = Field(default=None, description="The SFP+ cable technology supported by the transceiver.")
    fc_transmission_media: Optional[List[StrictStr]] = Field(default=None, description="The Fibre Channel transmission media supported by the transceiver.")
    fc_speeds: Optional[StrictStr] = Field(default=None, description="The Fibre Channel speeds supported by the transceiver. Speeds are in units of 100 MBytes/sec, which correspond to GFC (Gb/s).")
    signaling_rate: Optional[StrictStr] = Field(default=None, description="The nominal signaling rate in MBd, rounded off to the nearest 100 MBd, or if greater than 25400 MBd, rounded off to the nearest 250 MBd. The value can be unspecified.")
    signaling_rate_max: Optional[StrictStr] = Field(default=None, description="The upper signaling rate limit at which the transceiver still meets its specifications, specified as a percentage above the nominal signaling rate. The value can be unspecified.")
    signaling_rate_min: Optional[StrictStr] = Field(default=None, description="The lower signaling rate limit at which the transceiver still meets its specifications, specified as a percentage below the nominal signaling rate. The value can be unspecified.")
    wavelength: Optional[StrictStr] = Field(default=None, description="Laser wavelength (for optical variants) at room temperature, in units of nm. For passive and active cable variants, the value is unspecified.")
    link_length: Optional[StrictStr] = Field(default=None, description="Link length and cable attenuation (for active or copper cables) for the specified transceiver. Values are comma-separated lists of fields and values, where each field is separated from its corresponding value by a colon. Valid fields include `Copper Cable Attenuation (12.9 GHz)`, `Copper Cable Attenuation (25.78 GHz)`, `Copper Cable`, `SMF`, `OM2`, `OM1`, `OM4`, and `OM3`. The unit for attenuation is dB, and the units for length are meters or kilometers. Unspecified fields are omitted.")
    vendor_name: Optional[Annotated[str, Field(strict=True, max_length=16)]] = Field(default=None, description="The SFP vendor name.")
    vendor_oui: Optional[Annotated[str, Field(strict=True, max_length=8)]] = Field(default=None, description="The SFP vendor IEEE company ID.")
    vendor_part_number: Optional[Annotated[str, Field(strict=True, max_length=16)]] = Field(default=None, description="The part number provided by the SFP vendor.")
    vendor_revision: Optional[Annotated[str, Field(strict=True, max_length=4)]] = Field(default=None, description="The revision level for the part number provided by the SFP vendor.")
    vendor_serial_number: Optional[Annotated[str, Field(strict=True, max_length=16)]] = Field(default=None, description="The serial number provided by the SFP vendor.")
    vendor_date_code: Optional[Annotated[str, Field(strict=True, max_length=8)]] = Field(default=None, description="The SFP vendor's manufacturing date code. The first six characters are the date in YYMMDD format, and the last two characters are the vendor specific lot code. The last two characters are optional.")
    temperature_thresholds: Optional[NetworkInterfacePortDetailsStaticTemperatureThresholds] = None
    voltage_thresholds: Optional[NetworkInterfacePortDetailsStaticVoltageThresholds] = None
    tx_bias_thresholds: Optional[NetworkInterfacePortDetailsStaticTxBiasThresholds] = None
    tx_power_thresholds: Optional[NetworkInterfacePortDetailsStaticTxPowerThresholds] = None
    rx_power_thresholds: Optional[NetworkInterfacePortDetailsStaticRxPowerThresholds] = None
    __properties: ClassVar[List[str]] = ["identifier", "extended_identifier", "connector_type", "encoding", "rate_identifier", "specifications", "fc_link_lengths", "fc_technology", "cable_technology", "fc_transmission_media", "fc_speeds", "signaling_rate", "signaling_rate_max", "signaling_rate_min", "wavelength", "link_length", "vendor_name", "vendor_oui", "vendor_part_number", "vendor_revision", "vendor_serial_number", "vendor_date_code", "temperature_thresholds", "voltage_thresholds", "tx_bias_thresholds", "tx_power_thresholds", "rx_power_thresholds"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    def to_dict(self, include_readonly: bool = False) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.

        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=set() if include_readonly else excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of temperature_thresholds
        if self.temperature_thresholds and (include_readonly or "temperature_thresholds" not in excluded_fields):
            _dict['temperature_thresholds'] = self.temperature_thresholds.to_dict()
        # override the default output from pydantic by calling `to_dict()` of voltage_thresholds
        if self.voltage_thresholds and (include_readonly or "voltage_thresholds" not in excluded_fields):
            _dict['voltage_thresholds'] = self.voltage_thresholds.to_dict()
        # override the default output from pydantic by calling `to_dict()` of tx_bias_thresholds
        if self.tx_bias_thresholds and (include_readonly or "tx_bias_thresholds" not in excluded_fields):
            _dict['tx_bias_thresholds'] = self.tx_bias_thresholds.to_dict()
        # override the default output from pydantic by calling `to_dict()` of tx_power_thresholds
        if self.tx_power_thresholds and (include_readonly or "tx_power_thresholds" not in excluded_fields):
            _dict['tx_power_thresholds'] = self.tx_power_thresholds.to_dict()
        # override the default output from pydantic by calling `to_dict()` of rx_power_thresholds
        if self.rx_power_thresholds and (include_readonly or "rx_power_thresholds" not in excluded_fields):
            _dict['rx_power_thresholds'] = self.rx_power_thresholds.to_dict()
        return _dict

    def __getitem__(self, key):
        return getattr(self, key)

    def __setitem__(self, key, value):
        setattr(self, key, value)

    def __delitem__(self, key):
        setattr(self, key, None)

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of NetworkInterfacePortDetailsStatic from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of NetworkInterfacePortDetailsStatic from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_construct(_fields_set=None, **{
            "identifier": obj.get("identifier"),
            "extended_identifier": obj.get("extended_identifier"),
            "connector_type": obj.get("connector_type"),
            "encoding": obj.get("encoding"),
            "rate_identifier": obj.get("rate_identifier"),
            "specifications": obj.get("specifications"),
            "fc_link_lengths": obj.get("fc_link_lengths"),
            "fc_technology": obj.get("fc_technology"),
            "cable_technology": obj.get("cable_technology"),
            "fc_transmission_media": obj.get("fc_transmission_media"),
            "fc_speeds": obj.get("fc_speeds"),
            "signaling_rate": obj.get("signaling_rate"),
            "signaling_rate_max": obj.get("signaling_rate_max"),
            "signaling_rate_min": obj.get("signaling_rate_min"),
            "wavelength": obj.get("wavelength"),
            "link_length": obj.get("link_length"),
            "vendor_name": obj.get("vendor_name"),
            "vendor_oui": obj.get("vendor_oui"),
            "vendor_part_number": obj.get("vendor_part_number"),
            "vendor_revision": obj.get("vendor_revision"),
            "vendor_serial_number": obj.get("vendor_serial_number"),
            "vendor_date_code": obj.get("vendor_date_code"),
            "temperature_thresholds": NetworkInterfacePortDetailsStaticTemperatureThresholds.from_dict(obj["temperature_thresholds"]) if obj.get("temperature_thresholds") is not None else None,
            "voltage_thresholds": NetworkInterfacePortDetailsStaticVoltageThresholds.from_dict(obj["voltage_thresholds"]) if obj.get("voltage_thresholds") is not None else None,
            "tx_bias_thresholds": NetworkInterfacePortDetailsStaticTxBiasThresholds.from_dict(obj["tx_bias_thresholds"]) if obj.get("tx_bias_thresholds") is not None else None,
            "tx_power_thresholds": NetworkInterfacePortDetailsStaticTxPowerThresholds.from_dict(obj["tx_power_thresholds"]) if obj.get("tx_power_thresholds") is not None else None,
            "rx_power_thresholds": NetworkInterfacePortDetailsStaticRxPowerThresholds.from_dict(obj["rx_power_thresholds"]) if obj.get("rx_power_thresholds") is not None else None
        })
        return _obj



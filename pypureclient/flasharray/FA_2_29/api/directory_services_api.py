# coding: utf-8

"""
    FlashArray REST API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 2.29
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from pypureclient.flasharray.FA_2_29.models.directory_service import DirectoryService
from pypureclient.flasharray.FA_2_29.models.directory_service_get_response import DirectoryServiceGetResponse
from pypureclient.flasharray.FA_2_29.models.directory_service_response import DirectoryServiceResponse
from pypureclient.flasharray.FA_2_29.models.directory_service_role import DirectoryServiceRole
from pypureclient.flasharray.FA_2_29.models.directory_service_role_get_response import DirectoryServiceRoleGetResponse
from pypureclient.flasharray.FA_2_29.models.directory_service_role_response import DirectoryServiceRoleResponse
from pypureclient.flasharray.FA_2_29.models.local_group import LocalGroup
from pypureclient.flasharray.FA_2_29.models.local_group_get_response import LocalGroupGetResponse
from pypureclient.flasharray.FA_2_29.models.local_group_membership_post import LocalGroupMembershipPost
from pypureclient.flasharray.FA_2_29.models.local_group_post import LocalGroupPost
from pypureclient.flasharray.FA_2_29.models.local_group_response import LocalGroupResponse
from pypureclient.flasharray.FA_2_29.models.local_membership_get_response import LocalMembershipGetResponse
from pypureclient.flasharray.FA_2_29.models.local_membership_response import LocalMembershipResponse
from pypureclient.flasharray.FA_2_29.models.local_user_get_response import LocalUserGetResponse
from pypureclient.flasharray.FA_2_29.models.local_user_membership_post import LocalUserMembershipPost
from pypureclient.flasharray.FA_2_29.models.local_user_patch import LocalUserPatch
from pypureclient.flasharray.FA_2_29.models.local_user_post import LocalUserPost
from pypureclient.flasharray.FA_2_29.models.local_user_response import LocalUserResponse
from pypureclient.flasharray.FA_2_29.models.test_result_with_resource_response import TestResultWithResourceResponse
from pypureclient.flasharray.FA_2_29.api_client import ApiClient as _TransportApiClient, RequestSerialized
from pypureclient.flasharray.FA_2_29.api_response import ApiResponse
from pypureclient.flasharray.FA_2_29.rest import RESTResponseType


class DirectoryServicesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client: Optional[_TransportApiClient] = None) -> None:
        self.api_client = api_client if api_client else _TransportApiClient.get_default()


    @validate_call
    def api229_directory_services_get_with_http_info(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[DirectoryServiceGetResponse]:
        """List directory services configuration

        Displays the role-based access control (RBAC) group configuration settings for manageability.

        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.
        :type total_item_count: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api229_directory_services_get_serialize(
            authorization = authorization,
            x_request_id = x_request_id,
            continuation_token = continuation_token,
            filter = filter,
            limit = limit,
            names = names,
            offset = offset,
            sort = sort,
            total_item_count = total_item_count,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DirectoryServiceGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api229_directory_services_get_serialize(
        self,
        authorization,
        x_request_id,
        continuation_token,
        filter,
        limit,
        names,
        offset,
        sort,
        total_item_count,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if names is not None:
            
            _query_params.append(('names', names))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if total_item_count is not None:
            
            _query_params.append(('total_item_count', total_item_count))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.29/directory-services',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api229_directory_services_local_groups_delete_with_http_info(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        sids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the object SID specified. Enter multiple SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        gids: Annotated[Optional[List[StrictInt]], Field(description="Performs the operation on the specified GIDs. Enter multiple GIDs in comma-separated format. For example, `4234235,9681923`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[None]:
        """Delete local groups

        Deletes one or more local groups. The `gids`, `names`, or `sids` parameter is required, but cannot be set together.

        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param sids: Performs the operation on the object SID specified. Enter multiple SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type sids: List[str]
        :param gids: Performs the operation on the specified GIDs. Enter multiple GIDs in comma-separated format. For example, `4234235,9681923`.
        :type gids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api229_directory_services_local_groups_delete_serialize(
            authorization = authorization,
            x_request_id = x_request_id,
            names = names,
            sids = sids,
            gids = gids,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api229_directory_services_local_groups_delete_serialize(
        self,
        authorization,
        x_request_id,
        names,
        sids,
        gids,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'names': 'csv',
            'sids': 'csv',
            'gids': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if names is not None:
            
            _query_params.append(('names', names))
            
        if sids is not None:
            
            _query_params.append(('sids', sids))
            
        if gids is not None:
            
            _query_params.append(('gids', gids))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/2.29/directory-services/local/groups',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api229_directory_services_local_groups_get_with_http_info(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        gids: Annotated[Optional[List[StrictInt]], Field(description="Performs the operation on the specified GIDs. Enter multiple GIDs in comma-separated format. For example, `4234235,9681923`.")] = None,
        sids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the object SID specified. Enter multiple SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[LocalGroupGetResponse]:
        """List local groups

        Displays a list of local groups.

        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.
        :type continuation_token: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.
        :type ids: List[str]
        :param gids: Performs the operation on the specified GIDs. Enter multiple GIDs in comma-separated format. For example, `4234235,9681923`.
        :type gids: List[int]
        :param sids: Performs the operation on the object SID specified. Enter multiple SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type sids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param filter: Narrows down the results to only the response objects that satisfy the filter criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.
        :type total_item_count: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api229_directory_services_local_groups_get_serialize(
            authorization = authorization,
            x_request_id = x_request_id,
            continuation_token = continuation_token,
            ids = ids,
            gids = gids,
            sids = sids,
            names = names,
            filter = filter,
            limit = limit,
            offset = offset,
            sort = sort,
            total_item_count = total_item_count,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LocalGroupGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api229_directory_services_local_groups_get_serialize(
        self,
        authorization,
        x_request_id,
        continuation_token,
        ids,
        gids,
        sids,
        names,
        filter,
        limit,
        offset,
        sort,
        total_item_count,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
            'gids': 'csv',
            'sids': 'csv',
            'names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if gids is not None:
            
            _query_params.append(('gids', gids))
            
        if sids is not None:
            
            _query_params.append(('sids', sids))
            
        if names is not None:
            
            _query_params.append(('names', names))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if total_item_count is not None:
            
            _query_params.append(('total_item_count', total_item_count))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.29/directory-services/local/groups',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api229_directory_services_local_groups_members_delete_with_http_info(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        group_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the group names specified. Enter multiple group names in comma-separated format. For example, `group1,group2`.")] = None,
        group_sids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the specified group SID. Enter multiple group SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        group_gids: Annotated[Optional[List[StrictInt]], Field(description="Performs the operation on the specified GIDs. Enter multiple GIDs in comma-separated format. For example, `4234235,9681923`.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        member_sids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the specified member SID. Enter multiple member SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        member_ids: Annotated[Optional[List[StrictInt]], Field(description="Performs the operation on the unique local member IDs specified. Enter multiple member IDs in comma-separated format. For local group IDs refer to group IDs (GID). For local user IDs refer to user IDs (UID). The `member_ids` and `member_names` parameters cannot be provided together.")] = None,
        member_types: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the member types specified. The type of member is the full name of the resource endpoint. Valid values include `directories`. Enter multiple member types in comma-separated format. For example, `type01,type02`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[None]:
        """Delete local group membership

        Deletes one or more local group memberships. The `group_names`, `group_sids`, or `group_ids` parameter is required, but cannot be set together.

        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param group_names: Performs the operation on the group names specified. Enter multiple group names in comma-separated format. For example, `group1,group2`.
        :type group_names: List[str]
        :param group_sids: Performs the operation on the specified group SID. Enter multiple group SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type group_sids: List[str]
        :param group_gids: Performs the operation on the specified GIDs. Enter multiple GIDs in comma-separated format. For example, `4234235,9681923`.
        :type group_gids: List[int]
        :param member_names: Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param member_sids: Performs the operation on the specified member SID. Enter multiple member SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type member_sids: List[str]
        :param member_ids: Performs the operation on the unique local member IDs specified. Enter multiple member IDs in comma-separated format. For local group IDs refer to group IDs (GID). For local user IDs refer to user IDs (UID). The `member_ids` and `member_names` parameters cannot be provided together.
        :type member_ids: List[int]
        :param member_types: Performs the operation on the member types specified. The type of member is the full name of the resource endpoint. Valid values include `directories`. Enter multiple member types in comma-separated format. For example, `type01,type02`.
        :type member_types: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api229_directory_services_local_groups_members_delete_serialize(
            authorization = authorization,
            x_request_id = x_request_id,
            group_names = group_names,
            group_sids = group_sids,
            group_gids = group_gids,
            member_names = member_names,
            member_sids = member_sids,
            member_ids = member_ids,
            member_types = member_types,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api229_directory_services_local_groups_members_delete_serialize(
        self,
        authorization,
        x_request_id,
        group_names,
        group_sids,
        group_gids,
        member_names,
        member_sids,
        member_ids,
        member_types,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'group_names': 'csv',
            'group_sids': 'csv',
            'group_gids': 'csv',
            'member_names': 'csv',
            'member_sids': 'csv',
            'member_ids': 'csv',
            'member_types': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if group_names is not None:
            
            _query_params.append(('group_names', group_names))
            
        if group_sids is not None:
            
            _query_params.append(('group_sids', group_sids))
            
        if group_gids is not None:
            
            _query_params.append(('group_gids', group_gids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if member_sids is not None:
            
            _query_params.append(('member_sids', member_sids))
            
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_types is not None:
            
            _query_params.append(('member_types', member_types))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/2.29/directory-services/local/groups/members',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api229_directory_services_local_groups_members_get_with_http_info(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        group_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the group names specified. Enter multiple group names in comma-separated format. For example, `group1,group2`.")] = None,
        group_sids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the specified group SID. Enter multiple group SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        group_gids: Annotated[Optional[List[StrictInt]], Field(description="Performs the operation on the specified GIDs. Enter multiple GIDs in comma-separated format. For example, `4234235,9681923`.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        member_sids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the specified member SID. Enter multiple member SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        member_ids: Annotated[Optional[List[StrictInt]], Field(description="Performs the operation on the unique local member IDs specified. Enter multiple member IDs in comma-separated format. For local group IDs refer to group IDs (GID). For local user IDs refer to user IDs (UID). The `member_ids` and `member_names` parameters cannot be provided together.")] = None,
        member_types: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the member types specified. The type of member is the full name of the resource endpoint. Valid values include `directories`. Enter multiple member types in comma-separated format. For example, `type01,type02`.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[LocalMembershipGetResponse]:
        """List local group memberships

        Displays a list of local group memberships.

        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.
        :type continuation_token: str
        :param group_names: Performs the operation on the group names specified. Enter multiple group names in comma-separated format. For example, `group1,group2`.
        :type group_names: List[str]
        :param group_sids: Performs the operation on the specified group SID. Enter multiple group SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type group_sids: List[str]
        :param group_gids: Performs the operation on the specified GIDs. Enter multiple GIDs in comma-separated format. For example, `4234235,9681923`.
        :type group_gids: List[int]
        :param member_names: Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param member_sids: Performs the operation on the specified member SID. Enter multiple member SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type member_sids: List[str]
        :param member_ids: Performs the operation on the unique local member IDs specified. Enter multiple member IDs in comma-separated format. For local group IDs refer to group IDs (GID). For local user IDs refer to user IDs (UID). The `member_ids` and `member_names` parameters cannot be provided together.
        :type member_ids: List[int]
        :param member_types: Performs the operation on the member types specified. The type of member is the full name of the resource endpoint. Valid values include `directories`. Enter multiple member types in comma-separated format. For example, `type01,type02`.
        :type member_types: List[str]
        :param filter: Narrows down the results to only the response objects that satisfy the filter criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.
        :type total_item_count: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api229_directory_services_local_groups_members_get_serialize(
            authorization = authorization,
            x_request_id = x_request_id,
            continuation_token = continuation_token,
            group_names = group_names,
            group_sids = group_sids,
            group_gids = group_gids,
            member_names = member_names,
            member_sids = member_sids,
            member_ids = member_ids,
            member_types = member_types,
            filter = filter,
            limit = limit,
            offset = offset,
            sort = sort,
            total_item_count = total_item_count,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LocalMembershipGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api229_directory_services_local_groups_members_get_serialize(
        self,
        authorization,
        x_request_id,
        continuation_token,
        group_names,
        group_sids,
        group_gids,
        member_names,
        member_sids,
        member_ids,
        member_types,
        filter,
        limit,
        offset,
        sort,
        total_item_count,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'group_names': 'csv',
            'group_sids': 'csv',
            'group_gids': 'csv',
            'member_names': 'csv',
            'member_sids': 'csv',
            'member_ids': 'csv',
            'member_types': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if group_names is not None:
            
            _query_params.append(('group_names', group_names))
            
        if group_sids is not None:
            
            _query_params.append(('group_sids', group_sids))
            
        if group_gids is not None:
            
            _query_params.append(('group_gids', group_gids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if member_sids is not None:
            
            _query_params.append(('member_sids', member_sids))
            
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_types is not None:
            
            _query_params.append(('member_types', member_types))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if total_item_count is not None:
            
            _query_params.append(('total_item_count', total_item_count))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.29/directory-services/local/groups/members',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api229_directory_services_local_groups_members_post_with_http_info(
        self,
        local_membership: Annotated[LocalGroupMembershipPost, Field(description="The `member_names`, `member_sids`, or `member_gids` parameter is required, but cannot be set together.")],
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        group_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the group names specified. Enter multiple group names in comma-separated format. For example, `group1,group2`.")] = None,
        group_sids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the specified group SID. Enter multiple group SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        group_gids: Annotated[Optional[List[StrictInt]], Field(description="Performs the operation on the specified GIDs. Enter multiple GIDs in comma-separated format. For example, `4234235,9681923`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[LocalMembershipResponse]:
        """Create local group membership

        Creates a local group membership with a group. The `group_names`, `group_sids`, or `group_ids` parameter is required, but cannot be set together.

        :param local_membership: The `member_names`, `member_sids`, or `member_gids` parameter is required, but cannot be set together. (required)
        :type local_membership: LocalGroupMembershipPost
        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param group_names: Performs the operation on the group names specified. Enter multiple group names in comma-separated format. For example, `group1,group2`.
        :type group_names: List[str]
        :param group_sids: Performs the operation on the specified group SID. Enter multiple group SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type group_sids: List[str]
        :param group_gids: Performs the operation on the specified GIDs. Enter multiple GIDs in comma-separated format. For example, `4234235,9681923`.
        :type group_gids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api229_directory_services_local_groups_members_post_serialize(
            local_membership = local_membership,
            authorization = authorization,
            x_request_id = x_request_id,
            group_names = group_names,
            group_sids = group_sids,
            group_gids = group_gids,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LocalMembershipResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api229_directory_services_local_groups_members_post_serialize(
        self,
        local_membership,
        authorization,
        x_request_id,
        group_names,
        group_sids,
        group_gids,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'group_names': 'csv',
            'group_sids': 'csv',
            'group_gids': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if group_names is not None:
            
            _query_params.append(('group_names', group_names))
            
        if group_sids is not None:
            
            _query_params.append(('group_sids', group_sids))
            
        if group_gids is not None:
            
            _query_params.append(('group_gids', group_gids))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if local_membership is not None:
            _body_params = local_membership


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/2.29/directory-services/local/groups/members',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api229_directory_services_local_groups_patch_with_http_info(
        self,
        local_group: LocalGroup,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        sids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the object SID specified. Enter multiple SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        gids: Annotated[Optional[List[StrictInt]], Field(description="Performs the operation on the specified GIDs. Enter multiple GIDs in comma-separated format. For example, `4234235,9681923`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[LocalGroupResponse]:
        """Modify local groups

        Modifies local groups.

        :param local_group: (required)
        :type local_group: LocalGroup
        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param sids: Performs the operation on the object SID specified. Enter multiple SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type sids: List[str]
        :param gids: Performs the operation on the specified GIDs. Enter multiple GIDs in comma-separated format. For example, `4234235,9681923`.
        :type gids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api229_directory_services_local_groups_patch_serialize(
            local_group = local_group,
            authorization = authorization,
            x_request_id = x_request_id,
            names = names,
            sids = sids,
            gids = gids,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LocalGroupResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api229_directory_services_local_groups_patch_serialize(
        self,
        local_group,
        authorization,
        x_request_id,
        names,
        sids,
        gids,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'names': 'csv',
            'sids': 'csv',
            'gids': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if names is not None:
            
            _query_params.append(('names', names))
            
        if sids is not None:
            
            _query_params.append(('sids', sids))
            
        if gids is not None:
            
            _query_params.append(('gids', gids))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if local_group is not None:
            _body_params = local_group


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/2.29/directory-services/local/groups',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api229_directory_services_local_groups_post_with_http_info(
        self,
        names: Annotated[List[StrictStr], Field(description="Performs the operation on the unique name specified. For example, `name01`. Enter multiple names in comma-separated format.")],
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        local_group: Optional[LocalGroupPost] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[LocalGroupResponse]:
        """Create local group

        Creates a local group.

        :param names: Performs the operation on the unique name specified. For example, `name01`. Enter multiple names in comma-separated format. (required)
        :type names: List[str]
        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param local_group:
        :type local_group: LocalGroupPost
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api229_directory_services_local_groups_post_serialize(
            names = names,
            authorization = authorization,
            x_request_id = x_request_id,
            local_group = local_group,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LocalGroupResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api229_directory_services_local_groups_post_serialize(
        self,
        names,
        authorization,
        x_request_id,
        local_group,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if names is not None:
            
            _query_params.append(('names', names))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if local_group is not None:
            _body_params = local_group


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/2.29/directory-services/local/groups',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api229_directory_services_local_users_delete_with_http_info(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        sids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the object SID specified. Enter multiple SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        uids: Annotated[Optional[List[StrictInt]], Field(description="A comma-separated list of local user IDs (UIDs). Enter multiple local user IDs in comma-separated format. For example, `423,51234`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[None]:
        """Delete local users

        Deletes one or more local users. The `uids`, `names`, or `sids` parameter is required, but cannot be set together.

        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param sids: Performs the operation on the object SID specified. Enter multiple SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type sids: List[str]
        :param uids: A comma-separated list of local user IDs (UIDs). Enter multiple local user IDs in comma-separated format. For example, `423,51234`.
        :type uids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api229_directory_services_local_users_delete_serialize(
            authorization = authorization,
            x_request_id = x_request_id,
            names = names,
            sids = sids,
            uids = uids,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api229_directory_services_local_users_delete_serialize(
        self,
        authorization,
        x_request_id,
        names,
        sids,
        uids,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'names': 'csv',
            'sids': 'csv',
            'uids': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if names is not None:
            
            _query_params.append(('names', names))
            
        if sids is not None:
            
            _query_params.append(('sids', sids))
            
        if uids is not None:
            
            _query_params.append(('uids', uids))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/2.29/directory-services/local/users',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api229_directory_services_local_users_get_with_http_info(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        uids: Annotated[Optional[List[StrictInt]], Field(description="A comma-separated list of local user IDs (UIDs). Enter multiple local user IDs in comma-separated format. For example, `423,51234`.")] = None,
        sids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the object SID specified. Enter multiple SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[LocalUserGetResponse]:
        """List local users

        Displays a list of local users.

        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.
        :type continuation_token: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.
        :type ids: List[str]
        :param uids: A comma-separated list of local user IDs (UIDs). Enter multiple local user IDs in comma-separated format. For example, `423,51234`.
        :type uids: List[int]
        :param sids: Performs the operation on the object SID specified. Enter multiple SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type sids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param filter: Narrows down the results to only the response objects that satisfy the filter criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.
        :type total_item_count: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api229_directory_services_local_users_get_serialize(
            authorization = authorization,
            x_request_id = x_request_id,
            continuation_token = continuation_token,
            ids = ids,
            uids = uids,
            sids = sids,
            names = names,
            filter = filter,
            limit = limit,
            offset = offset,
            sort = sort,
            total_item_count = total_item_count,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LocalUserGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api229_directory_services_local_users_get_serialize(
        self,
        authorization,
        x_request_id,
        continuation_token,
        ids,
        uids,
        sids,
        names,
        filter,
        limit,
        offset,
        sort,
        total_item_count,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
            'uids': 'csv',
            'sids': 'csv',
            'names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if uids is not None:
            
            _query_params.append(('uids', uids))
            
        if sids is not None:
            
            _query_params.append(('sids', sids))
            
        if names is not None:
            
            _query_params.append(('names', names))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if total_item_count is not None:
            
            _query_params.append(('total_item_count', total_item_count))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.29/directory-services/local/users',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api229_directory_services_local_users_members_delete_with_http_info(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        group_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the group names specified. Enter multiple group names in comma-separated format. For example, `group1,group2`.")] = None,
        group_sids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the specified group SID. Enter multiple group SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        group_gids: Annotated[Optional[List[StrictInt]], Field(description="Performs the operation on the specified GIDs. Enter multiple GIDs in comma-separated format. For example, `4234235,9681923`.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        member_sids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the specified member SID. Enter multiple member SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        member_ids: Annotated[Optional[List[StrictInt]], Field(description="Performs the operation on the unique local member IDs specified. Enter multiple member IDs in comma-separated format. For local group IDs refer to group IDs (GID). For local user IDs refer to user IDs (UID). The `member_ids` and `member_names` parameters cannot be provided together.")] = None,
        member_types: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the member types specified. The type of member is the full name of the resource endpoint. Valid values include `directories`. Enter multiple member types in comma-separated format. For example, `type01,type02`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[None]:
        """Delete local user membership

        Deletes one or more local user memberships. The `member_names`, `member_sids`, or `member_ids` parameter is required, but cannot be set together.

        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param group_names: Performs the operation on the group names specified. Enter multiple group names in comma-separated format. For example, `group1,group2`.
        :type group_names: List[str]
        :param group_sids: Performs the operation on the specified group SID. Enter multiple group SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type group_sids: List[str]
        :param group_gids: Performs the operation on the specified GIDs. Enter multiple GIDs in comma-separated format. For example, `4234235,9681923`.
        :type group_gids: List[int]
        :param member_names: Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param member_sids: Performs the operation on the specified member SID. Enter multiple member SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type member_sids: List[str]
        :param member_ids: Performs the operation on the unique local member IDs specified. Enter multiple member IDs in comma-separated format. For local group IDs refer to group IDs (GID). For local user IDs refer to user IDs (UID). The `member_ids` and `member_names` parameters cannot be provided together.
        :type member_ids: List[int]
        :param member_types: Performs the operation on the member types specified. The type of member is the full name of the resource endpoint. Valid values include `directories`. Enter multiple member types in comma-separated format. For example, `type01,type02`.
        :type member_types: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api229_directory_services_local_users_members_delete_serialize(
            authorization = authorization,
            x_request_id = x_request_id,
            group_names = group_names,
            group_sids = group_sids,
            group_gids = group_gids,
            member_names = member_names,
            member_sids = member_sids,
            member_ids = member_ids,
            member_types = member_types,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api229_directory_services_local_users_members_delete_serialize(
        self,
        authorization,
        x_request_id,
        group_names,
        group_sids,
        group_gids,
        member_names,
        member_sids,
        member_ids,
        member_types,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'group_names': 'csv',
            'group_sids': 'csv',
            'group_gids': 'csv',
            'member_names': 'csv',
            'member_sids': 'csv',
            'member_ids': 'csv',
            'member_types': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if group_names is not None:
            
            _query_params.append(('group_names', group_names))
            
        if group_sids is not None:
            
            _query_params.append(('group_sids', group_sids))
            
        if group_gids is not None:
            
            _query_params.append(('group_gids', group_gids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if member_sids is not None:
            
            _query_params.append(('member_sids', member_sids))
            
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_types is not None:
            
            _query_params.append(('member_types', member_types))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/2.29/directory-services/local/users/members',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api229_directory_services_local_users_members_get_with_http_info(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        group_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the group names specified. Enter multiple group names in comma-separated format. For example, `group1,group2`.")] = None,
        group_sids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the specified group SID. Enter multiple group SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        group_gids: Annotated[Optional[List[StrictInt]], Field(description="Performs the operation on the specified GIDs. Enter multiple GIDs in comma-separated format. For example, `4234235,9681923`.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        member_sids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the specified member SID. Enter multiple member SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        member_ids: Annotated[Optional[List[StrictInt]], Field(description="Performs the operation on the unique local member IDs specified. Enter multiple member IDs in comma-separated format. For local group IDs refer to group IDs (GID). For local user IDs refer to user IDs (UID). The `member_ids` and `member_names` parameters cannot be provided together.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[LocalMembershipGetResponse]:
        """List local user memberships

        Displays a list of local user memberships.

        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.
        :type continuation_token: str
        :param group_names: Performs the operation on the group names specified. Enter multiple group names in comma-separated format. For example, `group1,group2`.
        :type group_names: List[str]
        :param group_sids: Performs the operation on the specified group SID. Enter multiple group SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type group_sids: List[str]
        :param group_gids: Performs the operation on the specified GIDs. Enter multiple GIDs in comma-separated format. For example, `4234235,9681923`.
        :type group_gids: List[int]
        :param member_names: Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param member_sids: Performs the operation on the specified member SID. Enter multiple member SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type member_sids: List[str]
        :param member_ids: Performs the operation on the unique local member IDs specified. Enter multiple member IDs in comma-separated format. For local group IDs refer to group IDs (GID). For local user IDs refer to user IDs (UID). The `member_ids` and `member_names` parameters cannot be provided together.
        :type member_ids: List[int]
        :param filter: Narrows down the results to only the response objects that satisfy the filter criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.
        :type total_item_count: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api229_directory_services_local_users_members_get_serialize(
            authorization = authorization,
            x_request_id = x_request_id,
            continuation_token = continuation_token,
            group_names = group_names,
            group_sids = group_sids,
            group_gids = group_gids,
            member_names = member_names,
            member_sids = member_sids,
            member_ids = member_ids,
            filter = filter,
            limit = limit,
            offset = offset,
            sort = sort,
            total_item_count = total_item_count,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LocalMembershipGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api229_directory_services_local_users_members_get_serialize(
        self,
        authorization,
        x_request_id,
        continuation_token,
        group_names,
        group_sids,
        group_gids,
        member_names,
        member_sids,
        member_ids,
        filter,
        limit,
        offset,
        sort,
        total_item_count,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'group_names': 'csv',
            'group_sids': 'csv',
            'group_gids': 'csv',
            'member_names': 'csv',
            'member_sids': 'csv',
            'member_ids': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if group_names is not None:
            
            _query_params.append(('group_names', group_names))
            
        if group_sids is not None:
            
            _query_params.append(('group_sids', group_sids))
            
        if group_gids is not None:
            
            _query_params.append(('group_gids', group_gids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if member_sids is not None:
            
            _query_params.append(('member_sids', member_sids))
            
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if total_item_count is not None:
            
            _query_params.append(('total_item_count', total_item_count))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.29/directory-services/local/users/members',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api229_directory_services_local_users_members_post_with_http_info(
        self,
        local_membership: Annotated[LocalUserMembershipPost, Field(description="The `group_names`, `group_sids`, or `group_gids` parameter is required, but cannot be set together.")],
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        member_sids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the specified member SID. Enter multiple member SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        member_ids: Annotated[Optional[List[StrictInt]], Field(description="Performs the operation on the unique local member IDs specified. Enter multiple member IDs in comma-separated format. For local group IDs refer to group IDs (GID). For local user IDs refer to user IDs (UID). The `member_ids` and `member_names` parameters cannot be provided together.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[LocalMembershipResponse]:
        """Create local user membership

        Creates a local user membership with a group. The `member_names` or `member_sids` or `member_ids` parameter is required, but cannot be set together.

        :param local_membership: The `group_names`, `group_sids`, or `group_gids` parameter is required, but cannot be set together. (required)
        :type local_membership: LocalUserMembershipPost
        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_names: Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param member_sids: Performs the operation on the specified member SID. Enter multiple member SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type member_sids: List[str]
        :param member_ids: Performs the operation on the unique local member IDs specified. Enter multiple member IDs in comma-separated format. For local group IDs refer to group IDs (GID). For local user IDs refer to user IDs (UID). The `member_ids` and `member_names` parameters cannot be provided together.
        :type member_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api229_directory_services_local_users_members_post_serialize(
            local_membership = local_membership,
            authorization = authorization,
            x_request_id = x_request_id,
            member_names = member_names,
            member_sids = member_sids,
            member_ids = member_ids,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LocalMembershipResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api229_directory_services_local_users_members_post_serialize(
        self,
        local_membership,
        authorization,
        x_request_id,
        member_names,
        member_sids,
        member_ids,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_names': 'csv',
            'member_sids': 'csv',
            'member_ids': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if member_sids is not None:
            
            _query_params.append(('member_sids', member_sids))
            
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if local_membership is not None:
            _body_params = local_membership


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/2.29/directory-services/local/users/members',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api229_directory_services_local_users_patch_with_http_info(
        self,
        local_user: LocalUserPatch,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        keep_open_sessions: Annotated[Optional[StrictBool], Field(description="If set to `true`, the session does not expire. If set to `false`, when the user is disabled or password is changed, the session expires. If not specified, defaults to `false`.")] = None,
        sids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the object SID specified. Enter multiple SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.")] = None,
        uids: Annotated[Optional[List[StrictInt]], Field(description="A comma-separated list of local user IDs (UIDs). Enter multiple local user IDs in comma-separated format. For example, `423,51234`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[LocalUserResponse]:
        """Modify local user

        Modifies a local user.

        :param local_user: (required)
        :type local_user: LocalUserPatch
        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param keep_open_sessions: If set to `true`, the session does not expire. If set to `false`, when the user is disabled or password is changed, the session expires. If not specified, defaults to `false`.
        :type keep_open_sessions: bool
        :param sids: Performs the operation on the object SID specified. Enter multiple SIDs in comma-separated format. For example, `S-1-2-532-582374278-329482934,S-1-2-532-234235245-423425234`.
        :type sids: List[str]
        :param uids: A comma-separated list of local user IDs (UIDs). Enter multiple local user IDs in comma-separated format. For example, `423,51234`.
        :type uids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api229_directory_services_local_users_patch_serialize(
            local_user = local_user,
            authorization = authorization,
            x_request_id = x_request_id,
            names = names,
            keep_open_sessions = keep_open_sessions,
            sids = sids,
            uids = uids,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LocalUserResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api229_directory_services_local_users_patch_serialize(
        self,
        local_user,
        authorization,
        x_request_id,
        names,
        keep_open_sessions,
        sids,
        uids,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'names': 'csv',
            'sids': 'csv',
            'uids': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if names is not None:
            
            _query_params.append(('names', names))
            
        if keep_open_sessions is not None:
            
            _query_params.append(('keep_open_sessions', keep_open_sessions))
            
        if sids is not None:
            
            _query_params.append(('sids', sids))
            
        if uids is not None:
            
            _query_params.append(('uids', uids))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if local_user is not None:
            _body_params = local_user


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/2.29/directory-services/local/users',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api229_directory_services_local_users_post_with_http_info(
        self,
        names: Annotated[List[StrictStr], Field(description="Performs the operation on the unique name specified. For example, `name01`. Enter multiple names in comma-separated format.")],
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        local_user: Optional[LocalUserPost] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[LocalUserResponse]:
        """Create local user

        Creates a local user.

        :param names: Performs the operation on the unique name specified. For example, `name01`. Enter multiple names in comma-separated format. (required)
        :type names: List[str]
        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param local_user:
        :type local_user: LocalUserPost
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api229_directory_services_local_users_post_serialize(
            names = names,
            authorization = authorization,
            x_request_id = x_request_id,
            local_user = local_user,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LocalUserResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api229_directory_services_local_users_post_serialize(
        self,
        names,
        authorization,
        x_request_id,
        local_user,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if names is not None:
            
            _query_params.append(('names', names))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if local_user is not None:
            _body_params = local_user


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/2.29/directory-services/local/users',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api229_directory_services_patch_with_http_info(
        self,
        names: Annotated[List[StrictStr], Field(description="Performs the operation on the unique name specified. For example, `name01`. Enter multiple names in comma-separated format.")],
        directory_service: DirectoryService,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[DirectoryServiceResponse]:
        """Modify directory services configuration

        Modifies the directory service configuration.

        :param names: Performs the operation on the unique name specified. For example, `name01`. Enter multiple names in comma-separated format. (required)
        :type names: List[str]
        :param directory_service: (required)
        :type directory_service: DirectoryService
        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api229_directory_services_patch_serialize(
            names = names,
            directory_service = directory_service,
            authorization = authorization,
            x_request_id = x_request_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DirectoryServiceResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api229_directory_services_patch_serialize(
        self,
        names,
        directory_service,
        authorization,
        x_request_id,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if names is not None:
            
            _query_params.append(('names', names))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if directory_service is not None:
            _body_params = directory_service


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/2.29/directory-services',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api229_directory_services_roles_get_with_http_info(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        role_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique roles specified. For example, `array_admin`. Enter multiple roles in comma-separated format.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[DirectoryServiceRoleGetResponse]:
        """List directory services roles

        Displays the role-based access control (RBAC) group role settings.

        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full set of response objects returned.
        :type offset: int
        :param role_names: Performs the operation on the unique roles specified. For example, `array_admin`. Enter multiple roles in comma-separated format.
        :type role_names: List[str]
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.
        :type total_item_count: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api229_directory_services_roles_get_serialize(
            authorization = authorization,
            x_request_id = x_request_id,
            continuation_token = continuation_token,
            filter = filter,
            limit = limit,
            offset = offset,
            role_names = role_names,
            sort = sort,
            total_item_count = total_item_count,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DirectoryServiceRoleGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api229_directory_services_roles_get_serialize(
        self,
        authorization,
        x_request_id,
        continuation_token,
        filter,
        limit,
        offset,
        role_names,
        sort,
        total_item_count,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'role_names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if role_names is not None:
            
            _query_params.append(('role_names', role_names))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if total_item_count is not None:
            
            _query_params.append(('total_item_count', total_item_count))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.29/directory-services/roles',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api229_directory_services_roles_patch_with_http_info(
        self,
        role_names: Annotated[List[StrictStr], Field(description="Performs the operation on the unique roles specified. For example, `array_admin`. Enter multiple roles in comma-separated format.")],
        directory_service_roles: DirectoryServiceRole,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[DirectoryServiceRoleResponse]:
        """Modify directory services roles

        Modifies directory services roles, mapping them to their configured `group` and `group_base` in the directory service.

        :param role_names: Performs the operation on the unique roles specified. For example, `array_admin`. Enter multiple roles in comma-separated format. (required)
        :type role_names: List[str]
        :param directory_service_roles: (required)
        :type directory_service_roles: DirectoryServiceRole
        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api229_directory_services_roles_patch_serialize(
            role_names = role_names,
            directory_service_roles = directory_service_roles,
            authorization = authorization,
            x_request_id = x_request_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DirectoryServiceRoleResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api229_directory_services_roles_patch_serialize(
        self,
        role_names,
        directory_service_roles,
        authorization,
        x_request_id,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'role_names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if role_names is not None:
            
            _query_params.append(('role_names', role_names))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if directory_service_roles is not None:
            _body_params = directory_service_roles


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/2.29/directory-services/roles',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api229_directory_services_test_get_with_http_info(
        self,
        names: Annotated[List[StrictStr], Field(description="Performs the operation on the unique name specified. For example, `name01`. Enter multiple names in comma-separated format.")],
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[TestResultWithResourceResponse]:
        """List directory services test results

        Displays the directory services test and displays the results. The test verifies that URIs can be resolved and that the array can bind and query the tree using the bind user credentials. The test also verifies that the array can find all configured groups to ensure the common names and group base are correctly configured.

        :param names: Performs the operation on the unique name specified. For example, `name01`. Enter multiple names in comma-separated format. (required)
        :type names: List[str]
        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.
        :type continuation_token: str
        :param filter: Narrows down the results to only the response objects that satisfy the filter criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.
        :type limit: int
        :param offset: The starting position based on the results of the query in relation to the full set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.
        :type total_item_count: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api229_directory_services_test_get_serialize(
            names = names,
            authorization = authorization,
            x_request_id = x_request_id,
            continuation_token = continuation_token,
            filter = filter,
            limit = limit,
            offset = offset,
            sort = sort,
            total_item_count = total_item_count,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TestResultWithResourceResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api229_directory_services_test_get_serialize(
        self,
        names,
        authorization,
        x_request_id,
        continuation_token,
        filter,
        limit,
        offset,
        sort,
        total_item_count,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if names is not None:
            
            _query_params.append(('names', names))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if total_item_count is not None:
            
            _query_params.append(('total_item_count', total_item_count))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.29/directory-services/test',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )

# coding: utf-8

"""
    FlashArray REST API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 2.21
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from pypureclient.flasharray.FA_2_21.models.software_upgrade_plan import SoftwareUpgradePlan
from typing import Optional, Set
from typing_extensions import Self

class Software(BaseModel):
    """
    Software
    """ # noqa: E501
    id: Optional[StrictStr] = Field(default=None, description="A globally unique, system-generated ID. The ID cannot be modified.")
    name: Optional[StrictStr] = Field(default=None, description="Name of the resource. The name cannot be modified.")
    details: Optional[StrictStr] = Field(default=None, description="The detailed reason for the `status`.")
    payload_id: Optional[StrictStr] = Field(default=None, description="A checksum hash referring to the update bundle.")
    progress: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The progress of the software upgrade. Displayed in decimal format.")
    upgrade_hops: Optional[List[StrictStr]] = Field(default=None, description="The plan by which the upgrade will be conducted. The first element is the current version, the last element is the destination version, and the elements in between are intermediate versions.")
    version: Optional[StrictStr] = Field(default=None, description="The version of the software package.")
    upgrade_plan: Optional[List[SoftwareUpgradePlan]] = Field(default=None, description="A list of steps that are planned to run during the upgrade in an optimal scenario (i.e., all upgrade checks pass, no step is retried, and the upgrade is not aborted). Steps are listed in the order that they should occur.")
    status: Optional[StrictStr] = Field(default=None, description="The status of the software package. Valid values are `available`, `downloaded`, `downloading`, `download_failed`, `checking`, `installing`, `new`, `paused`, `aborting`, `abort`, `canceled`, `partially_installed`, and `installed`. A status of `available` indicates that the package is available for download. This only applies if `automatic-download` is not enabled. A status of `downloaded` indicates that the package is downloaded and ready for installation. A status of `downloading` indicates that the package is currently downloading. A status of `download_failed` indicates that the download of the package failed. A status of `checking` indicates that the package is currently running in `check-only` mode. A status of `installing` indicates that the package is currently installing. A status of `new` indicates that Pure1 cloud is still building the package. A status of `paused` indicates that the upgrade is paused and waiting for user input to proceed. A status of `aborting` indicates that the upgrade is being aborted, due to an unrecoverable error or an `abort` command issued by the user. A status of `canceled` indicates that the upgrade has been canceled. A status of `partially_installed` indicates that the upgrade has been partially installed due to an `abort`. The array has been upgraded to an intermediate version and the `software` is no longer available for installation. A status of `installed` indicates that the upgrade has finished.")
    __properties: ClassVar[List[str]] = ["id", "name", "details", "payload_id", "progress", "upgrade_hops", "version", "upgrade_plan", "status"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    def to_dict(self, include_readonly: bool = False) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.

        * OpenAPI `readOnly` fields are excluded, if `include_readonly` is `False`.
        """
        excluded_fields: Set[str] = set([
            "id",
            "name",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=set() if include_readonly else excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in upgrade_plan (list)
        if self.upgrade_plan and (include_readonly or "upgrade_plan" not in excluded_fields):
            _items = []
            for _item_upgrade_plan in self.upgrade_plan:
                if _item_upgrade_plan:
                    _items.append(_item_upgrade_plan.to_dict())
            _dict['upgrade_plan'] = _items
        return _dict

    def __getitem__(self, key):
        return getattr(self, key)

    def __setitem__(self, key, value):
        setattr(self, key, value)

    def __delitem__(self, key):
        setattr(self, key, None)

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Software from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Software from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_construct(_fields_set=None, **{
            "id": obj.get("id"),
            "name": obj.get("name"),
            "details": obj.get("details"),
            "payload_id": obj.get("payload_id"),
            "progress": obj.get("progress"),
            "upgrade_hops": obj.get("upgrade_hops"),
            "version": obj.get("version"),
            "upgrade_plan": [SoftwareUpgradePlan.from_dict(_item) for _item in obj["upgrade_plan"]] if obj.get("upgrade_plan") is not None else None,
            "status": obj.get("status")
        })
        return _obj



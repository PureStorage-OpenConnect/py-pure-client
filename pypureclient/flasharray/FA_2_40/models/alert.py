# coding: utf-8

"""
    FlashArray REST API

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)

    OpenAPI spec version: 2.40
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re

import six
import typing

from ....properties import Property
if typing.TYPE_CHECKING:
    from pypureclient.flasharray.FA_2_40 import models

class Alert(object):
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'name': 'str',
        'id': 'str',
        'context': 'FixedReference',
        'severity': 'str',
        'summary': 'str',
        'actual': 'str',
        'code': 'int',
        'issue': 'str',
        'knowledge_base_url': 'str',
        'created': 'int',
        'notified': 'int',
        'component_name': 'str',
        'expected': 'str',
        'description': 'str',
        'component_type': 'str',
        'flagged': 'bool',
        'closed': 'int',
        'state': 'str',
        'category': 'str',
        'updated': 'int'
    }

    attribute_map = {
        'name': 'name',
        'id': 'id',
        'context': 'context',
        'severity': 'severity',
        'summary': 'summary',
        'actual': 'actual',
        'code': 'code',
        'issue': 'issue',
        'knowledge_base_url': 'knowledge_base_url',
        'created': 'created',
        'notified': 'notified',
        'component_name': 'component_name',
        'expected': 'expected',
        'description': 'description',
        'component_type': 'component_type',
        'flagged': 'flagged',
        'closed': 'closed',
        'state': 'state',
        'category': 'category',
        'updated': 'updated'
    }

    required_args = {
    }

    def __init__(
        self,
        name=None,  # type: str
        id=None,  # type: str
        context=None,  # type: models.FixedReference
        severity=None,  # type: str
        summary=None,  # type: str
        actual=None,  # type: str
        code=None,  # type: int
        issue=None,  # type: str
        knowledge_base_url=None,  # type: str
        created=None,  # type: int
        notified=None,  # type: int
        component_name=None,  # type: str
        expected=None,  # type: str
        description=None,  # type: str
        component_type=None,  # type: str
        flagged=None,  # type: bool
        closed=None,  # type: int
        state=None,  # type: str
        category=None,  # type: str
        updated=None,  # type: int
    ):
        """
        Keyword args:
            name (str): A locally unique, system-generated name. The name cannot be modified. 
            id (str): A globally unique, system-generated ID. The ID cannot be modified and cannot refer to another resource. 
            context (FixedReference): The context in which the operation was performed. Valid values include a reference to any array which is a member of the same fleet. If the array is not a member of a fleet, `context` will always implicitly be set to the array that received the request.  Other parameters provided with the request, such as names of volumes or snapshots,  are resolved relative to the provided `context`. 
            severity (str): The severity level of the alert. Valid values include `info`, `warning`, `critical`, and `hidden`. 
            summary (str): A summary of the alert.
            actual (str): Actual condition at the time the alert is created.
            code (int): The code number of the alert.
            issue (str): Information about the alert cause.
            knowledge_base_url (str): The URL of the relevant knowledge base page.
            created (int): The time the alert was created in milliseconds since the UNIX epoch.
            notified (int): The time the most recent alert notification was sent in milliseconds since the UNIX epoch. 
            component_name (str): The name of the component that generated the alert.
            expected (str): Expected state or threshold under normal conditions.
            description (str): A short description of the alert.
            component_type (str): The type of component that generated the alert.
            flagged (bool): If set to `true`, the message is flagged. Important messages can can be flagged and listed separately. 
            closed (int): The time the alert was closed in milliseconds since the UNIX epoch.
            state (str): The current state of the alert. Valid values include `open`, `closing`, and `closed`. 
            category (str): The category of the alert. Valid values include `array`, `hardware` and `software`. 
            updated (int): The time the alert was last updated in milliseconds since the UNIX epoch.
        """
        if name is not None:
            self.name = name
        if id is not None:
            self.id = id
        if context is not None:
            self.context = context
        if severity is not None:
            self.severity = severity
        if summary is not None:
            self.summary = summary
        if actual is not None:
            self.actual = actual
        if code is not None:
            self.code = code
        if issue is not None:
            self.issue = issue
        if knowledge_base_url is not None:
            self.knowledge_base_url = knowledge_base_url
        if created is not None:
            self.created = created
        if notified is not None:
            self.notified = notified
        if component_name is not None:
            self.component_name = component_name
        if expected is not None:
            self.expected = expected
        if description is not None:
            self.description = description
        if component_type is not None:
            self.component_type = component_type
        if flagged is not None:
            self.flagged = flagged
        if closed is not None:
            self.closed = closed
        if state is not None:
            self.state = state
        if category is not None:
            self.category = category
        if updated is not None:
            self.updated = updated

    def __setattr__(self, key, value):
        if key not in self.attribute_map:
            raise KeyError("Invalid key `{}` for `Alert`".format(key))
        self.__dict__[key] = value

    def __getattribute__(self, item):
        value = object.__getattribute__(self, item)
        if isinstance(value, Property):
            raise AttributeError
        else:
            return value

    def __getitem__(self, key):
        if key not in self.attribute_map:
            raise KeyError("Invalid key `{}` for `Alert`".format(key))
        return object.__getattribute__(self, key)

    def __setitem__(self, key, value):
        if key not in self.attribute_map:
            raise KeyError("Invalid key `{}` for `Alert`".format(key))
        object.__setattr__(self, key, value)

    def __delitem__(self, key):
        if key not in self.attribute_map:
            raise KeyError("Invalid key `{}` for `Alert`".format(key))
        object.__delattr__(self, key)

    def keys(self):
        return self.attribute_map.keys()

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            if hasattr(self, attr):
                value = getattr(self, attr)
                if isinstance(value, list):
                    result[attr] = list(map(
                        lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                        value
                    ))
                elif hasattr(value, "to_dict"):
                    result[attr] = value.to_dict()
                elif isinstance(value, dict):
                    result[attr] = dict(map(
                        lambda item: (item[0], item[1].to_dict())
                        if hasattr(item[1], "to_dict") else item,
                        value.items()
                    ))
                else:
                    result[attr] = value
        if issubclass(Alert, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, Alert):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other

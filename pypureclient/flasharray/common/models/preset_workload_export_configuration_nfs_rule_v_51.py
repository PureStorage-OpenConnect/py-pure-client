# coding: utf-8

"""
    FlashArray REST API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 2.51
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from typing import Set, Dict, Any

from typing import List, Optional

try:
    from pydantic.v1 import BaseModel, Field, StrictStr, conlist
except ModuleNotFoundError:
    from pydantic import BaseModel, Field, StrictStr, conlist


class PresetWorkloadExportConfigurationNfsRule(BaseModel):
    """
    PresetWorkloadExportConfigurationNfsRule
    """
    access: Optional[StrictStr] = Field(default=None, description="The access control specification for the export. The valid values are `root-squash`, `all-squash`, and `no-root-squash`. The `root-squash` setting prevents root privilege mapping by reassigning UID 0 and GID 0 to `anonuid` and `anongid`. The `all-squash` setting maps all UIDs and GIDs to `anonuid` and `anongid`. The `no-root-squash` setting allows access using original UIDs and GIDs. The default is `root-squash`. It supports parameterization.")
    anongid: Optional[StrictStr] = Field(default=None, description="The anonymous group ID (GID) used for mapping when `access` is set to `root_squash` or `all_squash`. The default is `null`, which corresponds to `65534`. It supports parameterization.")
    anonuid: Optional[StrictStr] = Field(default=None, description="The anonymous user ID (UID) used for mapping when `access` is set to `root_squash` or `all_squash`. The default is `null`, which corresponds to `65534`. It supports parameterization.")
    atime: Optional[StrictStr] = Field(default=None, description="If set to `true`, after a read operation has occurred, the inode access time is updated only if any of the following conditions is true: the previous access time is less than the inode modify time, the previous access time is less than the inode change time, or the previous access time is more than 24 hours ago. If set to `false`, disables the update of inode access times after read operations. The defaults to `true`. It supports parameterization.")
    client: Optional[StrictStr] = Field(default=None, description="The clients permitted to access the export. Accepted notations include a single IP address, a subnet in CIDR notation, a netgroup, a hostname (RFC-1123), a fully qualified domain name (RFC-1123, RFC 2181), wildcards, or anonymous (`*`). The default is `*`. It supports parameterization.")
    nfs_version: Optional[conlist(StrictStr)] = Field(default=None, description="The NFS protocol version allowed for the export. The valid values are `nfsv3` and `nfsv4`. It supports parameterization.")
    permission: Optional[StrictStr] = Field(default=None, description="The read-write client access permissions for the export. The valid values are `rw` and `ro`. The default is `ro`. It supports parameterization.")
    secure: Optional[StrictStr] = Field(default=None, description="The flag preventing NFS access to client connections from non-reserved ports. It applies to NFSv3, NFSv4.1, and the auxiliary protocols MOUNT and NLM. The default is `false`. It supports parameterization.")
    security: Optional[conlist(StrictStr)] = Field(default=None, description="The security flavors used to access files on the mount point. The mount operation fails if the server does not support the requested flavor. The `sys` flavor trusts the client to specify the user identity. The `krb5` flavor provides cryptographic proof of user identity in each RPC request and requires additional configuration. The `krb5i` flavor adds integrity checking to prevent data tampering. The `krb5p` flavor adds integrity checking and encryption, offering the highest security but incurring the highest performance overhead. The default is `sys`. It supports parameterization.")
    __properties = ["access", "anongid", "anonuid", "atime", "client", "nfs_version", "permission", "secure", "security"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.to_dict(include_readonly=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.as_request_dict())

    def as_request_dict(self) -> Dict[str, Any]:
        return self.to_dict(include_readonly=False)

    def to_dict(self, include_readonly: bool=True) -> Dict[str, Any]:

        """Returns the dictionary representation of the model using alias"""
        excluded_fields: Set[str] = set()
        if not include_readonly:
            excluded_fields.update([
            ])
        none_fields: Set[str] = set()
        for _field in self.__fields__.keys():
            if super().__getattribute__(_field) is None:
                none_fields.add(_field)

        _dict = self.dict(by_alias=True, exclude=excluded_fields, exclude_none=True)
        return _dict

    def __getitem__(self, key):
        return super().__getattribute__(key)

    def __setitem__(self, key, value):
        setattr(self, key, value)

    def __delitem__(self, key):
        setattr(self, key, None)

    def __getattribute__(self, name: str) -> Any:
        _value = super().__getattribute__(name)
        if _value is None and name in self.__fields__.keys() and _should_raise_on_none():
            raise AttributeError
        return _value
    def __str__(self) -> str:
        return self.to_str()

    def __repr__(self) -> str:
        return self.to_str()

    @classmethod
    def from_json(cls, json_str: str) -> PresetWorkloadExportConfigurationNfsRule:
        """Create an instance of PresetWorkloadExportConfigurationNfsRule from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    @classmethod
    def from_dict(cls, obj: dict) -> PresetWorkloadExportConfigurationNfsRule:
        """Create an instance of PresetWorkloadExportConfigurationNfsRule from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return PresetWorkloadExportConfigurationNfsRule.parse_obj(obj)

        _obj = PresetWorkloadExportConfigurationNfsRule.construct(_fields_set=None, **{
            "access": obj.get("access"),
            "anongid": obj.get("anongid"),
            "anonuid": obj.get("anonuid"),
            "atime": obj.get("atime"),
            "client": obj.get("client"),
            "nfs_version": obj.get("nfs_version"),
            "permission": obj.get("permission"),
            "secure": obj.get("secure"),
            "security": obj.get("security")
        })
        return _obj

def _should_raise_on_none() -> bool:
    import importlib
    _package = importlib.import_module(__package__)
    return _package._attribute_error_on_none

def _include_in_dict(name: str, include_readonly: bool, excluded_fields: Set[str], none_fields: Set[str]) -> bool:
    if name in none_fields:
        return False
    return (include_readonly or name not in excluded_fields)


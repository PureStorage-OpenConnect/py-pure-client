# coding: utf-8

"""
    FlashArray REST API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 2.50
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from typing import Set, Dict, Any

from typing import Optional

try:
    from pydantic.v1 import BaseModel, Field, StrictStr
except ModuleNotFoundError:
    from pydantic import BaseModel, Field, StrictStr


class OffloadAzure(BaseModel):
    """
    OffloadAzure
    """
    account_name: Optional[StrictStr] = Field(default=None, description="The name of the existing Azure Blob storage account.")
    client_id: Optional[StrictStr] = Field(default=None, description="Specifies the OAuth2 client ID used to identify the Offload application. Grants access to both Blob and Storage Account operations, such as handling lifecycle policies. Must be provided together with tenant_id and client_secret. Cannot be used together with secret_access_key.")
    client_secret: Optional[StrictStr] = Field(default=None, description="Specifies the OAuth2 client secret used to identify the Offload application. Grants access to both Blob and Storage Account operations, such as handling lifecycle policies. Must be provided together with tenant_id and client_id. Cannot be used together with secret_access_key.")
    container_name: Optional[StrictStr] = Field(default=None, description="The name of the container in the Azure Blob storage account to where the data will be offloaded. The name must be a valid DNS name. If not specified, defaults to `offload`.")
    placement_strategy: Optional[StrictStr] = Field(default=None, description="Specifies the tier where data will be stored in a Microsoft Azure Blob Storage offload target. Values include azure-hot and azure-archive. If set to azure-hot, data is stored in the Hot access tier. If set to azure-archive, the data is stored in the Archive access tier and the offload is operating in archive mode. All other metadata is placed in the Hot access tier. If not specified, defaults to azure-hot when the array is initially connected to an Azure offload target. The placement_strategy cannot be changed for Azure offload targets after initialization.")
    profile: Optional[StrictStr] = Field(default=None, description="The offload target profile that will be selected for this target. This option allows more granular configuration for the target on top of the `protocol` parameter. Values include `azure`.")
    secret_access_key: Optional[StrictStr] = Field(default=None, description="Specifies the authentication key used for direct access to the Azure Blob Storage Account account_name. Grants authorization for blob operations only. To add Storage Account operations, such as handling lifecycle policies, use OAuth2 Authentication instead. Cannot be used together with the OAuth2 fields tenant_id, client_id, and client_secret.")
    tenant_id: Optional[StrictStr] = Field(default=None, description="Azure tenant ID used to identify the Offload application, granting access to both Blob and Storage Account operations (handling lifecycle policies, ...). Must be provided together with `client_id` and `client_secret`. Cannot be used together with `secret_access_key`.")
    __properties = ["account_name", "client_id", "client_secret", "container_name", "placement_strategy", "profile", "secret_access_key", "tenant_id"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.to_dict(include_readonly=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.as_request_dict())

    def as_request_dict(self) -> Dict[str, Any]:
        return self.to_dict(include_readonly=False)

    def to_dict(self, include_readonly: bool=True) -> Dict[str, Any]:

        """Returns the dictionary representation of the model using alias"""
        excluded_fields: Set[str] = set()
        if not include_readonly:
            excluded_fields.update([
            ])
        none_fields: Set[str] = set()
        for _field in self.__fields__.keys():
            if super().__getattribute__(_field) is None:
                none_fields.add(_field)

        _dict = self.dict(by_alias=True, exclude=excluded_fields, exclude_none=True)
        return _dict

    def __getitem__(self, key):
        return super().__getattribute__(key)

    def __setitem__(self, key, value):
        setattr(self, key, value)

    def __delitem__(self, key):
        setattr(self, key, None)

    def __getattribute__(self, name: str) -> Any:
        _value = super().__getattribute__(name)
        if _value is None and name in self.__fields__.keys() and _should_raise_on_none():
            raise AttributeError
        return _value
    def __str__(self) -> str:
        return self.to_str()

    def __repr__(self) -> str:
        return self.to_str()

    @classmethod
    def from_json(cls, json_str: str) -> OffloadAzure:
        """Create an instance of OffloadAzure from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    @classmethod
    def from_dict(cls, obj: dict) -> OffloadAzure:
        """Create an instance of OffloadAzure from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return OffloadAzure.parse_obj(obj)

        _obj = OffloadAzure.construct(_fields_set=None, **{
            "account_name": obj.get("account_name"),
            "client_id": obj.get("client_id"),
            "client_secret": obj.get("client_secret"),
            "container_name": obj.get("container_name"),
            "placement_strategy": obj.get("placement_strategy"),
            "profile": obj.get("profile"),
            "secret_access_key": obj.get("secret_access_key"),
            "tenant_id": obj.get("tenant_id")
        })
        return _obj

def _should_raise_on_none() -> bool:
    import importlib
    _package = importlib.import_module(__package__)
    return _package._attribute_error_on_none

def _include_in_dict(name: str, include_readonly: bool, excluded_fields: Set[str], none_fields: Set[str]) -> bool:
    if name in none_fields:
        return False
    return (include_readonly or name not in excluded_fields)


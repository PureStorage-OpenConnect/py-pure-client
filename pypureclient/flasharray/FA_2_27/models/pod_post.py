# coding: utf-8

"""
    FlashArray REST API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 2.27
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from pypureclient.flasharray.FA_2_27.models.reference import Reference
from typing import Optional, Set
from typing_extensions import Self

class PodPost(BaseModel):
    """
    PodPost
    """ # noqa: E501
    id: Optional[StrictStr] = Field(default=None, description="A globally unique, system-generated ID. The ID cannot be modified and cannot refer to another resource.")
    name: Optional[StrictStr] = Field(default=None, description="A locally unique, system-generated name. The name cannot be modified.")
    source: Optional[Reference] = Field(default=None, description="The source pod from where data is cloned to create the new pod.")
    failover_preferences: Optional[List[Reference]] = Field(default=None, description="Determines which array within a stretched pod should be given priority to stay online should the arrays ever lose contact with each other. The current array and any peer arrays that are connected to the current array for synchronous replication can be added to a pod for failover preference. By default, `failover_preferences=null`, meaning no arrays have been configured for failover preference. Enter multiple arrays in comma-separated format. To clear the list of failover preferences, set to an empty list `[]`.")
    quota_limit: Optional[Annotated[int, Field(le=4503599627370496, strict=True, ge=1048576)]] = Field(default=None, description="The logical quota limit of the pod, measured in bytes. Must be a multiple of 512.")
    __properties: ClassVar[List[str]] = ["id", "name", "source", "failover_preferences", "quota_limit"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    def to_dict(self, include_readonly: bool = False) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.

        * OpenAPI `readOnly` fields are excluded, if `include_readonly` is `False`.
        """
        excluded_fields: Set[str] = set([
            "id",
            "name",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=set() if include_readonly else excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of source
        if self.source and (include_readonly or "source" not in excluded_fields):
            _dict['source'] = self.source.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in failover_preferences (list)
        if self.failover_preferences and (include_readonly or "failover_preferences" not in excluded_fields):
            _items = []
            for _item_failover_preferences in self.failover_preferences:
                if _item_failover_preferences:
                    _items.append(_item_failover_preferences.to_dict())
            _dict['failover_preferences'] = _items
        return _dict

    def __getitem__(self, key):
        return getattr(self, key)

    def __setitem__(self, key, value):
        setattr(self, key, value)

    def __delitem__(self, key):
        setattr(self, key, None)

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PodPost from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PodPost from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_construct(_fields_set=None, **{
            "id": obj.get("id"),
            "name": obj.get("name"),
            "source": Reference.from_dict(obj["source"]) if obj.get("source") is not None else None,
            "failover_preferences": [Reference.from_dict(_item) for _item in obj["failover_preferences"]] if obj.get("failover_preferences") is not None else None,
            "quota_limit": obj.get("quota_limit")
        })
        return _obj



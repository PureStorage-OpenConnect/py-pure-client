# coding: utf-8

"""
    FlashArray REST API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 2.43
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from typing import Set, Dict, Any

from typing import List, Optional, Union

try:
    from pydantic.v1 import BaseModel, Field, StrictFloat, StrictInt, StrictStr, conlist
except ModuleNotFoundError:
    from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr, conlist
from pypureclient.flasharray.FA_2_43.models.software_upgrade_plan import SoftwareUpgradePlan


class Software(BaseModel):
    """
    Software
    """
    id: Optional[StrictStr] = Field(default=None, description="A globally unique, system-generated ID. The ID cannot be modified.")
    name: Optional[StrictStr] = Field(default=None, description="Name of the resource. The name cannot be modified.")
    details: Optional[StrictStr] = Field(default=None, description="The detailed reason for the `status`.")
    payload_id: Optional[StrictStr] = Field(default=None, description="A checksum hash referring to the update bundle.")
    progress: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The progress of the software upgrade. Displayed in decimal format.")
    status: Optional[StrictStr] = Field(default=None, description="The status of the software package. Valid values are `available`, `downloaded`, `downloading`, `download_failed`, `checking`, `installing`, `new`, `paused`, `aborting`, `abort`, `canceled`, `partially_installed`, and `installed`. A status of `available` indicates that the package is available for download. This only applies if `automatic-download` is not enabled. A status of `downloaded` indicates that the package is downloaded and ready for installation. A status of `downloading` indicates that the package is currently downloading. A status of `download_failed` indicates that the download of the package failed. A status of `checking` indicates that the package is currently running in `check-only` mode. A status of `installing` indicates that the package is currently installing. A status of `new` indicates that Pure1 cloud is still building the package. A status of `paused` indicates that the upgrade is paused and waiting for user input to proceed. A status of `aborting` indicates that the upgrade is being aborted, due to an unrecoverable error or an `abort` command issued by the user. A status of `canceled` indicates that the upgrade has been canceled. A status of `partially_installed` indicates that the upgrade has been partially installed due to an `abort`. The array has been upgraded to an intermediate version and the `software` is no longer available for installation. A status of `installed` indicates that the upgrade has finished.")
    upgrade_hops: Optional[conlist(StrictStr, unique_items=True)] = Field(default=None, description="The plan by which the upgrade will be conducted. The first element is the current version, the last element is the destination version, and the elements in between are intermediate versions.")
    upgrade_plan: Optional[conlist(SoftwareUpgradePlan)] = Field(default=None, description="A list of steps that are planned to run during the upgrade in an optimal scenario (i.e., all upgrade checks pass, no step is retried, and the upgrade is not aborted). Steps are listed in the order that they should occur.")
    version: Optional[StrictStr] = Field(default=None, description="The version of the software package.")
    __properties = ["id", "name", "details", "payload_id", "progress", "status", "upgrade_hops", "upgrade_plan", "version"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.to_dict(include_readonly=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.as_request_dict())

    def as_request_dict(self) -> Dict[str, Any]:
        return self.to_dict(include_readonly=False)

    def to_dict(self, include_readonly: bool=True) -> Dict[str, Any]:

        """Returns the dictionary representation of the model using alias"""
        excluded_fields: Set[str] = set()
        if not include_readonly:
            excluded_fields.update([
                "id",
                "name",
            ])
        none_fields: Set[str] = set()
        for _field in self.__fields__.keys():
            if super().__getattribute__(_field) is None:
                none_fields.add(_field)

        _dict = self.dict(by_alias=True, exclude=excluded_fields, exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of each item in upgrade_plan (list)
        if _include_in_dict('upgrade_plan', include_readonly, excluded_fields, none_fields):
            _items = []
            for _item in self.upgrade_plan:
                if _item:
                    _items.append(_item.to_dict(include_readonly=include_readonly))
            _dict['upgrade_plan'] = _items
        return _dict

    def __getitem__(self, key):
        return super().__getattribute__(key)

    def __setitem__(self, key, value):
        setattr(self, key, value)

    def __delitem__(self, key):
        setattr(self, key, None)

    def __getattribute__(self, name: str) -> Any:
        _value = super().__getattribute__(name)
        if _value is None and name in self.__fields__.keys() and _should_raise_on_none():
            raise AttributeError
        return _value

    def __str__(self) -> str:
        return self.to_str()

    def __repr__(self) -> str:
        return self.to_str()

    @classmethod
    def from_json(cls, json_str: str) -> Software:
        """Create an instance of Software from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    @classmethod
    def from_dict(cls, obj: dict) -> Software:
        """Create an instance of Software from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return Software.parse_obj(obj)

        _obj = Software.construct(_fields_set=None, **{
            "id": obj.get("id"),
            "name": obj.get("name"),
            "details": obj.get("details"),
            "payload_id": obj.get("payload_id"),
            "progress": obj.get("progress"),
            "status": obj.get("status"),
            "upgrade_hops": obj.get("upgrade_hops"),
            "upgrade_plan": [SoftwareUpgradePlan.from_dict(_item) for _item in obj.get("upgrade_plan")] if obj.get("upgrade_plan") is not None else None,
            "version": obj.get("version")
        })
        return _obj

def _should_raise_on_none() -> bool:
    import importlib
    _package = importlib.import_module(__package__)
    return _package._attribute_error_on_none

def _include_in_dict(name: str, include_readonly: bool, excluded_fields: Set[str], none_fields: Set[str]) -> bool:
    if name in none_fields:
        return False
    return (include_readonly or name not in excluded_fields)


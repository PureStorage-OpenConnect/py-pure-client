# coding: utf-8

"""
    FlashArray REST API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 2.37
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from pypureclient.flasharray.FA_2_37.models.directory_get_response import DirectoryGetResponse
from pypureclient.flasharray.FA_2_37.models.directory_lock_nlm_reclamation_response import DirectoryLockNlmReclamationResponse
from pypureclient.flasharray.FA_2_37.models.directory_patch import DirectoryPatch
from pypureclient.flasharray.FA_2_37.models.directory_performance_get_response import DirectoryPerformanceGetResponse
from pypureclient.flasharray.FA_2_37.models.directory_policy_export_post import DirectoryPolicyExportPost
from pypureclient.flasharray.FA_2_37.models.directory_policy_post import DirectoryPolicyPost
from pypureclient.flasharray.FA_2_37.models.directory_post import DirectoryPost
from pypureclient.flasharray.FA_2_37.models.directory_response import DirectoryResponse
from pypureclient.flasharray.FA_2_37.models.policy_member_export_get_response import PolicyMemberExportGetResponse
from pypureclient.flasharray.FA_2_37.models.policy_member_export_response import PolicyMemberExportResponse
from pypureclient.flasharray.FA_2_37.models.policy_member_get_response import PolicyMemberGetResponse
from pypureclient.flasharray.FA_2_37.models.policy_member_response import PolicyMemberResponse
from pypureclient.flasharray.FA_2_37.models.resource_directory_space_get_response import ResourceDirectorySpaceGetResponse
from pypureclient.flasharray.FA_2_37.api_client import ApiClient as _TransportApiClient, RequestSerialized
from pypureclient.flasharray.FA_2_37.api_response import ApiResponse
from pypureclient.flasharray.FA_2_37.rest import RESTResponseType


class DirectoriesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client: Optional[_TransportApiClient] = None) -> None:
        self.api_client = api_client if api_client else _TransportApiClient.get_default()


    @validate_call
    def api237_directories_delete_with_http_info(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[None]:
        """Delete managed directories

        Deletes one or more managed directories. To be deleted, a managed directory must be empty and not attached to any enabled export policies. Deleted managed directories cannot be recovered. The `ids` or `names` parameter is required, but cannot be set together.

        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api237_directories_delete_serialize(
            authorization = authorization,
            x_request_id = x_request_id,
            ids = ids,
            names = names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api237_directories_delete_serialize(
        self,
        authorization,
        x_request_id,
        ids,
        names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
            'names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if names is not None:
            
            _query_params.append(('names', names))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/2.37/directories',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api237_directories_get_with_http_info(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        file_system_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the file system ID specified. Enter multiple file system IDs in comma-separated format. The `file_system_ids` or `file_system_names` parameter is required, but they cannot be set together.")] = None,
        file_system_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the file system name specified. Enter multiple file system names in comma-separated format. For example, `filesystem01,filesystem02`.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[DirectoryGetResponse]:
        """List directories

        Displays a list of directories, including those pending eradication.

        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param file_system_ids: Performs the operation on the file system ID specified. Enter multiple file system IDs in comma-separated format. The `file_system_ids` or `file_system_names` parameter is required, but they cannot be set together.
        :type file_system_ids: List[str]
        :param file_system_names: Performs the operation on the file system name specified. Enter multiple file system names in comma-separated format. For example, `filesystem01,filesystem02`.
        :type file_system_names: List[str]
        :param filter: Narrows down the results to only the response objects that satisfy the filter criteria.
        :type filter: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.
        :type total_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api237_directories_get_serialize(
            authorization = authorization,
            x_request_id = x_request_id,
            continuation_token = continuation_token,
            destroyed = destroyed,
            file_system_ids = file_system_ids,
            file_system_names = file_system_names,
            filter = filter,
            ids = ids,
            limit = limit,
            names = names,
            offset = offset,
            sort = sort,
            total_item_count = total_item_count,
            total_only = total_only,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DirectoryGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api237_directories_get_serialize(
        self,
        authorization,
        x_request_id,
        continuation_token,
        destroyed,
        file_system_ids,
        file_system_names,
        filter,
        ids,
        limit,
        names,
        offset,
        sort,
        total_item_count,
        total_only,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'file_system_ids': 'csv',
            'file_system_names': 'csv',
            'ids': 'csv',
            'names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if destroyed is not None:
            
            _query_params.append(('destroyed', destroyed))
            
        if file_system_ids is not None:
            
            _query_params.append(('file_system_ids', file_system_ids))
            
        if file_system_names is not None:
            
            _query_params.append(('file_system_names', file_system_names))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if names is not None:
            
            _query_params.append(('names', names))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if total_item_count is not None:
            
            _query_params.append(('total_item_count', total_item_count))
            
        if total_only is not None:
            
            _query_params.append(('total_only', total_only))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.37/directories',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api237_directories_locks_nlm_reclamations_post_with_http_info(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[DirectoryLockNlmReclamationResponse]:
        """Initiate NLM reclamation.

        NLM reclamation is a system-wide operation, affecting all clients, and so only one may be in progress at a time. Attempting to initiate reclamation while one is in progress will result in an error. When NLM reclamation is initiated, all NLM locks are deleted and client applications are notified that they can reacquire their locks within a grace period.

        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api237_directories_locks_nlm_reclamations_post_serialize(
            x_request_id = x_request_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DirectoryLockNlmReclamationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api237_directories_locks_nlm_reclamations_post_serialize(
        self,
        x_request_id,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/2.37/directories/locks/nlm-reclamations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api237_directories_patch_with_http_info(
        self,
        directory: DirectoryPatch,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[DirectoryResponse]:
        """Modify a managed directory

        Modifies a managed directory. To rename a managed directory, set `name` to the new name. The `ids` or `names` parameter is required, but cannot be set together. The `name` or `directory_name` parameter is required.

        :param directory: (required)
        :type directory: DirectoryPatch
        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api237_directories_patch_serialize(
            directory = directory,
            authorization = authorization,
            x_request_id = x_request_id,
            ids = ids,
            names = names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DirectoryResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api237_directories_patch_serialize(
        self,
        directory,
        authorization,
        x_request_id,
        ids,
        names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
            'names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if names is not None:
            
            _query_params.append(('names', names))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if directory is not None:
            _body_params = directory


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/2.37/directories',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api237_directories_performance_get_with_http_info(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        resolution: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The number of milliseconds between samples of historical data. For array-wide performance metrics (`/arrays/performance` endpoint), valid values are `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For performance metrics on storage objects (`<object name>/performance` endpoint), such as volumes, valid values are `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For space metrics, (`<object name>/space` endpoint), valid values are `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). Include the `start_time` parameter to display the performance data starting at the specified start time. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. Include the `end_time` parameter to display the performance data until the specified end time. If `end_time`is not specified, the end time will default to the current time. If the `resolution` parameter is not specified but either the `start_time` or `end_time` parameter is, then `resolution` will default to the lowest valid resolution.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        protocol: Annotated[Optional[StrictStr], Field(description="Protocol type. Valid values are `nfs`, `smb`, and `all`.")] = None,
        protocol_group: Annotated[Optional[StrictStr], Field(description="Protocol group type. Valid values are `block`, `file`, and `all`.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[DirectoryPerformanceGetResponse]:
        """List directory performance data

        Displays real-time and historical performance data, real-time latency data, and average I/O sizes for each directory and as a total of all directories across the entire array.

        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter criteria.
        :type filter: str
        :param end_time: Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.
        :type end_time: int
        :param resolution: The number of milliseconds between samples of historical data. For array-wide performance metrics (`/arrays/performance` endpoint), valid values are `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For performance metrics on storage objects (`<object name>/performance` endpoint), such as volumes, valid values are `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For space metrics, (`<object name>/space` endpoint), valid values are `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). Include the `start_time` parameter to display the performance data starting at the specified start time. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. Include the `end_time` parameter to display the performance data until the specified end time. If `end_time`is not specified, the end time will default to the current time. If the `resolution` parameter is not specified but either the `start_time` or `end_time` parameter is, then `resolution` will default to the lowest valid resolution.
        :type resolution: int
        :param start_time: Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.
        :type start_time: int
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full set of response objects returned.
        :type offset: int
        :param protocol: Protocol type. Valid values are `nfs`, `smb`, and `all`.
        :type protocol: str
        :param protocol_group: Protocol group type. Valid values are `block`, `file`, and `all`.
        :type protocol_group: str
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.
        :type total_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api237_directories_performance_get_serialize(
            authorization = authorization,
            x_request_id = x_request_id,
            destroyed = destroyed,
            filter = filter,
            end_time = end_time,
            resolution = resolution,
            start_time = start_time,
            ids = ids,
            limit = limit,
            names = names,
            offset = offset,
            protocol = protocol,
            protocol_group = protocol_group,
            sort = sort,
            total_item_count = total_item_count,
            total_only = total_only,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DirectoryPerformanceGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api237_directories_performance_get_serialize(
        self,
        authorization,
        x_request_id,
        destroyed,
        filter,
        end_time,
        resolution,
        start_time,
        ids,
        limit,
        names,
        offset,
        protocol,
        protocol_group,
        sort,
        total_item_count,
        total_only,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
            'names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if destroyed is not None:
            
            _query_params.append(('destroyed', destroyed))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if end_time is not None:
            
            _query_params.append(('end_time', end_time))
            
        if resolution is not None:
            
            _query_params.append(('resolution', resolution))
            
        if start_time is not None:
            
            _query_params.append(('start_time', start_time))
            
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if names is not None:
            
            _query_params.append(('names', names))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if protocol is not None:
            
            _query_params.append(('protocol', protocol))
            
        if protocol_group is not None:
            
            _query_params.append(('protocol_group', protocol_group))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if total_item_count is not None:
            
            _query_params.append(('total_item_count', total_item_count))
            
        if total_only is not None:
            
            _query_params.append(('total_only', total_only))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.37/directories/performance',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api237_directories_policies_audit_file_delete_with_http_info(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[None]:
        """Delete a membership between a directory and one or more audit policies

        Deletes a membership between a directory and one or more audit policies. Either the `policy_ids` or `policy_names` parameter is required, but they cannot be set together. Either the `member_ids` or `member_names` parameter is required, but they cannot be set together.

        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api237_directories_policies_audit_file_delete_serialize(
            authorization = authorization,
            x_request_id = x_request_id,
            member_ids = member_ids,
            member_names = member_names,
            policy_ids = policy_ids,
            policy_names = policy_names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api237_directories_policies_audit_file_delete_serialize(
        self,
        authorization,
        x_request_id,
        member_ids,
        member_names,
        policy_ids,
        policy_names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_ids': 'csv',
            'member_names': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/2.37/directories/policies/audit-file',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api237_directories_policies_audit_file_get_with_http_info(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[PolicyMemberGetResponse]:
        """List audit policies attached to a directory

        Displays a list of audit policies that are attached to directories.

        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.
        :type total_item_count: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api237_directories_policies_audit_file_get_serialize(
            authorization = authorization,
            x_request_id = x_request_id,
            continuation_token = continuation_token,
            destroyed = destroyed,
            filter = filter,
            limit = limit,
            member_ids = member_ids,
            member_names = member_names,
            policy_ids = policy_ids,
            policy_names = policy_names,
            offset = offset,
            sort = sort,
            total_item_count = total_item_count,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PolicyMemberGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api237_directories_policies_audit_file_get_serialize(
        self,
        authorization,
        x_request_id,
        continuation_token,
        destroyed,
        filter,
        limit,
        member_ids,
        member_names,
        policy_ids,
        policy_names,
        offset,
        sort,
        total_item_count,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_ids': 'csv',
            'member_names': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if destroyed is not None:
            
            _query_params.append(('destroyed', destroyed))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if total_item_count is not None:
            
            _query_params.append(('total_item_count', total_item_count))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.37/directories/policies/audit-file',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api237_directories_policies_audit_file_post_with_http_info(
        self,
        policies: DirectoryPolicyPost,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[PolicyMemberResponse]:
        """Create a membership between a directory and one or more audit policies

        Creates a membership between a directory and one or more audit policies. Either the `member_ids` or `member_names` parameter is required, but they cannot be set together.

        :param policies: (required)
        :type policies: DirectoryPolicyPost
        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api237_directories_policies_audit_file_post_serialize(
            policies = policies,
            authorization = authorization,
            x_request_id = x_request_id,
            member_ids = member_ids,
            member_names = member_names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PolicyMemberResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api237_directories_policies_audit_file_post_serialize(
        self,
        policies,
        authorization,
        x_request_id,
        member_ids,
        member_names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_ids': 'csv',
            'member_names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if policies is not None:
            _body_params = policies


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/2.37/directories/policies/audit-file',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api237_directories_policies_autodir_delete_with_http_info(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[None]:
        """Delete a membership between a directory and one or more auto managed directory policies

        Deletes a membership between a directory with one or more auto managed directory policies. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together. The `member_ids` or `member_names` parameter is required, but they cannot be set together.

        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api237_directories_policies_autodir_delete_serialize(
            authorization = authorization,
            x_request_id = x_request_id,
            member_ids = member_ids,
            member_names = member_names,
            policy_ids = policy_ids,
            policy_names = policy_names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api237_directories_policies_autodir_delete_serialize(
        self,
        authorization,
        x_request_id,
        member_ids,
        member_names,
        policy_ids,
        policy_names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_ids': 'csv',
            'member_names': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/2.37/directories/policies/autodir',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api237_directories_policies_autodir_get_with_http_info(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[PolicyMemberGetResponse]:
        """List auto managed directory policies attached to a directory

        Displays a list of auto managed directory policies that are attached to directories.

        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.
        :type total_item_count: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api237_directories_policies_autodir_get_serialize(
            authorization = authorization,
            x_request_id = x_request_id,
            continuation_token = continuation_token,
            destroyed = destroyed,
            filter = filter,
            limit = limit,
            member_ids = member_ids,
            member_names = member_names,
            policy_ids = policy_ids,
            policy_names = policy_names,
            offset = offset,
            sort = sort,
            total_item_count = total_item_count,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PolicyMemberGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api237_directories_policies_autodir_get_serialize(
        self,
        authorization,
        x_request_id,
        continuation_token,
        destroyed,
        filter,
        limit,
        member_ids,
        member_names,
        policy_ids,
        policy_names,
        offset,
        sort,
        total_item_count,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_ids': 'csv',
            'member_names': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if destroyed is not None:
            
            _query_params.append(('destroyed', destroyed))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if total_item_count is not None:
            
            _query_params.append(('total_item_count', total_item_count))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.37/directories/policies/autodir',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api237_directories_policies_autodir_post_with_http_info(
        self,
        policies: DirectoryPolicyPost,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[PolicyMemberResponse]:
        """Create a membership between a directory with one or more auto managed directory policies

        Creates a membership between a directory with one or more auto managed directory policies. The `member_ids` or `member_names` parameter is required, but they cannot be set together.

        :param policies: (required)
        :type policies: DirectoryPolicyPost
        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api237_directories_policies_autodir_post_serialize(
            policies = policies,
            authorization = authorization,
            x_request_id = x_request_id,
            member_ids = member_ids,
            member_names = member_names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PolicyMemberResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api237_directories_policies_autodir_post_serialize(
        self,
        policies,
        authorization,
        x_request_id,
        member_ids,
        member_names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_ids': 'csv',
            'member_names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if policies is not None:
            _body_params = policies


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/2.37/directories/policies/autodir',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api237_directories_policies_get_with_http_info(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[PolicyMemberGetResponse]:
        """List policies

        Displays a list of policies that are attached to directories.

        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.
        :type total_item_count: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api237_directories_policies_get_serialize(
            authorization = authorization,
            x_request_id = x_request_id,
            continuation_token = continuation_token,
            destroyed = destroyed,
            filter = filter,
            limit = limit,
            member_ids = member_ids,
            member_names = member_names,
            policy_ids = policy_ids,
            policy_names = policy_names,
            offset = offset,
            sort = sort,
            total_item_count = total_item_count,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PolicyMemberGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api237_directories_policies_get_serialize(
        self,
        authorization,
        x_request_id,
        continuation_token,
        destroyed,
        filter,
        limit,
        member_ids,
        member_names,
        policy_ids,
        policy_names,
        offset,
        sort,
        total_item_count,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_ids': 'csv',
            'member_names': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if destroyed is not None:
            
            _query_params.append(('destroyed', destroyed))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if total_item_count is not None:
            
            _query_params.append(('total_item_count', total_item_count))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.37/directories/policies',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api237_directories_policies_nfs_delete_with_http_info(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[None]:
        """Delete a membership between a directory and one or more NFS policies

        Deletes a membership between a directory and one or more NFS policies. The `policy_ids` or `policy_names` parameter is required, but cannot be set together. The `member_ids` or `member_names` parameter is required, but cannot be set together.

        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api237_directories_policies_nfs_delete_serialize(
            authorization = authorization,
            x_request_id = x_request_id,
            member_ids = member_ids,
            member_names = member_names,
            policy_ids = policy_ids,
            policy_names = policy_names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api237_directories_policies_nfs_delete_serialize(
        self,
        authorization,
        x_request_id,
        member_ids,
        member_names,
        policy_ids,
        policy_names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_ids': 'csv',
            'member_names': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/2.37/directories/policies/nfs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api237_directories_policies_nfs_get_with_http_info(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[PolicyMemberExportGetResponse]:
        """List NFS policies attached to a directory

        Displays a list of NFS policies that are attached to directories.

        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.
        :type total_item_count: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api237_directories_policies_nfs_get_serialize(
            authorization = authorization,
            x_request_id = x_request_id,
            continuation_token = continuation_token,
            destroyed = destroyed,
            filter = filter,
            limit = limit,
            member_ids = member_ids,
            member_names = member_names,
            policy_ids = policy_ids,
            policy_names = policy_names,
            offset = offset,
            sort = sort,
            total_item_count = total_item_count,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PolicyMemberExportGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api237_directories_policies_nfs_get_serialize(
        self,
        authorization,
        x_request_id,
        continuation_token,
        destroyed,
        filter,
        limit,
        member_ids,
        member_names,
        policy_ids,
        policy_names,
        offset,
        sort,
        total_item_count,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_ids': 'csv',
            'member_names': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if destroyed is not None:
            
            _query_params.append(('destroyed', destroyed))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if total_item_count is not None:
            
            _query_params.append(('total_item_count', total_item_count))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.37/directories/policies/nfs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api237_directories_policies_nfs_post_with_http_info(
        self,
        policies: DirectoryPolicyExportPost,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[PolicyMemberExportResponse]:
        """Create a membership between a directory and one or more NFS policies

        Creates a membership between a directory and one or more NFS policies. The `member_ids` or `member_names` parameter is required but cannot be set together.

        :param policies: (required)
        :type policies: DirectoryPolicyExportPost
        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api237_directories_policies_nfs_post_serialize(
            policies = policies,
            authorization = authorization,
            x_request_id = x_request_id,
            member_ids = member_ids,
            member_names = member_names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PolicyMemberExportResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api237_directories_policies_nfs_post_serialize(
        self,
        policies,
        authorization,
        x_request_id,
        member_ids,
        member_names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_ids': 'csv',
            'member_names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if policies is not None:
            _body_params = policies


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/2.37/directories/policies/nfs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api237_directories_policies_quota_delete_with_http_info(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[None]:
        """Delete a membership between a directory and one or more quota policies

        Deletes a membership between a directory and one or more quota policies. The `policy_ids` or `policy_names` parameter is required, but cannot be set together. The `member_ids` or `member_names` parameter is required, but cannot be set together.

        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api237_directories_policies_quota_delete_serialize(
            authorization = authorization,
            x_request_id = x_request_id,
            member_ids = member_ids,
            member_names = member_names,
            policy_ids = policy_ids,
            policy_names = policy_names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api237_directories_policies_quota_delete_serialize(
        self,
        authorization,
        x_request_id,
        member_ids,
        member_names,
        policy_ids,
        policy_names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_ids': 'csv',
            'member_names': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/2.37/directories/policies/quota',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api237_directories_policies_quota_get_with_http_info(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[PolicyMemberGetResponse]:
        """List quota policies attached to a directory

        Displays a list of quota policies that are attached to directories.

        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.
        :type total_item_count: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api237_directories_policies_quota_get_serialize(
            authorization = authorization,
            x_request_id = x_request_id,
            continuation_token = continuation_token,
            destroyed = destroyed,
            filter = filter,
            limit = limit,
            member_ids = member_ids,
            member_names = member_names,
            policy_ids = policy_ids,
            policy_names = policy_names,
            offset = offset,
            sort = sort,
            total_item_count = total_item_count,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PolicyMemberGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api237_directories_policies_quota_get_serialize(
        self,
        authorization,
        x_request_id,
        continuation_token,
        destroyed,
        filter,
        limit,
        member_ids,
        member_names,
        policy_ids,
        policy_names,
        offset,
        sort,
        total_item_count,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_ids': 'csv',
            'member_names': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if destroyed is not None:
            
            _query_params.append(('destroyed', destroyed))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if total_item_count is not None:
            
            _query_params.append(('total_item_count', total_item_count))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.37/directories/policies/quota',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api237_directories_policies_quota_post_with_http_info(
        self,
        policies: DirectoryPolicyPost,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        ignore_usage: Annotated[Optional[StrictBool], Field(description="Flag used to override checks for quota management operations. If set to `true`, directory usage is not checked against the `quota_limits` that are set. If set to `false`, the actual logical bytes in use are prevented from exceeding the limits set on the directory. Client operations might be impacted. If the limit exceeds the quota, the client operation is not allowed. If not specified, defaults to `false`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[PolicyMemberResponse]:
        """Create a membership between a directory and one or more quota policies

        Creates a membership between a directory and one or more quota policies. The `member_ids` or `member_names` parameter is required, but cannot be set together.

        :param policies: (required)
        :type policies: DirectoryPolicyPost
        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param ignore_usage: Flag used to override checks for quota management operations. If set to `true`, directory usage is not checked against the `quota_limits` that are set. If set to `false`, the actual logical bytes in use are prevented from exceeding the limits set on the directory. Client operations might be impacted. If the limit exceeds the quota, the client operation is not allowed. If not specified, defaults to `false`.
        :type ignore_usage: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api237_directories_policies_quota_post_serialize(
            policies = policies,
            authorization = authorization,
            x_request_id = x_request_id,
            member_ids = member_ids,
            member_names = member_names,
            ignore_usage = ignore_usage,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PolicyMemberResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api237_directories_policies_quota_post_serialize(
        self,
        policies,
        authorization,
        x_request_id,
        member_ids,
        member_names,
        ignore_usage,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_ids': 'csv',
            'member_names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if ignore_usage is not None:
            
            _query_params.append(('ignore_usage', ignore_usage))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if policies is not None:
            _body_params = policies


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/2.37/directories/policies/quota',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api237_directories_policies_smb_delete_with_http_info(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[None]:
        """Delete a membership between a directory and one or more SMB policies

        Deletes a membership between a directory and one or more SMB policies. The `policy_ids` or `policy_names` parameter is required, but cannot be set together. The `member_ids` or `member_names` parameter is required, but cannot be set together.

        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api237_directories_policies_smb_delete_serialize(
            authorization = authorization,
            x_request_id = x_request_id,
            member_ids = member_ids,
            member_names = member_names,
            policy_ids = policy_ids,
            policy_names = policy_names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api237_directories_policies_smb_delete_serialize(
        self,
        authorization,
        x_request_id,
        member_ids,
        member_names,
        policy_ids,
        policy_names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_ids': 'csv',
            'member_names': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/2.37/directories/policies/smb',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api237_directories_policies_smb_get_with_http_info(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[PolicyMemberExportGetResponse]:
        """List SMB policies attached to a directory

        Displays a list of SMB policies that are attached to directories.

        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.
        :type total_item_count: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api237_directories_policies_smb_get_serialize(
            authorization = authorization,
            x_request_id = x_request_id,
            continuation_token = continuation_token,
            destroyed = destroyed,
            filter = filter,
            limit = limit,
            member_ids = member_ids,
            member_names = member_names,
            policy_ids = policy_ids,
            policy_names = policy_names,
            offset = offset,
            sort = sort,
            total_item_count = total_item_count,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PolicyMemberExportGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api237_directories_policies_smb_get_serialize(
        self,
        authorization,
        x_request_id,
        continuation_token,
        destroyed,
        filter,
        limit,
        member_ids,
        member_names,
        policy_ids,
        policy_names,
        offset,
        sort,
        total_item_count,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_ids': 'csv',
            'member_names': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if destroyed is not None:
            
            _query_params.append(('destroyed', destroyed))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if total_item_count is not None:
            
            _query_params.append(('total_item_count', total_item_count))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.37/directories/policies/smb',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api237_directories_policies_smb_post_with_http_info(
        self,
        policies: DirectoryPolicyExportPost,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[PolicyMemberExportResponse]:
        """Create a membership between a directory and one or more SMB policies

        Creates a membership between a directory and one or more SMB policies. The `member_ids` or `member_names` parameter is required, but cannot be set together.

        :param policies: (required)
        :type policies: DirectoryPolicyExportPost
        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api237_directories_policies_smb_post_serialize(
            policies = policies,
            authorization = authorization,
            x_request_id = x_request_id,
            member_ids = member_ids,
            member_names = member_names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PolicyMemberExportResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api237_directories_policies_smb_post_serialize(
        self,
        policies,
        authorization,
        x_request_id,
        member_ids,
        member_names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_ids': 'csv',
            'member_names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if policies is not None:
            _body_params = policies


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/2.37/directories/policies/smb',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api237_directories_policies_snapshot_delete_with_http_info(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[None]:
        """Delete a membership between a directory and one or more snapshot policies

        Deletes a membership between a directory and one or more snapshot policies. The `policy_ids` or `policy_names` parameter is required, but cannot be set together. The `member_ids` or `member_names` parameter is required, but cannot be set together.

        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api237_directories_policies_snapshot_delete_serialize(
            authorization = authorization,
            x_request_id = x_request_id,
            member_ids = member_ids,
            member_names = member_names,
            policy_ids = policy_ids,
            policy_names = policy_names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api237_directories_policies_snapshot_delete_serialize(
        self,
        authorization,
        x_request_id,
        member_ids,
        member_names,
        policy_ids,
        policy_names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_ids': 'csv',
            'member_names': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/2.37/directories/policies/snapshot',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api237_directories_policies_snapshot_get_with_http_info(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[PolicyMemberGetResponse]:
        """List snapshot policies attached to a directory

        Displays a list of snapshot policies that are attached to directories.

        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: A token used to retrieve the next page of data with some consistency guaranteed. The token is a Base64 encoded value. Set `continuation_token` to the system-generated token taken from the `x-next-token` header field of the response. A query has reached its last page when the response does not include a token. Pagination requires the `limit` and `continuation_token` query parameters.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter criteria.
        :type filter: str
        :param limit: Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.
        :type limit: int
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param policy_ids: Performs the operation on the unique policy IDs specified. Enter multiple policy IDs in comma-separated format. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.
        :type policy_ids: List[str]
        :param policy_names: Performs the operation on the policy names specified. Enter multiple policy names in comma-separated format. For example, `name01,name02`.
        :type policy_names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.
        :type total_item_count: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api237_directories_policies_snapshot_get_serialize(
            authorization = authorization,
            x_request_id = x_request_id,
            continuation_token = continuation_token,
            destroyed = destroyed,
            filter = filter,
            limit = limit,
            member_ids = member_ids,
            member_names = member_names,
            policy_ids = policy_ids,
            policy_names = policy_names,
            offset = offset,
            sort = sort,
            total_item_count = total_item_count,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PolicyMemberGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api237_directories_policies_snapshot_get_serialize(
        self,
        authorization,
        x_request_id,
        continuation_token,
        destroyed,
        filter,
        limit,
        member_ids,
        member_names,
        policy_ids,
        policy_names,
        offset,
        sort,
        total_item_count,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_ids': 'csv',
            'member_names': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if destroyed is not None:
            
            _query_params.append(('destroyed', destroyed))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if total_item_count is not None:
            
            _query_params.append(('total_item_count', total_item_count))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.37/directories/policies/snapshot',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api237_directories_policies_snapshot_post_with_http_info(
        self,
        policies: DirectoryPolicyPost,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[PolicyMemberResponse]:
        """Create a membership between a directory with one or more snapshot policies

        Creates a membership between a directory with one or more snapshot policies. The `member_ids` or `member_names` parameter is required, but cannot be set together.

        :param policies: (required)
        :type policies: DirectoryPolicyPost
        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: Performs the operation on the unique member IDs specified. Enter multiple member IDs in comma-separated format. The `member_ids` or `member_names` parameter is required, but they cannot be set together.
        :type member_ids: List[str]
        :param member_names: Performs the operation on the unique member name specified. Examples of members include volumes, hosts, host groups, and directories. Enter multiple names in comma-separated format. For example, `vol01,vol02`.
        :type member_names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api237_directories_policies_snapshot_post_serialize(
            policies = policies,
            authorization = authorization,
            x_request_id = x_request_id,
            member_ids = member_ids,
            member_names = member_names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PolicyMemberResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api237_directories_policies_snapshot_post_serialize(
        self,
        policies,
        authorization,
        x_request_id,
        member_ids,
        member_names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_ids': 'csv',
            'member_names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if policies is not None:
            _body_params = policies


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/2.37/directories/policies/snapshot',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api237_directories_post_with_http_info(
        self,
        directory: DirectoryPost,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        file_system_names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the file system name specified. Enter multiple file system names in comma-separated format. For example, `filesystem01,filesystem02`.")] = None,
        file_system_ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the file system ID specified. Enter multiple file system IDs in comma-separated format. The `file_system_ids` or `file_system_names` parameter is required, but they cannot be set together.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[DirectoryResponse]:
        """Create directory

        Creates a managed directory at the specified path. The managed directory name must consist of a file system name prefix and a managed directory name suffix (separated with '&#58;'). The suffix must be between 1 and 63 characters (alphanumeric and '-') in length and begin and end with a letter or number. The suffix must include at least one letter or '-'. Set `names` to create a managed directory with the specified full managed directory name, or set `file_system_names` or `file_system_ids` in the query parameters and `suffix` in the body parameters to create a managed directory in the specified file system with the specified suffix. These two options are exclusive.

        :param directory: (required)
        :type directory: DirectoryPost
        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param file_system_names: Performs the operation on the file system name specified. Enter multiple file system names in comma-separated format. For example, `filesystem01,filesystem02`.
        :type file_system_names: List[str]
        :param file_system_ids: Performs the operation on the file system ID specified. Enter multiple file system IDs in comma-separated format. The `file_system_ids` or `file_system_names` parameter is required, but they cannot be set together.
        :type file_system_ids: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api237_directories_post_serialize(
            directory = directory,
            authorization = authorization,
            x_request_id = x_request_id,
            names = names,
            file_system_names = file_system_names,
            file_system_ids = file_system_ids,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DirectoryResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api237_directories_post_serialize(
        self,
        directory,
        authorization,
        x_request_id,
        names,
        file_system_names,
        file_system_ids,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'names': 'csv',
            'file_system_names': 'csv',
            'file_system_ids': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if names is not None:
            
            _query_params.append(('names', names))
            
        if file_system_names is not None:
            
            _query_params.append(('file_system_names', file_system_names))
            
        if file_system_ids is not None:
            
            _query_params.append(('file_system_ids', file_system_ids))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if directory is not None:
            _body_params = directory


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/2.37/directories',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api237_directories_space_get_with_http_info(
        self,
        authorization: Annotated[Optional[StrictStr], Field(description="Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)")] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Narrows down the results to only the response objects that satisfy the filter criteria.")] = None,
        end_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        resolution: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The number of milliseconds between samples of historical data. For array-wide performance metrics (`/arrays/performance` endpoint), valid values are `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For performance metrics on storage objects (`<object name>/performance` endpoint), such as volumes, valid values are `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For space metrics, (`<object name>/space` endpoint), valid values are `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). Include the `start_time` parameter to display the performance data starting at the specified start time. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. Include the `end_time` parameter to display the performance data until the specified end time. If `end_time`is not specified, the end time will default to the current time. If the `resolution` parameter is not specified but either the `start_time` or `end_time` parameter is, then `resolution` will default to the lowest valid resolution.")] = None,
        start_time: Annotated[Optional[StrictInt], Field(description="Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The starting position based on the results of the query in relation to the full set of response objects returned.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[ResourceDirectorySpaceGetResponse]:
        """List directory space information

        Displays physical storage consumption data for each directory.

        :param authorization: Access token (in JWT format) required to use any API endpoint (except `/oauth2`, `/login`, and `/logout`)
        :type authorization: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. For destroyed objects, the time remaining is displayed in milliseconds.
        :type destroyed: bool
        :param filter: Narrows down the results to only the response objects that satisfy the filter criteria.
        :type filter: str
        :param end_time: Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.
        :type end_time: int
        :param resolution: The number of milliseconds between samples of historical data. For array-wide performance metrics (`/arrays/performance` endpoint), valid values are `1000` (1 second), `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For performance metrics on storage objects (`<object name>/performance` endpoint), such as volumes, valid values are `30000` (30 seconds), `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). For space metrics, (`<object name>/space` endpoint), valid values are `300000` (5 minutes), `1800000` (30 minutes), `7200000` (2 hours), `28800000` (8 hours), and `86400000` (24 hours). Include the `start_time` parameter to display the performance data starting at the specified start time. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. Include the `end_time` parameter to display the performance data until the specified end time. If `end_time`is not specified, the end time will default to the current time. If the `resolution` parameter is not specified but either the `start_time` or `end_time` parameter is, then `resolution` will default to the lowest valid resolution.
        :type resolution: int
        :param start_time: Displays historical performance data for the specified time window, where `start_time` is the beginning of the time window, and `end_time` is the end of the time window. The `start_time` and `end_time` parameters are specified in milliseconds since the UNIX epoch. If `start_time` is not specified, the start time will default to one resolution before the end time, meaning that the most recent sample of performance data will be displayed. If `end_time`is not specified, the end time will default to the current time. Include the `resolution` parameter to display the performance data at the specified resolution. If not specified, `resolution` defaults to the lowest valid resolution.
        :type start_time: int
        :param ids: Performs the operation on the unique resource IDs specified. Enter multiple resource IDs in comma-separated format. The `ids` or `names` parameter is required, but they cannot be set together.
        :type ids: List[str]
        :param limit: Limits the size of the response to the specified number of objects on each page. To return the total number of resources, set `limit=0`. The total number of resources is returned as a `total_item_count` value. If the page size requested is larger than the system maximum limit, the server returns the maximum limit, disregarding the requested page size.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The starting position based on the results of the query in relation to the full set of response objects returned.
        :type offset: int
        :param sort: Returns the response objects in the order specified. Set `sort` to the name in the response by which to sort. Sorting can be performed on any of the names in the response, and the objects can be sorted in ascending or descending order. By default, the response objects are sorted in ascending order. To sort in descending order, append the minus sign (`-`) to the name. A single request can be sorted on multiple objects. For example, you can sort all volumes from largest to smallest volume size, and then sort volumes of the same size in ascending order by volume name. To sort on multiple names, list the names as comma-separated values.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.
        :type total_item_count: bool
        :param total_only: If set to `true`, returns the aggregate value of all items after filtering. Where it makes more sense, the average value is displayed instead. The values are displayed for each name where meaningful. If `total_only=true`, the `items` list will be empty.
        :type total_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api237_directories_space_get_serialize(
            authorization = authorization,
            x_request_id = x_request_id,
            destroyed = destroyed,
            filter = filter,
            end_time = end_time,
            resolution = resolution,
            start_time = start_time,
            ids = ids,
            limit = limit,
            names = names,
            offset = offset,
            sort = sort,
            total_item_count = total_item_count,
            total_only = total_only,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResourceDirectorySpaceGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api237_directories_space_get_serialize(
        self,
        authorization,
        x_request_id,
        destroyed,
        filter,
        end_time,
        resolution,
        start_time,
        ids,
        limit,
        names,
        offset,
        sort,
        total_item_count,
        total_only,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
            'names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if destroyed is not None:
            
            _query_params.append(('destroyed', destroyed))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if end_time is not None:
            
            _query_params.append(('end_time', end_time))
            
        if resolution is not None:
            
            _query_params.append(('resolution', resolution))
            
        if start_time is not None:
            
            _query_params.append(('start_time', start_time))
            
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if names is not None:
            
            _query_params.append(('names', names))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if total_item_count is not None:
            
            _query_params.append(('total_item_count', total_item_count))
            
        if total_only is not None:
            
            _query_params.append(('total_only', total_only))
            
        # process the header parameters
        if authorization is not None:
            _header_params['Authorization'] = authorization
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.37/directories/space',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )

# coding: utf-8

"""
    FlashBlade REST API

    A lightweight client for FlashBlade REST API 2.5, developed by Pure Storage, Inc. (http://www.purestorage.com/).

    The version of the OpenAPI document: 2.5
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from pypureclient.flashblade.FB_2_5.models.file_system_replica_link import FileSystemReplicaLink
from pypureclient.flashblade.FB_2_5.models.file_system_replica_link_get_response import FileSystemReplicaLinkGetResponse
from pypureclient.flashblade.FB_2_5.models.file_system_replica_link_response import FileSystemReplicaLinkResponse
from pypureclient.flashblade.FB_2_5.models.file_system_snapshot_get_transfer_response import FileSystemSnapshotGetTransferResponse
from pypureclient.flashblade.FB_2_5.models.policy_member_with_remote_get_response import PolicyMemberWithRemoteGetResponse
from pypureclient.flashblade.FB_2_5.models.policy_member_with_remote_response import PolicyMemberWithRemoteResponse
from pypureclient.flashblade.FB_2_5.api_client import ApiClient as _TransportApiClient, RequestSerialized
from pypureclient.flashblade.FB_2_5.api_response import ApiResponse
from pypureclient.flashblade.FB_2_5.rest import RESTResponseType


class FileSystemReplicaLinksApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client: Optional[_TransportApiClient] = None) -> None:
        self.api_client = api_client if api_client else _TransportApiClient.get_default()


    @validate_call
    def api25_file_system_replica_links_get_with_http_info(
        self,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        local_file_system_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The offset of the first resource to return from a collection.")] = None,
        remote_file_system_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote file system IDs. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_names` query parameter.")] = None,
        remote_file_system_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_ids` query parameter.")] = None,
        remote_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[FileSystemReplicaLinkGetResponse]:
        """GET file-system-replica-links

        List file system replication link.

        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.
        :type limit: int
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.
        :type local_file_system_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param remote_file_system_ids: A comma-separated list of remote file system IDs. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_names` query parameter.
        :type remote_file_system_ids: List[str]
        :param remote_file_system_names: A comma-separated list of remote file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_ids` query parameter.
        :type remote_file_system_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api25_file_system_replica_links_get_serialize(
            continuation_token = continuation_token,
            filter = filter,
            ids = ids,
            limit = limit,
            local_file_system_ids = local_file_system_ids,
            local_file_system_names = local_file_system_names,
            offset = offset,
            remote_file_system_ids = remote_file_system_ids,
            remote_file_system_names = remote_file_system_names,
            remote_ids = remote_ids,
            remote_names = remote_names,
            sort = sort,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileSystemReplicaLinkGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api25_file_system_replica_links_get_serialize(
        self,
        continuation_token,
        filter,
        ids,
        limit,
        local_file_system_ids,
        local_file_system_names,
        offset,
        remote_file_system_ids,
        remote_file_system_names,
        remote_ids,
        remote_names,
        sort,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
            'local_file_system_ids': 'csv',
            'local_file_system_names': 'csv',
            'remote_file_system_ids': 'csv',
            'remote_file_system_names': 'csv',
            'remote_ids': 'csv',
            'remote_names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if local_file_system_ids is not None:
            
            _query_params.append(('local_file_system_ids', local_file_system_ids))
            
        if local_file_system_names is not None:
            
            _query_params.append(('local_file_system_names', local_file_system_names))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if remote_file_system_ids is not None:
            
            _query_params.append(('remote_file_system_ids', remote_file_system_ids))
            
        if remote_file_system_names is not None:
            
            _query_params.append(('remote_file_system_names', remote_file_system_names))
            
        if remote_ids is not None:
            
            _query_params.append(('remote_ids', remote_ids))
            
        if remote_names is not None:
            
            _query_params.append(('remote_names', remote_names))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.5/file-system-replica-links',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api25_file_system_replica_links_policies_delete_with_http_info(
        self,
        local_file_system_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy names.")] = None,
        remote_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[None]:
        """DELETE file-system-replica-links/policies

        Remove a policy from a file system replication link.

        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.
        :type member_ids: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api25_file_system_replica_links_policies_delete_serialize(
            local_file_system_ids = local_file_system_ids,
            local_file_system_names = local_file_system_names,
            member_ids = member_ids,
            policy_ids = policy_ids,
            policy_names = policy_names,
            remote_ids = remote_ids,
            remote_names = remote_names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api25_file_system_replica_links_policies_delete_serialize(
        self,
        local_file_system_ids,
        local_file_system_names,
        member_ids,
        policy_ids,
        policy_names,
        remote_ids,
        remote_names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'local_file_system_ids': 'csv',
            'local_file_system_names': 'csv',
            'member_ids': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
            'remote_ids': 'csv',
            'remote_names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if local_file_system_ids is not None:
            
            _query_params.append(('local_file_system_ids', local_file_system_ids))
            
        if local_file_system_names is not None:
            
            _query_params.append(('local_file_system_names', local_file_system_names))
            
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        if remote_ids is not None:
            
            _query_params.append(('remote_ids', remote_ids))
            
        if remote_names is not None:
            
            _query_params.append(('remote_names', remote_names))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/2.5/file-system-replica-links/policies',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api25_file_system_replica_links_policies_get_with_http_info(
        self,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        local_file_system_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy names.")] = None,
        remote_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_file_system_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote file system IDs. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_names` query parameter.")] = None,
        remote_file_system_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_ids` query parameter.")] = None,
        remote_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[PolicyMemberWithRemoteGetResponse]:
        """GET file-system-replica-links/policies

        List file system replication link policies.

        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.
        :type limit: int
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.
        :type member_ids: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.
        :type remote_ids: List[str]
        :param remote_file_system_ids: A comma-separated list of remote file system IDs. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_names` query parameter.
        :type remote_file_system_ids: List[str]
        :param remote_file_system_names: A comma-separated list of remote file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_ids` query parameter.
        :type remote_file_system_names: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api25_file_system_replica_links_policies_get_serialize(
            continuation_token = continuation_token,
            filter = filter,
            limit = limit,
            local_file_system_ids = local_file_system_ids,
            local_file_system_names = local_file_system_names,
            member_ids = member_ids,
            offset = offset,
            policy_ids = policy_ids,
            policy_names = policy_names,
            remote_ids = remote_ids,
            remote_file_system_ids = remote_file_system_ids,
            remote_file_system_names = remote_file_system_names,
            remote_names = remote_names,
            sort = sort,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PolicyMemberWithRemoteGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api25_file_system_replica_links_policies_get_serialize(
        self,
        continuation_token,
        filter,
        limit,
        local_file_system_ids,
        local_file_system_names,
        member_ids,
        offset,
        policy_ids,
        policy_names,
        remote_ids,
        remote_file_system_ids,
        remote_file_system_names,
        remote_names,
        sort,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'local_file_system_ids': 'csv',
            'local_file_system_names': 'csv',
            'member_ids': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
            'remote_ids': 'csv',
            'remote_file_system_ids': 'csv',
            'remote_file_system_names': 'csv',
            'remote_names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if local_file_system_ids is not None:
            
            _query_params.append(('local_file_system_ids', local_file_system_ids))
            
        if local_file_system_names is not None:
            
            _query_params.append(('local_file_system_names', local_file_system_names))
            
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        if remote_ids is not None:
            
            _query_params.append(('remote_ids', remote_ids))
            
        if remote_file_system_ids is not None:
            
            _query_params.append(('remote_file_system_ids', remote_file_system_ids))
            
        if remote_file_system_names is not None:
            
            _query_params.append(('remote_file_system_names', remote_file_system_names))
            
        if remote_names is not None:
            
            _query_params.append(('remote_names', remote_names))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.5/file-system-replica-links/policies',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api25_file_system_replica_links_policies_post_with_http_info(
        self,
        local_file_system_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy names.")] = None,
        remote_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[PolicyMemberWithRemoteResponse]:
        """POST file-system-replica-links/policies

        Add a policy to a file system replication link.

        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.
        :type member_ids: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api25_file_system_replica_links_policies_post_serialize(
            local_file_system_ids = local_file_system_ids,
            local_file_system_names = local_file_system_names,
            member_ids = member_ids,
            policy_ids = policy_ids,
            policy_names = policy_names,
            remote_ids = remote_ids,
            remote_names = remote_names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PolicyMemberWithRemoteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api25_file_system_replica_links_policies_post_serialize(
        self,
        local_file_system_ids,
        local_file_system_names,
        member_ids,
        policy_ids,
        policy_names,
        remote_ids,
        remote_names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'local_file_system_ids': 'csv',
            'local_file_system_names': 'csv',
            'member_ids': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
            'remote_ids': 'csv',
            'remote_names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if local_file_system_ids is not None:
            
            _query_params.append(('local_file_system_ids', local_file_system_ids))
            
        if local_file_system_names is not None:
            
            _query_params.append(('local_file_system_names', local_file_system_names))
            
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        if remote_ids is not None:
            
            _query_params.append(('remote_ids', remote_ids))
            
        if remote_names is not None:
            
            _query_params.append(('remote_names', remote_names))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/2.5/file-system-replica-links/policies',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api25_file_system_replica_links_post_with_http_info(
        self,
        file_system_replica_link: FileSystemReplicaLink,
        ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        local_file_system_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        remote_file_system_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_ids` query parameter.")] = None,
        remote_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[FileSystemReplicaLinkResponse]:
        """POST file-system-replica-links

        Create a file system replication link.

        :param file_system_replica_link: (required)
        :type file_system_replica_link: FileSystemReplicaLink
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.
        :type ids: List[str]
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.
        :type local_file_system_names: List[str]
        :param remote_file_system_names: A comma-separated list of remote file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_ids` query parameter.
        :type remote_file_system_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api25_file_system_replica_links_post_serialize(
            file_system_replica_link = file_system_replica_link,
            ids = ids,
            local_file_system_ids = local_file_system_ids,
            local_file_system_names = local_file_system_names,
            remote_file_system_names = remote_file_system_names,
            remote_ids = remote_ids,
            remote_names = remote_names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileSystemReplicaLinkResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api25_file_system_replica_links_post_serialize(
        self,
        file_system_replica_link,
        ids,
        local_file_system_ids,
        local_file_system_names,
        remote_file_system_names,
        remote_ids,
        remote_names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
            'local_file_system_ids': 'csv',
            'local_file_system_names': 'csv',
            'remote_file_system_names': 'csv',
            'remote_ids': 'csv',
            'remote_names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if local_file_system_ids is not None:
            
            _query_params.append(('local_file_system_ids', local_file_system_ids))
            
        if local_file_system_names is not None:
            
            _query_params.append(('local_file_system_names', local_file_system_names))
            
        if remote_file_system_names is not None:
            
            _query_params.append(('remote_file_system_names', remote_file_system_names))
            
        if remote_ids is not None:
            
            _query_params.append(('remote_ids', remote_ids))
            
        if remote_names is not None:
            
            _query_params.append(('remote_names', remote_names))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if file_system_replica_link is not None:
            _body_params = file_system_replica_link


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/2.5/file-system-replica-links',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api25_file_system_replica_links_transfer_get_with_http_info(
        self,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names_or_owner_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource names. Either the names of the snapshots or the owning file systems.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The offset of the first resource to return from a collection.")] = None,
        remote_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[FileSystemSnapshotGetTransferResponse]:
        """GET file-system-replica-links/transfer

        List the transfer status details for file system replication.

        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.
        :type limit: int
        :param names_or_owner_names: A comma-separated list of resource names. Either the names of the snapshots or the owning file systems.
        :type names_or_owner_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api25_file_system_replica_links_transfer_get_serialize(
            continuation_token = continuation_token,
            filter = filter,
            ids = ids,
            limit = limit,
            names_or_owner_names = names_or_owner_names,
            offset = offset,
            remote_ids = remote_ids,
            remote_names = remote_names,
            sort = sort,
            total_only = total_only,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileSystemSnapshotGetTransferResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api25_file_system_replica_links_transfer_get_serialize(
        self,
        continuation_token,
        filter,
        ids,
        limit,
        names_or_owner_names,
        offset,
        remote_ids,
        remote_names,
        sort,
        total_only,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
            'names_or_owner_names': 'csv',
            'remote_ids': 'csv',
            'remote_names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if names_or_owner_names is not None:
            
            _query_params.append(('names_or_owner_names', names_or_owner_names))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if remote_ids is not None:
            
            _query_params.append(('remote_ids', remote_ids))
            
        if remote_names is not None:
            
            _query_params.append(('remote_names', remote_names))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if total_only is not None:
            
            _query_params.append(('total_only', total_only))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.5/file-system-replica-links/transfer',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )

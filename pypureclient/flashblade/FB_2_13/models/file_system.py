# coding: utf-8

"""
    FlashBlade REST API

    A lightweight client for FlashBlade REST API 2.13, developed by Pure Storage, Inc. (http://www.purestorage.com/).

    The version of the OpenAPI document: 2.13
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from pypureclient.flashblade.FB_2_13.models.http import Http
from pypureclient.flashblade.FB_2_13.models.location_reference import LocationReference
from pypureclient.flashblade.FB_2_13.models.multi_protocol import MultiProtocol
from pypureclient.flashblade.FB_2_13.models.nfs import Nfs
from pypureclient.flashblade.FB_2_13.models.smb import Smb
from pypureclient.flashblade.FB_2_13.models.space import Space
from typing import Optional, Set
from typing_extensions import Self

class FileSystem(BaseModel):
    """
    FileSystem
    """ # noqa: E501
    name: Optional[StrictStr] = Field(default=None, description="Name of the object (e.g., a file system or snapshot).")
    id: Optional[StrictStr] = Field(default=None, description="A non-modifiable, globally unique ID chosen by the system.")
    created: Optional[StrictInt] = Field(default=None, description="Creation timestamp of the file system.")
    default_group_quota: Optional[StrictInt] = Field(default=None, description="The default space quota for a group writing to this file system.")
    default_user_quota: Optional[StrictInt] = Field(default=None, description="The default space quota for a user writing to this file system.")
    destroyed: Optional[StrictBool] = Field(default=None, description="Returns a value of `true` if the file system has been destroyed and is pending eradication. The file system cannot be modified while it is in the destroyed state. The `time_remaining` value displays the amount of time left until the destroyed file system is permanently eradicated. Once eradication has begun, the file system can no longer be recovered. Before the `time_remaining` period has elapsed, the destroyed file system can be recovered through the PATCH method by setting `destroyed=false`.")
    fast_remove_directory_enabled: Optional[StrictBool] = Field(default=None, description="If set to `true`, the file system, when mounted, will contain a directory that can be used for fast removal of other directories. Directories can be moved into the fast remove directory in order to have them deleted, and their space freed, more quickly than a normal removal operation.")
    hard_limit_enabled: Optional[StrictBool] = Field(default=None, description="If set to `true`, the file system's size, as defined by `provisioned`, is used as a hard limit quota.")
    http: Optional[Http] = Field(default=None, description="HTTP configuration.")
    multi_protocol: Optional[MultiProtocol] = Field(default=None, description="Multi-protocol configuration.")
    nfs: Optional[Nfs] = Field(default=None, description="NFS configuration.")
    provisioned: Optional[StrictInt] = Field(default=None, description="The provisioned size of the file system, displayed in bytes. If set to an empty string (`\"\"`), the file system is unlimited in size.")
    promotion_status: Optional[StrictStr] = Field(default=None, description="Possible values are `promoted` and `demoted`. The current status of the file system with respect to replication. Changes via `requested_promotion_state`. The default for new file systems is `promoted`.")
    requested_promotion_state: Optional[StrictStr] = Field(default=None, description="Possible values are `promoted` and `demoted`. The `demoted` state is used for replication targets and is only allowed to be set if the file system is in a replica-link relationship. The additional query param `discard-non-snapshotted-data` must be set to `true` when demoting a file system. The default for new file systems is `promoted`.")
    smb: Optional[Smb] = Field(default=None, description="SMB configuration.")
    snapshot_directory_enabled: Optional[StrictBool] = Field(default=None, description="If set to `true`, a hidden .snapshot directory will be present in each directory of the file system when it is mounted. The .snapshot directory allows clients read access to the contents of the snapshots that have been taken of a directory. If set to `false`, the .snapshot directory will not be present in any directories within a mounted file system.")
    source: Optional[LocationReference] = Field(default=None, description="A reference to the source file system.")
    space: Optional[Space] = Field(default=None, description="The space usage of the file system.")
    time_remaining: Optional[StrictInt] = Field(default=None, description="Time in milliseconds before the file system is eradicated. `null` if not destroyed.")
    writable: Optional[StrictBool] = Field(default=None, description="Whether the file system is writable or not. If `false`, this overrides any protocol or file permission settings and prevents changes. If `true`, then the protocol and file permission settings are evaluated. If not specified, defaults to `true`. Modifiable.")
    group_ownership: Optional[StrictStr] = Field(default=None, description="The group ownership for new files and directories in a file system. Possible values are `creator` and `parent-directory`. If `creator` is selected, the owning group of new files and directories is the primary group of the user who creates them. If `parent-directory` is selected, the owning group is the parent directory group. Note: Existing files and directories are unaffected by this change.")
    __properties: ClassVar[List[str]] = ["name", "id", "created", "default_group_quota", "default_user_quota", "destroyed", "fast_remove_directory_enabled", "hard_limit_enabled", "http", "multi_protocol", "nfs", "provisioned", "promotion_status", "requested_promotion_state", "smb", "snapshot_directory_enabled", "source", "space", "time_remaining", "writable", "group_ownership"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    def to_dict(self, include_readonly: bool = False) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.

        * OpenAPI `readOnly` fields are excluded, if `include_readonly` is `False`.
        """
        excluded_fields: Set[str] = set([
            "name",
            "id",
            "created",
            "promotion_status",
            "time_remaining",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=set() if include_readonly else excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of http
        if self.http and (include_readonly or "http" not in excluded_fields):
            _dict['http'] = self.http.to_dict()
        # override the default output from pydantic by calling `to_dict()` of multi_protocol
        if self.multi_protocol and (include_readonly or "multi_protocol" not in excluded_fields):
            _dict['multi_protocol'] = self.multi_protocol.to_dict()
        # override the default output from pydantic by calling `to_dict()` of nfs
        if self.nfs and (include_readonly or "nfs" not in excluded_fields):
            _dict['nfs'] = self.nfs.to_dict()
        # override the default output from pydantic by calling `to_dict()` of smb
        if self.smb and (include_readonly or "smb" not in excluded_fields):
            _dict['smb'] = self.smb.to_dict()
        # override the default output from pydantic by calling `to_dict()` of source
        if self.source and (include_readonly or "source" not in excluded_fields):
            _dict['source'] = self.source.to_dict()
        # override the default output from pydantic by calling `to_dict()` of space
        if self.space and (include_readonly or "space" not in excluded_fields):
            _dict['space'] = self.space.to_dict()
        return _dict

    def __getitem__(self, key):
        return getattr(self, key)

    def __setitem__(self, key, value):
        setattr(self, key, value)

    def __delitem__(self, key):
        setattr(self, key, None)

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of FileSystem from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of FileSystem from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_construct(_fields_set=None, **{
            "name": obj.get("name"),
            "id": obj.get("id"),
            "created": obj.get("created"),
            "default_group_quota": obj.get("default_group_quota"),
            "default_user_quota": obj.get("default_user_quota"),
            "destroyed": obj.get("destroyed"),
            "fast_remove_directory_enabled": obj.get("fast_remove_directory_enabled"),
            "hard_limit_enabled": obj.get("hard_limit_enabled"),
            "http": Http.from_dict(obj["http"]) if obj.get("http") is not None else None,
            "multi_protocol": MultiProtocol.from_dict(obj["multi_protocol"]) if obj.get("multi_protocol") is not None else None,
            "nfs": Nfs.from_dict(obj["nfs"]) if obj.get("nfs") is not None else None,
            "provisioned": obj.get("provisioned"),
            "promotion_status": obj.get("promotion_status"),
            "requested_promotion_state": obj.get("requested_promotion_state"),
            "smb": Smb.from_dict(obj["smb"]) if obj.get("smb") is not None else None,
            "snapshot_directory_enabled": obj.get("snapshot_directory_enabled"),
            "source": LocationReference.from_dict(obj["source"]) if obj.get("source") is not None else None,
            "space": Space.from_dict(obj["space"]) if obj.get("space") is not None else None,
            "time_remaining": obj.get("time_remaining"),
            "writable": obj.get("writable"),
            "group_ownership": obj.get("group_ownership")
        })
        return _obj



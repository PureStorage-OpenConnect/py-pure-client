import json
import ssl
import time
import urllib3
import uuid
import warnings
import os
import re
import tempfile

from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

try:
    from pydantic.v1 import Field, StrictBool, StrictFloat, StrictInt, StrictStr, conint, conlist, constr, validator
except ModuleNotFoundError:
    from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, conint, conlist, constr, validator


from pypureclient.reference_type import ReferenceType
from pypureclient.api_token_manager import APITokenManager
from pypureclient.exceptions import PureError
from pypureclient.keywords import Headers, Responses
from pypureclient.properties import Property, Filter
from pypureclient.responses import ValidResponse, ErrorResponse, ApiError, ItemIterator, ResponseHeaders
from pypureclient.token_manager import TokenManager

from pypureclient._helpers import create_api_client

from pypureclient._transport.api_client import ApiClient
from pypureclient._transport.api_response import ApiResponse
from pypureclient._transport.rest import ApiException
from pypureclient._transport.configuration import Configuration

from . import api
from . import models


class Client(object):

    def __init__(self,
                 configuration: Configuration,
                 id_token: str = None,
                 private_key_file: str = None,
                 private_key_password: str = None,
                 username: str = None,
                 client_id: str = None,
                 key_id: str = None,
                 issuer: str = None,
                 api_token: str = None,
                 retries: int = None,
                 timeout: Union[int, Tuple[float, float]] = None,
                 user_agent = None):
        """
        Initialize a FlashBlade Client. id_token is generated based on app ID and private
        key info. Either id_token or api_token could be used for authentication. Only one
        authentication option is allowed.

        :param configuration: configuration object
        :type configuration: Configuration

        :param id_token: The security token that represents the identity of the party on
            behalf of whom the request is being made, issued by an enabled
            API client on the array. Overrides given private key.
        :type id_token: str, optional

        :param private_key_file: The path of the private key to use. Defaults to None.
        :type private_key_file: str, optional

        :param private_key_password: The password of the private key. Defaults to None.
        :type private_key_password: str, optional

        :param username: Username of the user the token should be issued for. This must
            be a valid user in the system.
        :type username: str, optional

        :param client_id: ID of API client that issued the identity token.
        :type client_id: str, optional

        :param key_id: Key ID of API client that issued the identity token.
        :type key_id: str, optional

        :param issuer: API client's trusted identity issuer on the array.
        :type issuer: str, optional

        :param api_token: API token for the user.
        :type api_token: str, optional

        :param retries: The number of times to retry an API call if it fails for a
            non-blocking reason
        :type retries: int, optional

        :param timeout: The timeout duration in seconds, either in total time or
            (connect and read) times. Defaults to None.
        :type timeout: int or (float, float), optional

        :param user_agent: User-Agent request header to use.
        :type user_agent: str, optional

        :raises PureError: If it could not create an ID or access token
        """

        if id_token and api_token:
            raise PureError("Only one authentication option is allowed. Please use either id_token or api_token and try again!")
        elif private_key_file and private_key_password and username and \
                key_id and client_id and issuer and api_token:
            raise PureError("id_token is generated based on app ID and private key info. Please use either id_token or api_token and try again!")
        elif api_token:
            self._token_man = APITokenManager(
                api_token=api_token,
                user_agent=user_agent,
                timeout=timeout,
                configuration=configuration
            )
        else:
            headers = {
                'kid': key_id
            }
            payload = {
                'iss': issuer,
                'aud': client_id,
                'sub': username,
            }
            self._token_man = TokenManager(configuration=configuration,
                                           id_token=id_token,
                                           private_key_file=private_key_file,
                                           private_key_password=private_key_password,
                                           payload=payload,
                                           headers=headers,
                                           timeout=timeout,
                                           user_agent=user_agent)

        self._api_client = create_api_client(configuration=configuration, user_agent=user_agent, _models_package=models)
        self._set_auth_header()

        # Read timeout and retries
        self._retries = retries
        self._timeout = timeout
        self.__apis_instances = {
            'AuthorizationApi': api.AuthorizationApi(self._api_client)
        }

    def __del__(self):
        # Cleanup this REST API client resources
        _api_client_attr = getattr(self, '_api_client', None) # using getattr to avoid raising exception, if we failed too early
        if _api_client_attr:
            _api_client_attr.close()

    def get_access_token(self, refresh=False):
        """
        Get the last used access token.

        Args:
            refresh (bool, optional):
                Whether to retrieve a new access token. Defaults to False.

        Returns:
            str

        Raises:
            PureError: If there was an error retrieving an access token.
        """
        return self._token_man.get_access_token(refresh)

    def disable_verify_ssl(self):
        """ Change our certificate requirements so that a certificate is not validated. """
        self._api_client.rest_client.pool_manager.connection_pool_kw['cert_reqs'] = ssl.CERT_NONE

    def enable_verify_ssl(self, ca_certs_file_path=None):
        """ Change our certificate requirements so that a certificate is required and validated.
        Optionally, if a CA certificate(s) file path is provided, configure the client to use
        that CA certificate file.
        """
        if ca_certs_file_path:
            self.configure_ca_certificate_file(ca_certs_file_path)
        self._api_client.rest_client.pool_manager.connection_pool_kw['cert_reqs'] = ssl.CERT_REQUIRED

    def configure_ca_certificate_file(self, ca_certs_file_path):
        """"
        :param ca_certs_file_path: The path to the CA certificate(s) file to use.
        :return:
        """
        self._api_client.rest_client.pool_manager.connection_pool_kw['ca_certs'] = ca_certs_file_path

    def delete_api_clients(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE api-clients
        
        Delete the API client.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('APIClientsApi', 'api26_api_clients_delete_with_http_info', kwargs)

    def get_api_clients(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET api-clients
        
        List an API client and its configuration attributes.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('APIClientsApi', 'api26_api_clients_get_with_http_info', kwargs)

    def patch_api_clients(
        self,
        api_clients: 'models.ApiClient',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH api-clients
        
        Modify an API client. Newly created API clients can be enabled by setting the `enabled` parameter to `true`.
        
        :param api_clients: (required)
        :type api_clients: ApiClient
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            api_clients=api_clients,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('APIClientsApi', 'api26_api_clients_patch_with_http_info', kwargs)

    def post_api_clients(
        self,
        api_client: 'models.ApiClientsPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST api-clients
        
        Create an API client to authorize Access Token or Bearer Tokens for use on the array. Required fields include `issuer`, `public_key`, and `access_token_ttl_in_ms`. After creating an API client, it can only be enabled by an authorized user.
        
        :param api_client: (required)
        :type api_client: ApiClientsPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            api_client=api_client,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('APIClientsApi', 'api26_api_clients_post_with_http_info', kwargs)

    def delete_active_directory(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        local_only: Annotated[Optional[StrictBool], Field(description="If specified as `true`, only delete the Active Directory configuration on the local array, without deleting the computer account created in the Active Directory domain. If not specified, defaults to `false`.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE active-directory
        
        Delete an Active Directory account.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param local_only: If specified as `true`, only delete the Active Directory configuration on the
                        local array, without deleting the computer account created in the Active
                        Directory domain. If not specified, defaults to `false`.
        :type local_only: bool
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            local_only=local_only,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('ActiveDirectoryApi', 'api26_active_directory_delete_with_http_info', kwargs)

    def get_active_directory(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET active-directory
        
        List an Active Directory account and its configuration.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('ActiveDirectoryApi', 'api26_active_directory_get_with_http_info', kwargs)

    def patch_active_directory(
        self,
        active_directory: 'models.ActiveDirectoryPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH active-directory
        
        Modify the configuration of an Active Directory account.
        
        :param active_directory: (required)
        :type active_directory: ActiveDirectoryPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            active_directory=active_directory,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('ActiveDirectoryApi', 'api26_active_directory_patch_with_http_info', kwargs)

    def post_active_directory(
        self,
        active_directory: 'models.ActiveDirectoryPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        join_existing_account: Annotated[Optional[StrictBool], Field(description="If specified as `true`, the domain is searched for a pre-existing computer account to join to, and no new account will be created within the domain. The `user` specified when joining to a pre-existing account must have permissions to 'read attributes from' and 'reset the password of' the pre-existing account. `service_principal_names`, `encryption_types`, and `join_ou` will be read from the pre-existing account and cannot be specified when joining to an existing account. If not specified, defaults to `false`.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST active-directory
        
        Join an Active Directory domain and generate keytabs for the registered SPNs and supported encryption types.
        
        :param active_directory: (required)
        :type active_directory: ActiveDirectoryPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param join_existing_account: If specified as `true`, the domain is searched for a pre-existing computer
                                    account to join to, and no new account will be created within the domain.
                                    The `user` specified when joining to a pre-existing account must have
                                    permissions to 'read attributes from' and 'reset the password of' the
                                    pre-existing account. `service_principal_names`, `encryption_types`, and
                                    `join_ou` will be read from the pre-existing account and cannot be
                                    specified when joining to an existing account. If not specified, defaults
                                    to `false`.
        :type join_existing_account: bool
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            active_directory=active_directory,
            join_existing_account=join_existing_account,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('ActiveDirectoryApi', 'api26_active_directory_post_with_http_info', kwargs)

    def get_active_directory_test(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET active-directory/test
        
        Testing if the configuration of an Active Directory account is valid.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('ActiveDirectoryApi', 'api26_active_directory_test_get_with_http_info', kwargs)

    def delete_admins_api_tokens(
        self,
        admins: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        admin_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of admin IDs. If after filtering, there is not at least one admin resource that matches each of the elements, then an error is returned. This cannot be provided together with the `admin_names` query parameter.")] = None,
        admin_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of admin names. If there is not at least one admin resource that matches each of the elements, then an error is returned. This cannot be provided together with `admin_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE admins/api-tokens
        
        Deletes the API tokens of the specified administrators.
        
        :param admins: A list of admins to query for. Overrides admin_ids and admin_names keyword arguments.
        :type admins: ReferenceType or List[ReferenceType], optional
        :param admin_ids: A comma-separated list of admin IDs. If after filtering, there is not at least
                        one admin resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `admin_names` query
                        parameter.
        :type admin_ids: List[str]
        :param admin_names: A comma-separated list of admin names. If there is not at least one admin
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `admin_ids` query parameter.
        :type admin_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            admin_ids=admin_ids,
            admin_names=admin_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(admins, ['admin_ids', 'admin_names'], kwargs)
        _fixup_list_type_params(['admin_ids', 'admin_names'], kwargs)
        return self._call_api('AdministratorsApi', 'api26_admins_api_tokens_delete_with_http_info', kwargs)

    def get_admins_api_tokens(
        self,
        admins: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        admin_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of admin IDs. If after filtering, there is not at least one admin resource that matches each of the elements, then an error is returned. This cannot be provided together with the `admin_names` query parameter.")] = None,
        admin_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of admin names. If there is not at least one admin resource that matches each of the elements, then an error is returned. This cannot be provided together with `admin_ids` query parameter.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        expose_api_token: Annotated[Optional[StrictBool], Field(description="If `true`, exposes the API token of the current user.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET admins/api-tokens
        
        Displays API tokens for the specified administrators.
        
        :param admins: A list of admins to query for. Overrides admin_ids and admin_names keyword arguments.
        :type admins: ReferenceType or List[ReferenceType], optional
        :param admin_ids: A comma-separated list of admin IDs. If after filtering, there is not at least
                        one admin resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `admin_names` query
                        parameter.
        :type admin_ids: List[str]
        :param admin_names: A comma-separated list of admin names. If there is not at least one admin
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `admin_ids` query parameter.
        :type admin_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param expose_api_token: If `true`, exposes the API token of the current user.
        :type expose_api_token: bool
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            admin_ids=admin_ids,
            admin_names=admin_names,
            continuation_token=continuation_token,
            expose_api_token=expose_api_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(admins, ['admin_ids', 'admin_names'], kwargs)
        _fixup_list_type_params(['admin_ids', 'admin_names', 'sort'], kwargs)
        return self._call_api('AdministratorsApi', 'api26_admins_api_tokens_get_with_http_info', kwargs)

    def post_admins_api_tokens(
        self,
        admins: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        admin_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of admin IDs. If after filtering, there is not at least one admin resource that matches each of the elements, then an error is returned. This cannot be provided together with the `admin_names` query parameter.")] = None,
        admin_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of admin names. If there is not at least one admin resource that matches each of the elements, then an error is returned. This cannot be provided together with `admin_ids` query parameter.")] = None,
        timeout: Annotated[Optional[StrictInt], Field(description="The duration of API token validity, in milliseconds.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST admins/api-tokens
        
        Creates API tokens for the specified administrators.
        
        :param admins: A list of admins to query for. Overrides admin_ids and admin_names keyword arguments.
        :type admins: ReferenceType or List[ReferenceType], optional
        :param admin_ids: A comma-separated list of admin IDs. If after filtering, there is not at least
                        one admin resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `admin_names` query
                        parameter.
        :type admin_ids: List[str]
        :param admin_names: A comma-separated list of admin names. If there is not at least one admin
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `admin_ids` query parameter.
        :type admin_names: List[str]
        :param timeout: The duration of API token validity, in milliseconds.
        :type timeout: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            admin_ids=admin_ids,
            admin_names=admin_names,
            timeout=timeout,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(admins, ['admin_ids', 'admin_names'], kwargs)
        _fixup_list_type_params(['admin_ids', 'admin_names'], kwargs)
        return self._call_api('AdministratorsApi', 'api26_admins_api_tokens_post_with_http_info', kwargs)

    def delete_admins_cache(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE admins/cache
        
        Delete cached administrator role information by name or ID.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('AdministratorsApi', 'api26_admins_cache_delete_with_http_info', kwargs)

    def get_admins_cache(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        refresh: Annotated[Optional[StrictBool], Field(description="Whether to refresh the user info from directory service. If not specified, defaults to `false`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET admins/cache
        
        List cached administrator information used to determine role based access control privileges.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param refresh: Whether to refresh the user info from directory service. If not specified,
                        defaults to `false`.
        :type refresh: bool
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            refresh=refresh,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('AdministratorsApi', 'api26_admins_cache_get_with_http_info', kwargs)

    def get_admins(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        expose_api_token: Annotated[Optional[StrictBool], Field(description="If `true`, exposes the API token of the current user.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET admins
        
        List the administrator's attributes, including the API token and public key.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param expose_api_token: If `true`, exposes the API token of the current user.
        :type expose_api_token: bool
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            expose_api_token=expose_api_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('AdministratorsApi', 'api26_admins_get_with_http_info', kwargs)

    def patch_admins(
        self,
        admin: 'models.AdminPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH admins
        
        Modify the attributes of the administrator.
        
        :param admin: (required)
        :type admin: AdminPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            admin=admin,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('AdministratorsApi', 'api26_admins_patch_with_http_info', kwargs)

    def get_admins_settings(
        self,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List global admin settings
        
        Return global admin settings.
        
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('AdministratorsApi', 'api26_admins_settings_get_with_http_info', kwargs)

    def patch_admins_settings(
        self,
        admin_setting: 'models.AdminSetting',
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Update global admin settings
        
        Update properties for global admin settings.
        
        :param admin_setting: (required)
        :type admin_setting: AdminSetting
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            admin_setting=admin_setting,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('AdministratorsApi', 'api26_admins_settings_patch_with_http_info', kwargs)

    def delete_alert_watchers(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE alert-watchers
        
        Delete an alert watcher.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('AlertWatchersApi', 'api26_alert_watchers_delete_with_http_info', kwargs)

    def get_alert_watchers(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET alert-watchers
        
        List alert watchers that are configured to receive alert messages.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('AlertWatchersApi', 'api26_alert_watchers_get_with_http_info', kwargs)

    def patch_alert_watchers(
        self,
        alert_watcher: 'models.AlertWatcher',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH alert-watchers
        
        Modify an alert watchers configuration. Enable or disable an alert watcher privilege and select the level of alert notification of an alert watcher. Alert notification levels are `info`, `warning`, or `critical`.
        
        :param alert_watcher: (required)
        :type alert_watcher: AlertWatcher
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            alert_watcher=alert_watcher,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('AlertWatchersApi', 'api26_alert_watchers_patch_with_http_info', kwargs)

    def post_alert_watchers(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        alert_watcher: Optional['models.AlertWatcherPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST alert-watchers
        
        Create an alert watcher to receive array alert messages.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param alert_watcher:
        :type alert_watcher: AlertWatcherPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            alert_watcher=alert_watcher,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('AlertWatchersApi', 'api26_alert_watchers_post_with_http_info', kwargs)

    def get_alert_watchers_test(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET alert-watchers/test
        
        Test an alert watcher's contact information to verify alerts can be sent and received.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            names=names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('AlertWatchersApi', 'api26_alert_watchers_test_get_with_http_info', kwargs)

    def get_alerts(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET alerts
        
        Returns a list of alerts which have been generated by the array.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('AlertsApi', 'api26_alerts_get_with_http_info', kwargs)

    def patch_alerts(
        self,
        alerts_settings: 'models.Alert',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH alerts
        
        Make changes to an alert. This is currently limited to the alert's `flagged` property.
        
        :param alerts_settings: (required)
        :type alerts_settings: Alert
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            alerts_settings=alerts_settings,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('AlertsApi', 'api26_alerts_patch_with_http_info', kwargs)

    def get_array_connections_connection_key(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET array-connections/connection-key
        
        List connection keys used to authenticate the connection from one array to another.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api26_array_connections_connection_key_get_with_http_info', kwargs)

    def post_array_connections_connection_key(
        self,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST array-connections/connection-key
        
        Create an array connection key allowing one array to connect to another for replication.
        
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api26_array_connections_connection_key_post_with_http_info', kwargs)

    def delete_array_connections(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE array-connections
        
        Delete a connection to an array.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['ids', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api26_array_connections_delete_with_http_info', kwargs)

    def get_array_connections(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET array-connections
        
        List connected arrays for replication.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            offset=offset,
            remote_ids=remote_ids,
            remote_names=remote_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['ids', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api26_array_connections_get_with_http_info', kwargs)

    def patch_array_connections(
        self,
        array_connection: 'models.ArrayConnection',
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH array-connections
        
        Modify the configuration of a connected array.
        
        :param array_connection: (required)
        :type array_connection: ArrayConnection
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            array_connection=array_connection,
            ids=ids,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['ids', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api26_array_connections_patch_with_http_info', kwargs)

    def get_array_connections_path(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET array-connections/path
        
        List network path details of connected arrays.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            offset=offset,
            remote_ids=remote_ids,
            remote_names=remote_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['ids', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api26_array_connections_path_get_with_http_info', kwargs)

    def get_array_connections_performance_replication(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Display the metric of a specified object type. Valid values are `all`, `file-system`, and `object-store`. If not specified, defaults to `all`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET array-connections/performance/replication
        
        List performance metrics of file systems or objects being replicated from one array to another.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param type: Display the metric of a specified object type. Valid values are `all`, `file-
                    system`, and `object-store`. If not specified, defaults to `all`.
        :type type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            end_time=end_time,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            offset=offset,
            remote_ids=remote_ids,
            remote_names=remote_names,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_only=total_only,
            type=type,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['ids', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api26_array_connections_performance_replication_get_with_http_info', kwargs)

    def post_array_connections(
        self,
        array_connection: 'models.ArrayConnectionPost',
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST array-connections
        
        Create a connection to an array for replication and configure network settings.
        
        :param array_connection: (required)
        :type array_connection: ArrayConnectionPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            array_connection=array_connection,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api26_array_connections_post_with_http_info', kwargs)

    def get_arrays_eula(
        self,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET arrays/eula
        
        List the End User Agreement and signature.
        
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('ArraysApi', 'api26_arrays_eula_get_with_http_info', kwargs)

    def patch_arrays_eula(
        self,
        eula: 'models.Eula',
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH arrays/eula
        
        Modifies the signature on the End User Agreement.
        
        :param eula: (required)
        :type eula: Eula
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            eula=eula,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api26_arrays_eula_patch_with_http_info', kwargs)

    def delete_arrays_factory_reset_token(
        self,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a factory reset token
        
        Deletes any existing token that could be used to perform a factory reset on the array.
        
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api26_arrays_factory_reset_token_delete_with_http_info', kwargs)

    def get_arrays_factory_reset_token(
        self,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List factory reset tokens
        
        Displays a list of tokens used to perform a factory reset on the array.
        
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('ArraysApi', 'api26_arrays_factory_reset_token_get_with_http_info', kwargs)

    def post_arrays_factory_reset_token(
        self,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a factory reset token
        
        Creates a token that can be used to perform a factory reset on the array. Factory reset tokens can only be created after the array has been prepared for reset (e.g., all file systems, buckets, and snapshots must first be eradicated). After a token has been created, operations that would take the array out of the prepared state (e.g., creating file systems) are disabled until all tokens have been deleted.
        
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api26_arrays_factory_reset_token_post_with_http_info', kwargs)

    def get_arrays(
        self,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET arrays
        
        List array attributes such as the array name, ID, version, and NTP servers.
        
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('ArraysApi', 'api26_arrays_get_with_http_info', kwargs)

    def get_arrays_http_specific_performance(
        self,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET arrays/http-specific-performance
        
        List the HTTP performance metrics of the array.
        
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            end_time=end_time,
            resolution=resolution,
            start_time=start_time,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api26_arrays_http_specific_performance_get_with_http_info', kwargs)

    def get_arrays_nfs_specific_performance(
        self,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET arrays/nfs-specific-performance
        
        List the NFS performance metrics of the array.
        
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            end_time=end_time,
            resolution=resolution,
            start_time=start_time,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api26_arrays_nfs_specific_performance_get_with_http_info', kwargs)

    def patch_arrays(
        self,
        array: 'models.Array',
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH arrays
        
        Modify the general configuration of the array including banner text, array name, NTP servers, and time zone.
        
        :param array: (required)
        :type array: Array
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            array=array,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api26_arrays_patch_with_http_info', kwargs)

    def get_arrays_performance(
        self,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        protocol: Annotated[Optional[StrictStr], Field(description="Display the performance of a specified protocol. Valid values are `all`, `HTTP`, `SMB`, `NFS`, and `S3`. If not specified, defaults to `all`, which will provide the combined performance of all available protocols.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET arrays/performance
        
        Lists the overall performance metrics of the array.
        
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param protocol: Display the performance of a specified protocol. Valid values are `all`, `HTTP`,
                        `SMB`, `NFS`, and `S3`. If not specified, defaults to `all`, which will
                        provide the combined performance of all available protocols.
        :type protocol: str
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            end_time=end_time,
            protocol=protocol,
            resolution=resolution,
            start_time=start_time,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api26_arrays_performance_get_with_http_info', kwargs)

    def get_arrays_performance_replication(
        self,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Display the metric of a specified object type. Valid values are `all`, `file-system`, and `object-store`. If not specified, defaults to `all`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET arrays/performance/replication
        
        List replication performance metrics.
        
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param type: Display the metric of a specified object type. Valid values are `all`, `file-
                    system`, and `object-store`. If not specified, defaults to `all`.
        :type type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            end_time=end_time,
            resolution=resolution,
            start_time=start_time,
            type=type,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api26_arrays_performance_replication_get_with_http_info', kwargs)

    def get_arrays_s3_specific_performance(
        self,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET arrays/s3-specific-performance
        
        List the S3 performance metrics of the array.
        
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            end_time=end_time,
            resolution=resolution,
            start_time=start_time,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api26_arrays_s3_specific_performance_get_with_http_info', kwargs)

    def get_arrays_space(
        self,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Display the metric of a specified object type. Valid values are `array`, `file-system`, and `object-store`. If not specified, defaults to `array`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET arrays/space
        
        List available and used storage space on the array.
        
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param type: Display the metric of a specified object type. Valid values are `array`, `file-
                    system`, and `object-store`. If not specified, defaults to `array`.
        :type type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            end_time=end_time,
            resolution=resolution,
            start_time=start_time,
            type=type,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api26_arrays_space_get_with_http_info', kwargs)

    def get_arrays_supported_time_zones(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET arrays/supported-time-zones
        
        List supported time zones for the array.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('ArraysApi', 'api26_arrays_supported_time_zones_get_with_http_info', kwargs)

    def get_audits(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET audits
        
        List the array audit trail to view activities that were performed on the array.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('AuditsApi', 'api26_audits_get_with_http_info', kwargs)

    def get_blades(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET blades
        
        List array blade information.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('BladesApi', 'api26_blades_get_with_http_info', kwargs)

    def delete_bucket_replica_links(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        local_bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local bucket IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_bucket_names` query parameter.")] = None,
        local_bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local bucket names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_bucket_ids` query parameter.")] = None,
        remote_bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote bucket names. If there is not at least one resource that matches each of the elements, then an error is returned.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE bucket-replica-links
        
        Delete a bucket replica link.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param remote_buckets: A list of remote_buckets to query for. Overrides remote_bucket_names keyword argument.
        :type remote_buckets: ReferenceType or List[ReferenceType], optional
        :param local_buckets: A list of local_buckets to query for. Overrides local_bucket_ids and local_bucket_names keyword arguments.
        :type local_buckets: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param local_bucket_ids: A comma-separated list of local bucket IDs. If after filtering, there is not at
                                least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `local_bucket_names`
                                query parameter.
        :type local_bucket_ids: List[str]
        :param local_bucket_names: A comma-separated list of local bucket names. If there is not at least one
                                resource that matches each of the elements, then an error is returned.
                                This cannot be provided together with `local_bucket_ids` query parameter.
        :type local_bucket_names: List[str]
        :param remote_bucket_names: A comma-separated list of remote bucket names. If there is not at least one
                                    resource that matches each of the elements, then an error is returned.
        :type remote_bucket_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            local_bucket_ids=local_bucket_ids,
            local_bucket_names=local_bucket_names,
            remote_bucket_names=remote_bucket_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids'], kwargs)
        _process_references(local_buckets, ['local_bucket_ids', 'local_bucket_names'], kwargs)
        _process_references(remote_buckets, ['remote_bucket_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['ids', 'local_bucket_ids', 'local_bucket_names', 'remote_bucket_names', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('BucketReplicaLinksApi', 'api26_bucket_replica_links_delete_with_http_info', kwargs)

    def get_bucket_replica_links(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        local_bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local bucket IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_bucket_names` query parameter.")] = None,
        local_bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local bucket names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_bucket_ids` query parameter.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        remote_bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote bucket names. If there is not at least one resource that matches each of the elements, then an error is returned.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET bucket-replica-links
        
        List bucket replica links for object replication.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param remote_buckets: A list of remote_buckets to query for. Overrides remote_bucket_names keyword argument.
        :type remote_buckets: ReferenceType or List[ReferenceType], optional
        :param local_buckets: A list of local_buckets to query for. Overrides local_bucket_ids and local_bucket_names keyword arguments.
        :type local_buckets: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param local_bucket_ids: A comma-separated list of local bucket IDs. If after filtering, there is not at
                                least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `local_bucket_names`
                                query parameter.
        :type local_bucket_ids: List[str]
        :param local_bucket_names: A comma-separated list of local bucket names. If there is not at least one
                                resource that matches each of the elements, then an error is returned.
                                This cannot be provided together with `local_bucket_ids` query parameter.
        :type local_bucket_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param remote_bucket_names: A comma-separated list of remote bucket names. If there is not at least one
                                    resource that matches each of the elements, then an error is returned.
        :type remote_bucket_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            local_bucket_ids=local_bucket_ids,
            local_bucket_names=local_bucket_names,
            offset=offset,
            remote_bucket_names=remote_bucket_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids'], kwargs)
        _process_references(local_buckets, ['local_bucket_ids', 'local_bucket_names'], kwargs)
        _process_references(remote_buckets, ['remote_bucket_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['ids', 'local_bucket_ids', 'local_bucket_names', 'remote_bucket_names', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('BucketReplicaLinksApi', 'api26_bucket_replica_links_get_with_http_info', kwargs)

    def patch_bucket_replica_links(
        self,
        bucket_replica_link: 'models.BucketReplicaLink',
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        local_bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local bucket IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_bucket_names` query parameter.")] = None,
        local_bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local bucket names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_bucket_ids` query parameter.")] = None,
        remote_bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote bucket names. If there is not at least one resource that matches each of the elements, then an error is returned.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH bucket-replica-links
        
        Modify the configuration of a bucket replica link including whether the link is paused and the object store remote credentials used.
        
        :param bucket_replica_link: (required)
        :type bucket_replica_link: BucketReplicaLink
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param remote_buckets: A list of remote_buckets to query for. Overrides remote_bucket_names keyword argument.
        :type remote_buckets: ReferenceType or List[ReferenceType], optional
        :param local_buckets: A list of local_buckets to query for. Overrides local_bucket_ids and local_bucket_names keyword arguments.
        :type local_buckets: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param local_bucket_ids: A comma-separated list of local bucket IDs. If after filtering, there is not at
                                least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `local_bucket_names`
                                query parameter.
        :type local_bucket_ids: List[str]
        :param local_bucket_names: A comma-separated list of local bucket names. If there is not at least one
                                resource that matches each of the elements, then an error is returned.
                                This cannot be provided together with `local_bucket_ids` query parameter.
        :type local_bucket_names: List[str]
        :param remote_bucket_names: A comma-separated list of remote bucket names. If there is not at least one
                                    resource that matches each of the elements, then an error is returned.
        :type remote_bucket_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            bucket_replica_link=bucket_replica_link,
            ids=ids,
            local_bucket_ids=local_bucket_ids,
            local_bucket_names=local_bucket_names,
            remote_bucket_names=remote_bucket_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids'], kwargs)
        _process_references(local_buckets, ['local_bucket_ids', 'local_bucket_names'], kwargs)
        _process_references(remote_buckets, ['remote_bucket_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['ids', 'local_bucket_ids', 'local_bucket_names', 'remote_bucket_names', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('BucketReplicaLinksApi', 'api26_bucket_replica_links_patch_with_http_info', kwargs)

    def post_bucket_replica_links(
        self,
        bucket_replica_link: 'models.BucketReplicaLinkPost',
        remote_credential: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local bucket IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_bucket_names` query parameter.")] = None,
        local_bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local bucket names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_bucket_ids` query parameter.")] = None,
        remote_bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote bucket names. If there is not at least one resource that matches each of the elements, then an error is returned.")] = None,
        remote_credentials_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote credentials IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_credentials_names` query parameter.")] = None,
        remote_credentials_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote credentials names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_credentials_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST bucket-replica-links
        
        Create a bucket replica link for object replication.
        
        :param bucket_replica_link: (required)
        :type bucket_replica_link: BucketReplicaLinkPost
        :param remote_credential: A list of remote_credential to query for. Overrides remote_credentials_ids and remote_credentials_names keyword arguments.
        :type remote_credential: ReferenceType or List[ReferenceType], optional
        :param remote_buckets: A list of remote_buckets to query for. Overrides remote_bucket_names keyword argument.
        :type remote_buckets: ReferenceType or List[ReferenceType], optional
        :param local_buckets: A list of local_buckets to query for. Overrides local_bucket_ids and local_bucket_names keyword arguments.
        :type local_buckets: ReferenceType or List[ReferenceType], optional
        :param local_bucket_ids: A comma-separated list of local bucket IDs. If after filtering, there is not at
                                least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `local_bucket_names`
                                query parameter.
        :type local_bucket_ids: List[str]
        :param local_bucket_names: A comma-separated list of local bucket names. If there is not at least one
                                resource that matches each of the elements, then an error is returned.
                                This cannot be provided together with `local_bucket_ids` query parameter.
        :type local_bucket_names: List[str]
        :param remote_bucket_names: A comma-separated list of remote bucket names. If there is not at least one
                                    resource that matches each of the elements, then an error is returned.
        :type remote_bucket_names: List[str]
        :param remote_credentials_ids: A comma-separated list of remote credentials IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `remote_credentials_names` query parameter.
        :type remote_credentials_ids: List[str]
        :param remote_credentials_names: A comma-separated list of remote credentials names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with the `remote_credentials_ids` query
                                        parameter.
        :type remote_credentials_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            bucket_replica_link=bucket_replica_link,
            local_bucket_ids=local_bucket_ids,
            local_bucket_names=local_bucket_names,
            remote_bucket_names=remote_bucket_names,
            remote_credentials_ids=remote_credentials_ids,
            remote_credentials_names=remote_credentials_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(local_buckets, ['local_bucket_ids', 'local_bucket_names'], kwargs)
        _process_references(remote_buckets, ['remote_bucket_names'], kwargs)
        _process_references(remote_credential, ['remote_credentials_ids', 'remote_credentials_names'], kwargs)
        _fixup_list_type_params(['local_bucket_ids', 'local_bucket_names', 'remote_bucket_names', 'remote_credentials_ids', 'remote_credentials_names'], kwargs)
        return self._call_api('BucketReplicaLinksApi', 'api26_bucket_replica_links_post_with_http_info', kwargs)

    def delete_buckets(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE buckets
        
        Delete object store buckets.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('BucketsApi', 'api26_buckets_delete_with_http_info', kwargs)

    def get_buckets(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. If not set, lists both objects that are destroyed and those that are not destroyed. If object name(s) are specified in the `names` parameter, then each object referenced must exist. If `destroyed` is set to `true`, then each object referenced must also be destroyed. If `destroyed` is set to `false`, then each object referenced must also not be destroyed. An error is returned if any of these conditions are not met.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET buckets
        
        List object store bucket attributes such as creation time and space usage.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        If not set, lists both objects that are destroyed and those that are not
                        destroyed. If object name(s) are specified in the `names` parameter, then
                        each object referenced must exist. If `destroyed` is set to `true`, then
                        each object referenced must also be destroyed. If `destroyed` is set to
                        `false`, then each object referenced must also not be destroyed. An error is
                        returned if any of these conditions are not met.
        :type destroyed: bool
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('BucketsApi', 'api26_buckets_get_with_http_info', kwargs)

    def patch_buckets(
        self,
        bucket: 'models.Bucket',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH buckets
        
        Modify object store bucket attributes such as destroyed and versioning.
        
        :param bucket: (required)
        :type bucket: Bucket
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            bucket=bucket,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('BucketsApi', 'api26_buckets_patch_with_http_info', kwargs)

    def get_buckets_performance(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET buckets/performance
        
        List performance metrics for a bucket.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            end_time=end_time,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('BucketsApi', 'api26_buckets_performance_get_with_http_info', kwargs)

    def post_buckets(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        bucket: 'models.BucketPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST buckets
        
        Create a new object store bucket.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param bucket: (required)
        :type bucket: BucketPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            bucket=bucket,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('BucketsApi', 'api26_buckets_post_with_http_info', kwargs)

    def get_buckets_s3_specific_performance(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET buckets/s3-specific-performance
        
        List performance metrics specific to S3 operations for a bucket.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            end_time=end_time,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('BucketsApi', 'api26_buckets_s3_specific_performance_get_with_http_info', kwargs)

    def delete_certificate_groups_certificates(
        self,
        certificates: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group ids. If there is not at least one resource that matches each of the elements of `certificate_group_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_names` parameter.")] = None,
        certificate_group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group names. If there is not at least one resource that matches each of the elements of `certificate_group_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_ids` parameter.")] = None,
        certificate_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate ids. If there is not at least one resource that matches each of the elements of `certificate_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_names` parameter.")] = None,
        certificate_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate names. If there is not at least one resource that matches each of the elements of `certificate_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_ids` parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE certificate-groups/certificates
        
        Delete one or more certificate groups.
        
        :param certificates: A list of certificates to query for. Overrides certificate_ids and certificate_names keyword arguments.
        :type certificates: ReferenceType or List[ReferenceType], optional
        :param certificate_groups: A list of certificate_groups to query for. Overrides certificate_group_ids and certificate_group_names keyword arguments.
        :type certificate_groups: ReferenceType or List[ReferenceType], optional
        :param certificate_group_ids: A comma-separated list of certificate group ids. If there is not at least one
                                    resource that matches each of the elements of `certificate_group_ids`,
                                    then an error is returned. This cannot be provided in conjunction with
                                    the `certificate_group_names` parameter.
        :type certificate_group_ids: List[str]
        :param certificate_group_names: A comma-separated list of certificate group names. If there is not at least one
                                        resource that matches each of the elements of `certificate_group_names`,
                                        then an error is returned. This cannot be provided in conjunction with
                                        the `certificate_group_ids` parameter.
        :type certificate_group_names: List[str]
        :param certificate_ids: A comma-separated list of certificate ids. If there is not at least one resource
                                that matches each of the elements of `certificate_ids`, then an error is
                                returned. This cannot be provided in conjunction with the
                                `certificate_names` parameter.
        :type certificate_ids: List[str]
        :param certificate_names: A comma-separated list of certificate names. If there is not at least one
                                resource that matches each of the elements of `certificate_names`, then an
                                error is returned. This cannot be provided in conjunction with the
                                `certificate_ids` parameter.
        :type certificate_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            certificate_group_ids=certificate_group_ids,
            certificate_group_names=certificate_group_names,
            certificate_ids=certificate_ids,
            certificate_names=certificate_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(certificate_groups, ['certificate_group_ids', 'certificate_group_names'], kwargs)
        _process_references(certificates, ['certificate_ids', 'certificate_names'], kwargs)
        _fixup_list_type_params(['certificate_group_ids', 'certificate_group_names', 'certificate_ids', 'certificate_names'], kwargs)
        return self._call_api('CertificateGroupsApi', 'api26_certificate_groups_certificates_delete_with_http_info', kwargs)

    def get_certificate_groups_certificates(
        self,
        certificates: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group ids. If there is not at least one resource that matches each of the elements of `certificate_group_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_names` parameter.")] = None,
        certificate_group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group names. If there is not at least one resource that matches each of the elements of `certificate_group_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_ids` parameter.")] = None,
        certificate_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate ids. If there is not at least one resource that matches each of the elements of `certificate_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_names` parameter.")] = None,
        certificate_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate names. If there is not at least one resource that matches each of the elements of `certificate_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_ids` parameter.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET certificate-groups/certificates
        
        List membership associations between groups and certificates on the array.
        
        :param certificates: A list of certificates to query for. Overrides certificate_ids and certificate_names keyword arguments.
        :type certificates: ReferenceType or List[ReferenceType], optional
        :param certificate_groups: A list of certificate_groups to query for. Overrides certificate_group_ids and certificate_group_names keyword arguments.
        :type certificate_groups: ReferenceType or List[ReferenceType], optional
        :param certificate_group_ids: A comma-separated list of certificate group ids. If there is not at least one
                                    resource that matches each of the elements of `certificate_group_ids`,
                                    then an error is returned. This cannot be provided in conjunction with
                                    the `certificate_group_names` parameter.
        :type certificate_group_ids: List[str]
        :param certificate_group_names: A comma-separated list of certificate group names. If there is not at least one
                                        resource that matches each of the elements of `certificate_group_names`,
                                        then an error is returned. This cannot be provided in conjunction with
                                        the `certificate_group_ids` parameter.
        :type certificate_group_names: List[str]
        :param certificate_ids: A comma-separated list of certificate ids. If there is not at least one resource
                                that matches each of the elements of `certificate_ids`, then an error is
                                returned. This cannot be provided in conjunction with the
                                `certificate_names` parameter.
        :type certificate_ids: List[str]
        :param certificate_names: A comma-separated list of certificate names. If there is not at least one
                                resource that matches each of the elements of `certificate_names`, then an
                                error is returned. This cannot be provided in conjunction with the
                                `certificate_ids` parameter.
        :type certificate_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            certificate_group_ids=certificate_group_ids,
            certificate_group_names=certificate_group_names,
            certificate_ids=certificate_ids,
            certificate_names=certificate_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(certificate_groups, ['certificate_group_ids', 'certificate_group_names'], kwargs)
        _process_references(certificates, ['certificate_ids', 'certificate_names'], kwargs)
        _fixup_list_type_params(['certificate_group_ids', 'certificate_group_names', 'certificate_ids', 'certificate_names', 'sort'], kwargs)
        return self._call_api('CertificateGroupsApi', 'api26_certificate_groups_certificates_get_with_http_info', kwargs)

    def post_certificate_groups_certificates(
        self,
        certificates: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group ids. If there is not at least one resource that matches each of the elements of `certificate_group_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_names` parameter.")] = None,
        certificate_group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group names. If there is not at least one resource that matches each of the elements of `certificate_group_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_ids` parameter.")] = None,
        certificate_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate ids. If there is not at least one resource that matches each of the elements of `certificate_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_names` parameter.")] = None,
        certificate_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate names. If there is not at least one resource that matches each of the elements of `certificate_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_ids` parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST certificate-groups/certificates
        
        Add one or more certificates to one or more certificate groups on the array.
        
        :param certificates: A list of certificates to query for. Overrides certificate_ids and certificate_names keyword arguments.
        :type certificates: ReferenceType or List[ReferenceType], optional
        :param certificate_groups: A list of certificate_groups to query for. Overrides certificate_group_ids and certificate_group_names keyword arguments.
        :type certificate_groups: ReferenceType or List[ReferenceType], optional
        :param certificate_group_ids: A comma-separated list of certificate group ids. If there is not at least one
                                    resource that matches each of the elements of `certificate_group_ids`,
                                    then an error is returned. This cannot be provided in conjunction with
                                    the `certificate_group_names` parameter.
        :type certificate_group_ids: List[str]
        :param certificate_group_names: A comma-separated list of certificate group names. If there is not at least one
                                        resource that matches each of the elements of `certificate_group_names`,
                                        then an error is returned. This cannot be provided in conjunction with
                                        the `certificate_group_ids` parameter.
        :type certificate_group_names: List[str]
        :param certificate_ids: A comma-separated list of certificate ids. If there is not at least one resource
                                that matches each of the elements of `certificate_ids`, then an error is
                                returned. This cannot be provided in conjunction with the
                                `certificate_names` parameter.
        :type certificate_ids: List[str]
        :param certificate_names: A comma-separated list of certificate names. If there is not at least one
                                resource that matches each of the elements of `certificate_names`, then an
                                error is returned. This cannot be provided in conjunction with the
                                `certificate_ids` parameter.
        :type certificate_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            certificate_group_ids=certificate_group_ids,
            certificate_group_names=certificate_group_names,
            certificate_ids=certificate_ids,
            certificate_names=certificate_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(certificate_groups, ['certificate_group_ids', 'certificate_group_names'], kwargs)
        _process_references(certificates, ['certificate_ids', 'certificate_names'], kwargs)
        _fixup_list_type_params(['certificate_group_ids', 'certificate_group_names', 'certificate_ids', 'certificate_names'], kwargs)
        return self._call_api('CertificateGroupsApi', 'api26_certificate_groups_certificates_post_with_http_info', kwargs)

    def delete_certificate_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE certificate-groups
        
        Delete one or more certificate groups from the array.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('CertificateGroupsApi', 'api26_certificate_groups_delete_with_http_info', kwargs)

    def get_certificate_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET certificate-groups
        
        Display all array certificate groups.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('CertificateGroupsApi', 'api26_certificate_groups_get_with_http_info', kwargs)

    def post_certificate_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST certificate-groups
        
        Create one or more certificate groups on the array.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('CertificateGroupsApi', 'api26_certificate_groups_post_with_http_info', kwargs)

    def get_certificate_groups_uses(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET certificate-groups/uses
        
        List how certificate groups are being used and by what.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('CertificateGroupsApi', 'api26_certificate_groups_uses_get_with_http_info', kwargs)

    def delete_certificates_certificate_groups(
        self,
        certificates: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group ids. If there is not at least one resource that matches each of the elements of `certificate_group_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_names` parameter.")] = None,
        certificate_group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group names. If there is not at least one resource that matches each of the elements of `certificate_group_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_ids` parameter.")] = None,
        certificate_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate ids. If there is not at least one resource that matches each of the elements of `certificate_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_names` parameter.")] = None,
        certificate_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate names. If there is not at least one resource that matches each of the elements of `certificate_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_ids` parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE certificates/certificate-groups
        
        Remove one or more certificates from one or more certificate groups.
        
        :param certificates: A list of certificates to query for. Overrides certificate_ids and certificate_names keyword arguments.
        :type certificates: ReferenceType or List[ReferenceType], optional
        :param certificate_groups: A list of certificate_groups to query for. Overrides certificate_group_ids and certificate_group_names keyword arguments.
        :type certificate_groups: ReferenceType or List[ReferenceType], optional
        :param certificate_group_ids: A comma-separated list of certificate group ids. If there is not at least one
                                    resource that matches each of the elements of `certificate_group_ids`,
                                    then an error is returned. This cannot be provided in conjunction with
                                    the `certificate_group_names` parameter.
        :type certificate_group_ids: List[str]
        :param certificate_group_names: A comma-separated list of certificate group names. If there is not at least one
                                        resource that matches each of the elements of `certificate_group_names`,
                                        then an error is returned. This cannot be provided in conjunction with
                                        the `certificate_group_ids` parameter.
        :type certificate_group_names: List[str]
        :param certificate_ids: A comma-separated list of certificate ids. If there is not at least one resource
                                that matches each of the elements of `certificate_ids`, then an error is
                                returned. This cannot be provided in conjunction with the
                                `certificate_names` parameter.
        :type certificate_ids: List[str]
        :param certificate_names: A comma-separated list of certificate names. If there is not at least one
                                resource that matches each of the elements of `certificate_names`, then an
                                error is returned. This cannot be provided in conjunction with the
                                `certificate_ids` parameter.
        :type certificate_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            certificate_group_ids=certificate_group_ids,
            certificate_group_names=certificate_group_names,
            certificate_ids=certificate_ids,
            certificate_names=certificate_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(certificate_groups, ['certificate_group_ids', 'certificate_group_names'], kwargs)
        _process_references(certificates, ['certificate_ids', 'certificate_names'], kwargs)
        _fixup_list_type_params(['certificate_group_ids', 'certificate_group_names', 'certificate_ids', 'certificate_names'], kwargs)
        return self._call_api('CertificatesApi', 'api26_certificates_certificate_groups_delete_with_http_info', kwargs)

    def get_certificates_certificate_groups(
        self,
        certificates: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group ids. If there is not at least one resource that matches each of the elements of `certificate_group_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_names` parameter.")] = None,
        certificate_group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group names. If there is not at least one resource that matches each of the elements of `certificate_group_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_ids` parameter.")] = None,
        certificate_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate ids. If there is not at least one resource that matches each of the elements of `certificate_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_names` parameter.")] = None,
        certificate_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate names. If there is not at least one resource that matches each of the elements of `certificate_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_ids` parameter.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET certificates/certificate-groups
        
        List membership associations between groups and certificates.
        
        :param certificates: A list of certificates to query for. Overrides certificate_ids and certificate_names keyword arguments.
        :type certificates: ReferenceType or List[ReferenceType], optional
        :param certificate_groups: A list of certificate_groups to query for. Overrides certificate_group_ids and certificate_group_names keyword arguments.
        :type certificate_groups: ReferenceType or List[ReferenceType], optional
        :param certificate_group_ids: A comma-separated list of certificate group ids. If there is not at least one
                                    resource that matches each of the elements of `certificate_group_ids`,
                                    then an error is returned. This cannot be provided in conjunction with
                                    the `certificate_group_names` parameter.
        :type certificate_group_ids: List[str]
        :param certificate_group_names: A comma-separated list of certificate group names. If there is not at least one
                                        resource that matches each of the elements of `certificate_group_names`,
                                        then an error is returned. This cannot be provided in conjunction with
                                        the `certificate_group_ids` parameter.
        :type certificate_group_names: List[str]
        :param certificate_ids: A comma-separated list of certificate ids. If there is not at least one resource
                                that matches each of the elements of `certificate_ids`, then an error is
                                returned. This cannot be provided in conjunction with the
                                `certificate_names` parameter.
        :type certificate_ids: List[str]
        :param certificate_names: A comma-separated list of certificate names. If there is not at least one
                                resource that matches each of the elements of `certificate_names`, then an
                                error is returned. This cannot be provided in conjunction with the
                                `certificate_ids` parameter.
        :type certificate_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            certificate_group_ids=certificate_group_ids,
            certificate_group_names=certificate_group_names,
            certificate_ids=certificate_ids,
            certificate_names=certificate_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(certificate_groups, ['certificate_group_ids', 'certificate_group_names'], kwargs)
        _process_references(certificates, ['certificate_ids', 'certificate_names'], kwargs)
        _fixup_list_type_params(['certificate_group_ids', 'certificate_group_names', 'certificate_ids', 'certificate_names', 'sort'], kwargs)
        return self._call_api('CertificatesApi', 'api26_certificates_certificate_groups_get_with_http_info', kwargs)

    def post_certificates_certificate_groups(
        self,
        certificates: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group ids. If there is not at least one resource that matches each of the elements of `certificate_group_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_names` parameter.")] = None,
        certificate_group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group names. If there is not at least one resource that matches each of the elements of `certificate_group_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_ids` parameter.")] = None,
        certificate_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate ids. If there is not at least one resource that matches each of the elements of `certificate_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_names` parameter.")] = None,
        certificate_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate names. If there is not at least one resource that matches each of the elements of `certificate_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_ids` parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST certificates/certificate-groups
        
        Add one or more certificates to one or more certificate groups.
        
        :param certificates: A list of certificates to query for. Overrides certificate_ids and certificate_names keyword arguments.
        :type certificates: ReferenceType or List[ReferenceType], optional
        :param certificate_groups: A list of certificate_groups to query for. Overrides certificate_group_ids and certificate_group_names keyword arguments.
        :type certificate_groups: ReferenceType or List[ReferenceType], optional
        :param certificate_group_ids: A comma-separated list of certificate group ids. If there is not at least one
                                    resource that matches each of the elements of `certificate_group_ids`,
                                    then an error is returned. This cannot be provided in conjunction with
                                    the `certificate_group_names` parameter.
        :type certificate_group_ids: List[str]
        :param certificate_group_names: A comma-separated list of certificate group names. If there is not at least one
                                        resource that matches each of the elements of `certificate_group_names`,
                                        then an error is returned. This cannot be provided in conjunction with
                                        the `certificate_group_ids` parameter.
        :type certificate_group_names: List[str]
        :param certificate_ids: A comma-separated list of certificate ids. If there is not at least one resource
                                that matches each of the elements of `certificate_ids`, then an error is
                                returned. This cannot be provided in conjunction with the
                                `certificate_names` parameter.
        :type certificate_ids: List[str]
        :param certificate_names: A comma-separated list of certificate names. If there is not at least one
                                resource that matches each of the elements of `certificate_names`, then an
                                error is returned. This cannot be provided in conjunction with the
                                `certificate_ids` parameter.
        :type certificate_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            certificate_group_ids=certificate_group_ids,
            certificate_group_names=certificate_group_names,
            certificate_ids=certificate_ids,
            certificate_names=certificate_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(certificate_groups, ['certificate_group_ids', 'certificate_group_names'], kwargs)
        _process_references(certificates, ['certificate_ids', 'certificate_names'], kwargs)
        _fixup_list_type_params(['certificate_group_ids', 'certificate_group_names', 'certificate_ids', 'certificate_names'], kwargs)
        return self._call_api('CertificatesApi', 'api26_certificates_certificate_groups_post_with_http_info', kwargs)

    def delete_certificates(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE certificates
        
        Delete a CA certificate from the array.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('CertificatesApi', 'api26_certificates_delete_with_http_info', kwargs)

    def get_certificates(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET certificates
        
        List array certificates and their attributes.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('CertificatesApi', 'api26_certificates_get_with_http_info', kwargs)

    def patch_certificates(
        self,
        certificate: 'models.CertificatePatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH certificates
        
        Modify SSL certificate attributes such as passphrases and intermediate certificates.
        
        :param certificate: (required)
        :type certificate: CertificatePatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            certificate=certificate,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('CertificatesApi', 'api26_certificates_patch_with_http_info', kwargs)

    def post_certificates(
        self,
        certificate: 'models.CertificatePost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST certificates
        
        Upload a CA certificate to the array.
        
        :param certificate: (required)
        :type certificate: CertificatePost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            certificate=certificate,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('CertificatesApi', 'api26_certificates_post_with_http_info', kwargs)

    def get_certificates_uses(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET certificates/uses
        
        List how certificates are being used and by what.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('CertificatesApi', 'api26_certificates_uses_get_with_http_info', kwargs)

    def get_arrays_clients_performance(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET clients-performance
        
        List NFS client I/O performance metrics.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            names=names,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('ClientsApi', 'api26_arrays_clients_performance_get_with_http_info', kwargs)

    def get_dns(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET dns
        
        List DNS attributes for the array's administrative network.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('DNSApi', 'api26_dns_get_with_http_info', kwargs)

    def patch_dns(
        self,
        dns: 'models.Dns',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH dns
        
        Modify DNS attributes.
        
        :param dns: (required)
        :type dns: Dns
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            dns=dns,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('DNSApi', 'api26_dns_patch_with_http_info', kwargs)

    def get_directory_services(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET directory-services
        
        List directory service configuration information for the array.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api26_directory_services_get_with_http_info', kwargs)

    def patch_directory_services(
        self,
        directory_service: 'models.DirectoryService',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH directory-services
        
        Modifies and tests the directory service configuration.
        
        :param directory_service: (required)
        :type directory_service: DirectoryService
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            directory_service=directory_service,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api26_directory_services_patch_with_http_info', kwargs)

    def get_directory_services_roles(
        self,
        roles: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `role_names` or `role_ids` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        role_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of role_ids. If after filtering, there is not at least one resource that matches each of the elements of `role_ids`, then an error is returned. This cannot be provided together with the `ids` or `role_names` query parameters.")] = None,
        role_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of role_names. If there is not at least one resource that matches each of the elements of `role_names`, then an error is returned. This cannot be provided together with the `ids` or `role_ids` query parameters.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET directory-service/roles
        
        Return array's RBAC group configuration settings for manageability.
        
        :param roles: A list of roles to query for. Overrides role_ids and role_names keyword arguments.
        :type roles: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `role_names` or
                    `role_ids` query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param role_ids: A comma-separated list of role_ids. If after filtering, there is not at least
                        one resource that matches each of the elements of `role_ids`, then an error
                        is returned. This cannot be provided together with the `ids` or `role_names`
                        query parameters.
        :type role_ids: List[str]
        :param role_names: A comma-separated list of role_names. If there is not at least one resource that
                        matches each of the elements of `role_names`, then an error is returned.
                        This cannot be provided together with the `ids` or `role_ids` query
                        parameters.
        :type role_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            offset=offset,
            role_ids=role_ids,
            role_names=role_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids'], kwargs)
        _process_references(roles, ['role_ids', 'role_names'], kwargs)
        _fixup_list_type_params(['ids', 'role_ids', 'role_names', 'sort'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api26_directory_services_roles_get_with_http_info', kwargs)

    def patch_directory_services_roles(
        self,
        directory_service_roles: 'models.DirectoryServiceRole',
        roles: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `role_names` or `role_ids` query parameters.")] = None,
        role_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of role_ids. If after filtering, there is not at least one resource that matches each of the elements of `role_ids`, then an error is returned. This cannot be provided together with the `ids` or `role_names` query parameters.")] = None,
        role_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of role_names. If there is not at least one resource that matches each of the elements of `role_names`, then an error is returned. This cannot be provided together with the `ids` or `role_ids` query parameters.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH directory-service/roles
        
        Update an RBAC group configuration setting for manageability.
        
        :param directory_service_roles: (required)
        :type directory_service_roles: DirectoryServiceRole
        :param roles: A list of roles to query for. Overrides role_ids and role_names keyword arguments.
        :type roles: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `role_names` or
                    `role_ids` query parameters.
        :type ids: List[str]
        :param role_ids: A comma-separated list of role_ids. If after filtering, there is not at least
                        one resource that matches each of the elements of `role_ids`, then an error
                        is returned. This cannot be provided together with the `ids` or `role_names`
                        query parameters.
        :type role_ids: List[str]
        :param role_names: A comma-separated list of role_names. If there is not at least one resource that
                        matches each of the elements of `role_names`, then an error is returned.
                        This cannot be provided together with the `ids` or `role_ids` query
                        parameters.
        :type role_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            directory_service_roles=directory_service_roles,
            ids=ids,
            role_ids=role_ids,
            role_names=role_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids'], kwargs)
        _process_references(roles, ['role_ids', 'role_names'], kwargs)
        _fixup_list_type_params(['ids', 'role_ids', 'role_names'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api26_directory_services_roles_patch_with_http_info', kwargs)

    def get_directory_services_test(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET directory-services/test
        
        Test the configured directory services on the array.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api26_directory_services_test_get_with_http_info', kwargs)

    def patch_directory_services_test(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        directory_service: Annotated[Optional['models.DirectoryService'], Field(description="An optional directory service configuration that, if provided, will be used to overwrite aspects of the existing directory service objects when performing tests.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH directory-service/test
        
        Test the configured directory services on the array. Optionally, provide modifications which will be used to perform the tests, but will not be applied to the current configuration.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param directory_service: An optional directory service configuration that, if provided, will be used to
                                overwrite aspects of the existing directory service objects when
                                performing tests.
        :type directory_service: DirectoryService
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            names=names,
            sort=sort,
            directory_service=directory_service,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api26_directory_services_test_patch_with_http_info', kwargs)

    def get_drives(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET drives
        
        List array drive information.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('DrivesApi', 'api26_drives_get_with_http_info', kwargs)

    def get_file_system_replica_links(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        remote_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system IDs. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_names` query parameter.")] = None,
        remote_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_ids` query parameter.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-system-replica-links
        
        List file system replication link.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param remote_file_systems: A list of remote_file_systems to query for. Overrides remote_file_system_ids and remote_file_system_names keyword arguments.
        :type remote_file_systems: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param remote_file_system_ids: A comma-separated list of remote file system IDs. If there is not at least one
                                    resource that matches each of the elements, then an error is returned.
                                    This cannot be provided together with the `remote_file_system_names`
                                    query parameter.
        :type remote_file_system_ids: List[str]
        :param remote_file_system_names: A comma-separated list of remote file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with the `remote_file_system_ids` query
                                        parameter.
        :type remote_file_system_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            offset=offset,
            remote_file_system_ids=remote_file_system_ids,
            remote_file_system_names=remote_file_system_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids'], kwargs)
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(remote_file_systems, ['remote_file_system_ids', 'remote_file_system_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['ids', 'local_file_system_ids', 'local_file_system_names', 'remote_file_system_ids', 'remote_file_system_names', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('FileSystemReplicaLinksApi', 'api26_file_system_replica_links_get_with_http_info', kwargs)

    def delete_file_system_replica_links_policies(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE file-system-replica-links/policies
        
        Remove a policy from a file system replication link.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            member_ids=member_ids,
            policy_ids=policy_ids,
            policy_names=policy_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(members, ['member_ids'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['local_file_system_ids', 'local_file_system_names', 'member_ids', 'policy_ids', 'policy_names', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('FileSystemReplicaLinksApi', 'api26_file_system_replica_links_policies_delete_with_http_info', kwargs)

    def get_file_system_replica_links_policies(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        remote_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system IDs. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_names` query parameter.")] = None,
        remote_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_ids` query parameter.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-system-replica-links/policies
        
        List file system replication link policies.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param remote_file_systems: A list of remote_file_systems to query for. Overrides remote_file_system_ids and remote_file_system_names keyword arguments.
        :type remote_file_systems: ReferenceType or List[ReferenceType], optional
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_file_system_ids: A comma-separated list of remote file system IDs. If there is not at least one
                                    resource that matches each of the elements, then an error is returned.
                                    This cannot be provided together with the `remote_file_system_names`
                                    query parameter.
        :type remote_file_system_ids: List[str]
        :param remote_file_system_names: A comma-separated list of remote file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with the `remote_file_system_ids` query
                                        parameter.
        :type remote_file_system_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            member_ids=member_ids,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            remote_file_system_ids=remote_file_system_ids,
            remote_file_system_names=remote_file_system_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(members, ['member_ids'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _process_references(remote_file_systems, ['remote_file_system_ids', 'remote_file_system_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['local_file_system_ids', 'local_file_system_names', 'member_ids', 'policy_ids', 'policy_names', 'remote_file_system_ids', 'remote_file_system_names', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('FileSystemReplicaLinksApi', 'api26_file_system_replica_links_policies_get_with_http_info', kwargs)

    def post_file_system_replica_links_policies(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST file-system-replica-links/policies
        
        Add a policy to a file system replication link.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            member_ids=member_ids,
            policy_ids=policy_ids,
            policy_names=policy_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(members, ['member_ids'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['local_file_system_ids', 'local_file_system_names', 'member_ids', 'policy_ids', 'policy_names', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('FileSystemReplicaLinksApi', 'api26_file_system_replica_links_policies_post_with_http_info', kwargs)

    def post_file_system_replica_links(
        self,
        file_system_replica_link: 'models.FileSystemReplicaLink',
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        remote_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_ids` query parameter.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST file-system-replica-links
        
        Create a file system replication link.
        
        :param file_system_replica_link: (required)
        :type file_system_replica_link: FileSystemReplicaLink
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param remote_file_systems: A list of remote_file_systems to query for. Overrides remote_file_system_names keyword argument.
        :type remote_file_systems: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param remote_file_system_names: A comma-separated list of remote file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with the `remote_file_system_ids` query
                                        parameter.
        :type remote_file_system_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            file_system_replica_link=file_system_replica_link,
            ids=ids,
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            remote_file_system_names=remote_file_system_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids'], kwargs)
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(remote_file_systems, ['remote_file_system_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['ids', 'local_file_system_ids', 'local_file_system_names', 'remote_file_system_names', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('FileSystemReplicaLinksApi', 'api26_file_system_replica_links_post_with_http_info', kwargs)

    def get_file_system_replica_links_transfer(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        names_or_owners: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names_or_owner_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. Either the names of the snapshots or the owning file systems.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-system-replica-links/transfer
        
        List the transfer status details for file system replication.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param names_or_owners: A list of names_or_owners to query for. Overrides names_or_owner_names keyword argument.
        :type names_or_owners: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names_or_owner_names: A comma-separated list of resource names. Either the names of the snapshots or
                                    the owning file systems.
        :type names_or_owner_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names_or_owner_names=names_or_owner_names,
            offset=offset,
            remote_ids=remote_ids,
            remote_names=remote_names,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids'], kwargs)
        _process_references(names_or_owners, ['names_or_owner_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['ids', 'names_or_owner_names', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('FileSystemReplicaLinksApi', 'api26_file_system_replica_links_transfer_get_with_http_info', kwargs)

    def delete_file_system_snapshots(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE file-system-snapshots
        
        Delete a file system snapshot.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('FileSystemSnapshotsApi', 'api26_file_system_snapshots_delete_with_http_info', kwargs)

    def get_file_system_snapshots(
        self,
        owners: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        names_or_owners: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. If not set, lists both objects that are destroyed and those that are not destroyed. If object name(s) are specified in the `names` parameter, then each object referenced must exist. If `destroyed` is set to `true`, then each object referenced must also be destroyed. If `destroyed` is set to `false`, then each object referenced must also not be destroyed. An error is returned if any of these conditions are not met.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names_or_owner_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. Either the names of the snapshots or the owning file systems.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        owner_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of owning file system IDs. If after filtering, there is not at least one resource that matches each of the elements of owner IDs, then an error is returned. This cannot be provided together with the `ids`, `names_or_owner_names`, or `names_or_sources` query parameters.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-system-snapshots
        
        List file system snapshots.
        
        :param owners: A list of owners to query for. Overrides owner_ids keyword argument.
        :type owners: ReferenceType or List[ReferenceType], optional
        :param names_or_owners: A list of names_or_owners to query for. Overrides names_or_owner_names keyword argument.
        :type names_or_owners: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        If not set, lists both objects that are destroyed and those that are not
                        destroyed. If object name(s) are specified in the `names` parameter, then
                        each object referenced must exist. If `destroyed` is set to `true`, then
                        each object referenced must also be destroyed. If `destroyed` is set to
                        `false`, then each object referenced must also not be destroyed. An error is
                        returned if any of these conditions are not met.
        :type destroyed: bool
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names_or_owner_names: A comma-separated list of resource names. Either the names of the snapshots or
                                    the owning file systems.
        :type names_or_owner_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param owner_ids: A comma-separated list of owning file system IDs. If after filtering, there is
                        not at least one resource that matches each of the elements of owner IDs,
                        then an error is returned. This cannot be provided together with the `ids`,
                        `names_or_owner_names`, or `names_or_sources` query parameters.
        :type owner_ids: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names_or_owner_names=names_or_owner_names,
            offset=offset,
            owner_ids=owner_ids,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids'], kwargs)
        _process_references(names_or_owners, ['names_or_owner_names'], kwargs)
        _process_references(owners, ['owner_ids'], kwargs)
        _fixup_list_type_params(['ids', 'names_or_owner_names', 'owner_ids', 'sort'], kwargs)
        return self._call_api('FileSystemSnapshotsApi', 'api26_file_system_snapshots_get_with_http_info', kwargs)

    def patch_file_system_snapshots(
        self,
        file_system_snapshot: 'models.FileSystemSnapshot',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        latest_replica: Annotated[Optional[StrictBool], Field(description="Used when destroying a snapshot. If not present or `false`, and the snapshot is the latest replicated snapshot, then destroy will fail. If `true` or the snapshot is not the latest replicated snapshot, then destroy will be successful.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH file-system-snapshots
        
        Modify file system snapshot attributes.
        
        :param file_system_snapshot: (required)
        :type file_system_snapshot: FileSystemSnapshot
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param latest_replica: Used when destroying a snapshot. If not present or `false`, and the snapshot is
                            the latest replicated snapshot, then destroy will fail. If `true` or the
                            snapshot is not the latest replicated snapshot, then destroy will be
                            successful.
        :type latest_replica: bool
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            file_system_snapshot=file_system_snapshot,
            ids=ids,
            latest_replica=latest_replica,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('FileSystemSnapshotsApi', 'api26_file_system_snapshots_patch_with_http_info', kwargs)

    def delete_file_system_snapshots_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE file-system-snapshots/policies
        
        Remove snapshot scheduling policies from a file system.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('FileSystemSnapshotsApi', 'api26_file_system_snapshots_policies_delete_with_http_info', kwargs)

    def get_file_system_snapshots_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-system-snapshots/policies
        
        List file system snapshots mapped to snapshot scheduling policies.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('FileSystemSnapshotsApi', 'api26_file_system_snapshots_policies_get_with_http_info', kwargs)

    def post_file_system_snapshots(
        self,
        sources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        send: Annotated[Optional[StrictBool], Field(description="Whether to replicate created snapshots immediately to other arrays. If it's `false`, created snapshots may still be replicated to other arrays according to policy.")] = None,
        source_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of source file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `source_ids`, then an error is returned. This cannot be provided together with the `names_or_sources` or `sources` query parameters.")] = None,
        source_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of names for the source of the object. If there is not at least one resource that matches each of the elements of `source_names`, an error is returned.")] = None,
        targets: Annotated[Optional[conlist(StrictStr)], Field(description="The target arrays to replicate created snapshots to. Only valid when `send` is `true`.")] = None,
        file_system_snapshot: Optional['models.FileSystemSnapshotPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST file-system-snapshots
        
        Create a snapshot for a specified source file system. If a source file system is not specified, creates snapshots for all file systems on the array.
        
        :param sources: A list of sources to query for. Overrides source_ids and source_names keyword arguments.
        :type sources: ReferenceType or List[ReferenceType], optional
        :param send: Whether to replicate created snapshots immediately to other arrays. If it's
                    `false`, created snapshots may still be replicated to other arrays according
                    to policy.
        :type send: bool
        :param source_ids: A comma-separated list of source file system IDs. If after filtering, there is
                        not at least one resource that matches each of the elements of `source_ids`,
                        then an error is returned. This cannot be provided together with the
                        `names_or_sources` or `sources` query parameters.
        :type source_ids: List[str]
        :param source_names: A comma-separated list of names for the source of the object. If there is not at
                            least one resource that matches each of the elements of `source_names`, an
                            error is returned.
        :type source_names: List[str]
        :param targets: The target arrays to replicate created snapshots to. Only valid when `send` is
                        `true`.
        :type targets: List[str]
        :param file_system_snapshot:
        :type file_system_snapshot: FileSystemSnapshotPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            send=send,
            source_ids=source_ids,
            source_names=source_names,
            targets=targets,
            file_system_snapshot=file_system_snapshot,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(sources, ['source_ids', 'source_names'], kwargs)
        _fixup_list_type_params(['source_ids', 'source_names', 'targets'], kwargs)
        return self._call_api('FileSystemSnapshotsApi', 'api26_file_system_snapshots_post_with_http_info', kwargs)

    def delete_file_system_snapshots_transfer(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE file-system-snapshots/transfer
        
        Delete file system snapshot transfers from the source array to the target array.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('FileSystemSnapshotsApi', 'api26_file_system_snapshots_transfer_delete_with_http_info', kwargs)

    def get_file_system_snapshots_transfer(
        self,
        names_or_owners: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names_or_owner_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. Either the names of the snapshots or the owning file systems.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-system-snapshots/transfer
        
        List file system snapshot transfers from the source array to the target array.
        
        :param names_or_owners: A list of names_or_owners to query for. Overrides names_or_owner_names keyword argument.
        :type names_or_owners: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names_or_owner_names: A comma-separated list of resource names. Either the names of the snapshots or
                                    the owning file systems.
        :type names_or_owner_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names_or_owner_names=names_or_owner_names,
            offset=offset,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids'], kwargs)
        _process_references(names_or_owners, ['names_or_owner_names'], kwargs)
        _fixup_list_type_params(['ids', 'names_or_owner_names', 'sort'], kwargs)
        return self._call_api('FileSystemSnapshotsApi', 'api26_file_system_snapshots_transfer_get_with_http_info', kwargs)

    def delete_file_systems(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE file-systems
        
        Deletes a file system. Deleting a file system is equivalent to eradication. A file system's `destroyed` parameter must be set to `true` before a file system can be deleted.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('FileSystemsApi', 'api26_file_systems_delete_with_http_info', kwargs)

    def get_file_systems(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. If not set, lists both objects that are destroyed and those that are not destroyed. If object name(s) are specified in the `names` parameter, then each object referenced must exist. If `destroyed` is set to `true`, then each object referenced must also be destroyed. If `destroyed` is set to `false`, then each object referenced must also not be destroyed. An error is returned if any of these conditions are not met.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-systems
        
        List one or more file systems on the array.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        If not set, lists both objects that are destroyed and those that are not
                        destroyed. If object name(s) are specified in the `names` parameter, then
                        each object referenced must exist. If `destroyed` is set to `true`, then
                        each object referenced must also be destroyed. If `destroyed` is set to
                        `false`, then each object referenced must also not be destroyed. An error is
                        returned if any of these conditions are not met.
        :type destroyed: bool
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('FileSystemsApi', 'api26_file_systems_get_with_http_info', kwargs)

    def get_file_systems_groups_performance(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        gids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs. This cannot be provided together with `group_names` query parameter.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group names. This cannot be provided together with `gids` query parameter.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-systems/groups/performance
        
        List a groups I/O performance metrics on a file system.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param gids: A comma-separated list of group IDs. This cannot be provided together with
                    `group_names` query parameter.
        :type gids: List[str]
        :param group_names: A comma-separated list of group names. This cannot be provided together with
                            `gids` query parameter.
        :type group_names: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            gids=gids,
            group_names=group_names,
            limit=limit,
            names=names,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(groups, ['group_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'gids', 'group_names', 'names', 'sort'], kwargs)
        return self._call_api('FileSystemsApi', 'api26_file_systems_groups_performance_get_with_http_info', kwargs)

    def patch_file_systems(
        self,
        file_system: 'models.FileSystemPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        delete_link_on_eradication: Annotated[Optional[StrictBool], Field(description="If set to `true`, the file system can be destroyed, even if it has a replica link. If set to `false`, the file system cannot be destroyed if it has a replica link. Defaults to `false`.")] = None,
        discard_detailed_permissions: Annotated[Optional[StrictBool], Field(description="This parameter must be set to `true` in order to change a file system's `access_control_style` from a style that supports more detailed access control lists to a style that only supports less detailed mode bits as a form of permission control. This parameter may not be set to `true` any other time. Setting this parameter to `true` is acknowledgement that any more detailed access control lists currently set within the file system will be lost, and NFS permission controls will only be enforced at the granularity level of NFS mode bits.")] = None,
        discard_non_snapshotted_data: Annotated[Optional[StrictBool], Field(description="This parameter must be set to `true` in order to restore a file system from a snapshot or to demote a file system (which restores the file system from the common baseline snapshot). Setting this parameter to `true` is acknowledgement that any non-snapshotted data currently in the file system will be irretrievably lost.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        ignore_usage: Annotated[Optional[StrictBool], Field(description="Allow update operations that lead to a `hard_limit_enabled` file system with usage over its provisioned size. The update can be either setting `hard_limit_enabled` when usage is higher than provisioned size, or resize provisioned size to a value under usage when `hard_limit_enabled` is `true`.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH file-systems
        
        Modify a file systems attributes including its export protocols and limits.
        
        :param file_system: (required)
        :type file_system: FileSystemPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param delete_link_on_eradication: If set to `true`, the file system can be destroyed, even if it has a replica
                                        link. If set to `false`, the file system cannot be destroyed if it has a
                                        replica link. Defaults to `false`.
        :type delete_link_on_eradication: bool
        :param discard_detailed_permissions: This parameter must be set to `true` in order to change a file system's
                                            `access_control_style` from a style that supports more detailed access
                                            control lists to a style that only supports less detailed mode bits as
                                            a form of permission control. This parameter may not be set to `true`
                                            any other time. Setting this parameter to `true` is acknowledgement
                                            that any more detailed access control lists currently set within the
                                            file system will be lost, and NFS permission controls will only be
                                            enforced at the granularity level of NFS mode bits.
        :type discard_detailed_permissions: bool
        :param discard_non_snapshotted_data: This parameter must be set to `true` in order to restore a file system from a
                                            snapshot or to demote a file system (which restores the file system
                                            from the common baseline snapshot). Setting this parameter to `true` is
                                            acknowledgement that any non-snapshotted data currently in the file
                                            system will be irretrievably lost.
        :type discard_non_snapshotted_data: bool
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param ignore_usage: Allow update operations that lead to a `hard_limit_enabled` file system with
                            usage over its provisioned size. The update can be either setting
                            `hard_limit_enabled` when usage is higher than provisioned size, or resize
                            provisioned size to a value under usage when `hard_limit_enabled` is
                            `true`.
        :type ignore_usage: bool
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            file_system=file_system,
            delete_link_on_eradication=delete_link_on_eradication,
            discard_detailed_permissions=discard_detailed_permissions,
            discard_non_snapshotted_data=discard_non_snapshotted_data,
            ids=ids,
            ignore_usage=ignore_usage,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('FileSystemsApi', 'api26_file_systems_patch_with_http_info', kwargs)

    def get_file_systems_performance(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        protocol: Annotated[Optional[StrictStr], Field(description="Display the performance of a specified protocol. Valid values are `all`, `HTTP`, `SMB`, `NFS`, and `S3`. If not specified, defaults to `all`, which will provide the combined performance of all available protocols.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-systems/performance
        
        Displays the performance metrics for a file system.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param protocol: Display the performance of a specified protocol. Valid values are `all`, `HTTP`,
                        `SMB`, `NFS`, and `S3`. If not specified, defaults to `all`, which will
                        provide the combined performance of all available protocols.
        :type protocol: str
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            end_time=end_time,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            protocol=protocol,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('FileSystemsApi', 'api26_file_systems_performance_get_with_http_info', kwargs)

    def get_file_systems_policies_all(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-systems/policies-all
        
        List file system policies.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('FileSystemsApi', 'api26_file_systems_policies_all_get_with_http_info', kwargs)

    def delete_file_systems_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE file-systems/policies
        
        Remove a snapshot scheduling policy from a file system.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('FileSystemsApi', 'api26_file_systems_policies_delete_with_http_info', kwargs)

    def get_file_systems_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-systems/policies
        
        List file system snapshot scheduling policies.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('FileSystemsApi', 'api26_file_systems_policies_get_with_http_info', kwargs)

    def post_file_systems_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST file-systems/policies
        
        Apply a snapshot scheduling policy to a file system. Only one file system can be mapped to a policy at a time.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('FileSystemsApi', 'api26_file_systems_policies_post_with_http_info', kwargs)

    def post_file_systems(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        file_system: 'models.FileSystemPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        discard_non_snapshotted_data: Annotated[Optional[StrictBool], Field(description="This parameter must be set to `true` in order to restore a file system from a snapshot or to demote a file system (which restores the file system from the common baseline snapshot). Setting this parameter to `true` is acknowledgement that any non-snapshotted data currently in the file system will be irretrievably lost.")] = None,
        overwrite: Annotated[Optional[StrictBool], Field(description="When used for snapshot restore, overwrites (`true`) an existing file system.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST file-systems
        
        Create a file system on the current array.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param file_system: (required)
        :type file_system: FileSystemPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param discard_non_snapshotted_data: This parameter must be set to `true` in order to restore a file system from a
                                            snapshot or to demote a file system (which restores the file system
                                            from the common baseline snapshot). Setting this parameter to `true` is
                                            acknowledgement that any non-snapshotted data currently in the file
                                            system will be irretrievably lost.
        :type discard_non_snapshotted_data: bool
        :param overwrite: When used for snapshot restore, overwrites (`true`) an existing file system.
        :type overwrite: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            file_system=file_system,
            discard_non_snapshotted_data=discard_non_snapshotted_data,
            overwrite=overwrite,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('FileSystemsApi', 'api26_file_systems_post_with_http_info', kwargs)

    def get_file_systems_users_performance(
        self,
        users: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        uids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of user IDs. This cannot be provided together with `user_names` query parameter.")] = None,
        user_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of user names. This cannot be provided together with `uids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-systems/users/performance
        
        List a users I/O performance metrics on a file system.
        
        :param users: A list of users to query for. Overrides user_names keyword argument.
        :type users: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param uids: A comma-separated list of user IDs. This cannot be provided together with
                    `user_names` query parameter.
        :type uids: List[int]
        :param user_names: A comma-separated list of user names. This cannot be provided together with
                        `uids` query parameter.
        :type user_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            names=names,
            sort=sort,
            total_only=total_only,
            uids=uids,
            user_names=user_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _process_references(users, ['user_names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'names', 'sort', 'uids', 'user_names'], kwargs)
        return self._call_api('FileSystemsApi', 'api26_file_systems_users_performance_get_with_http_info', kwargs)

    def get_hardware(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET hardware
        
        List hardware slots and bays and the status of installed components.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('HardwareApi', 'api26_hardware_get_with_http_info', kwargs)

    def patch_hardware(
        self,
        hardware: 'models.Hardware',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH hardware
        
        Controls the visual identification light of the specified hardware component.
        
        :param hardware: (required)
        :type hardware: Hardware
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            hardware=hardware,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('HardwareApi', 'api26_hardware_patch_with_http_info', kwargs)

    def get_hardware_connectors(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET hardware-connectors
        
        List array connection information.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('HardwareConnectorsApi', 'api26_hardware_connectors_get_with_http_info', kwargs)

    def patch_hardware_connectors(
        self,
        hardware_connector: 'models.HardwareConnector',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH hardware-connectors
        
        Modify array connection information.
        
        :param hardware_connector: (required)
        :type hardware_connector: HardwareConnector
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            hardware_connector=hardware_connector,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('HardwareConnectorsApi', 'api26_hardware_connectors_patch_with_http_info', kwargs)

    def get_hardware_connectors_performance(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET hardware-connectors/performance
        
        Displays network statistics, historical bandwidth, and error reporting for all specified hardware connectors.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            end_time=end_time,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('HardwareConnectorsApi', 'api26_hardware_connectors_performance_get_with_http_info', kwargs)

    def delete_kmip(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a KMIP server configuration
        
        Deletes a KMIP server configuration. A server can only be deleted when not in use by the array.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('KMIPApi', 'api26_kmip_delete_with_http_info', kwargs)

    def get_kmip(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List KMIP server configurations
        
        Displays a list of KMIP server configurations.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('KMIPApi', 'api26_kmip_get_with_http_info', kwargs)

    def patch_kmip(
        self,
        kmip_server: 'models.KmipServer',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify a KMIP server configuration
        
        Modifies KMIP server properties - URI, certificate, certificate group.
        
        :param kmip_server: (required)
        :type kmip_server: KmipServer
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            kmip_server=kmip_server,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('KMIPApi', 'api26_kmip_patch_with_http_info', kwargs)

    def post_kmip(
        self,
        kmip_server: 'models.KmipServer',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a KMIP server configuration
        
        Creates a KMIP server configuration.
        
        :param kmip_server: (required)
        :type kmip_server: KmipServer
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            kmip_server=kmip_server,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('KMIPApi', 'api26_kmip_post_with_http_info', kwargs)

    def get_kmip_test(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Displays KMIP server test results
        
        Displays a detailed result of of KMIP server test.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('KMIPApi', 'api26_kmip_test_get_with_http_info', kwargs)

    def delete_keytabs(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE keytabs
        
        Delete a Kerberos keytab file.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('KeytabsApi', 'api26_keytabs_delete_with_http_info', kwargs)

    def get_keytabs_download(
        self,
        keytabs: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        keytab_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of keytab IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `keytab_names` query parameter.")] = None,
        keytab_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of keytab names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `keytab_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET keytabs/download
        
        Download a Kerberos keytab file. The file can be downloaded in the native binary format or a base64 encoded format. If not specified, defaults to binary.
        
        :param keytabs: A list of keytabs to query for. Overrides keytab_ids and keytab_names keyword arguments.
        :type keytabs: ReferenceType or List[ReferenceType], optional
        :param keytab_ids: A comma-separated list of keytab IDs. If after filtering, there is not at least
                        one resource that matches each of the elements, then an error is returned.
                        This cannot be provided together with the `keytab_names` query parameter.
        :type keytab_ids: List[str]
        :param keytab_names: A comma-separated list of keytab names. If there is not at least one resource
                            that matches each of the elements, then an error is returned. This cannot
                            be provided together with `keytab_ids` query parameter.
        :type keytab_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            keytab_ids=keytab_ids,
            keytab_names=keytab_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(keytabs, ['keytab_ids', 'keytab_names'], kwargs)
        _fixup_list_type_params(['keytab_ids', 'keytab_names'], kwargs)
        return self._call_api('KeytabsApi', 'api26_keytabs_download_get_with_http_info', kwargs)

    def get_keytabs(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET keytabs
        
        List a Kerberos keytab file and its configuration information.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('KeytabsApi', 'api26_keytabs_get_with_http_info', kwargs)

    def post_keytabs(
        self,
        keytab: 'models.KeytabPost',
        name_prefixes: Annotated[Optional[StrictStr], Field(description="The prefix to use for the names of all Kerberos keytab objects that are being created.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST keytabs
        
        Import a Kerberos keytab file from a Key Distribution Center.
        
        :param keytab: (required)
        :type keytab: KeytabPost
        :param name_prefixes: The prefix to use for the names of all Kerberos keytab objects that are being
                            created.
        :type name_prefixes: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            keytab=keytab,
            name_prefixes=name_prefixes,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('KeytabsApi', 'api26_keytabs_post_with_http_info', kwargs)

    def post_keytabs_upload(
        self,
        keytab_file: Annotated[StrictStr, Field(..., description="The keytab file to upload.")],
        name_prefixes: Annotated[Optional[StrictStr], Field(description="The prefix to use for the names of all Kerberos keytab objects that are being created.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST keytabs/upload
        
        Upload a Kerberos keytab file to the array. The file can be uploaded in the native binary format or a base64 encoded format. If not specified, defaults to binary. The procedure to upload a file may vary depending on the type of REST client.
        
        :param keytab_file: The keytab file to upload. (required)
        :type keytab_file: str
        :param name_prefixes: The prefix to use for the names of all Kerberos keytab objects that are being
                            created.
        :type name_prefixes: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            keytab_file=keytab_file,
            name_prefixes=name_prefixes,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('KeytabsApi', 'api26_keytabs_upload_post_with_http_info', kwargs)

    def delete_lifecycle_rules(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket IDs. If after filtering, there is not at least one resource that matches each of the elements of `bucket_ids`, then an error is returned. This cannot be provided together with the `bucket_names` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket names. If there is not at least one resource that matches each of the elements of `bucket_names`, then an error is returned. This cannot be provided together with the `bucket_ids` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE lifecycle-rules
        
        Deletes individual lifecycle rules by name or id, or deletes all rules for a bucket. If `ids` is specified, `bucket_names` or `bucket_ids` is also required. If `bucket_names` or `bucket_ids` are specified without `ids`, delete all the rules for the bucket.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param buckets: A list of buckets to query for. Overrides bucket_ids and bucket_names keyword arguments.
        :type buckets: ReferenceType or List[ReferenceType], optional
        :param bucket_ids: A comma-separated list of bucket IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `bucket_ids`, then an
                        error is returned. This cannot be provided together with the `bucket_names`
                        query parameter. This can be provided with the `ids` query parameter but not
                        with `names`.
        :type bucket_ids: List[str]
        :param bucket_names: A comma-separated list of bucket names. If there is not at least one resource
                            that matches each of the elements of `bucket_names`, then an error is
                            returned. This cannot be provided together with the `bucket_ids` query
                            parameter. This can be provided with the `ids` query parameter but not with
                            `names`.
        :type bucket_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            bucket_ids=bucket_ids,
            bucket_names=bucket_names,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(buckets, ['bucket_ids', 'bucket_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['bucket_ids', 'bucket_names', 'ids', 'names'], kwargs)
        return self._call_api('LifecycleRulesApi', 'api26_lifecycle_rules_delete_with_http_info', kwargs)

    def get_lifecycle_rules(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket IDs. If after filtering, there is not at least one resource that matches each of the elements of `bucket_ids`, then an error is returned. This cannot be provided together with the `bucket_names` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket names. If there is not at least one resource that matches each of the elements of `bucket_names`, then an error is returned. This cannot be provided together with the `bucket_ids` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET lifecycle-rules
        
        Returns a list of lifecycle rules. If `names` is specified, list the individual rules. If `ids` is specified, `bucket_names` or `bucket_ids` is also required. If `bucket_names` or `bucket_ids` are specified without `ids`, list all the rules for the bucket.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param buckets: A list of buckets to query for. Overrides bucket_ids and bucket_names keyword arguments.
        :type buckets: ReferenceType or List[ReferenceType], optional
        :param bucket_ids: A comma-separated list of bucket IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `bucket_ids`, then an
                        error is returned. This cannot be provided together with the `bucket_names`
                        query parameter. This can be provided with the `ids` query parameter but not
                        with `names`.
        :type bucket_ids: List[str]
        :param bucket_names: A comma-separated list of bucket names. If there is not at least one resource
                            that matches each of the elements of `bucket_names`, then an error is
                            returned. This cannot be provided together with the `bucket_ids` query
                            parameter. This can be provided with the `ids` query parameter but not with
                            `names`.
        :type bucket_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            bucket_ids=bucket_ids,
            bucket_names=bucket_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(buckets, ['bucket_ids', 'bucket_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['bucket_ids', 'bucket_names', 'ids', 'names', 'sort'], kwargs)
        return self._call_api('LifecycleRulesApi', 'api26_lifecycle_rules_get_with_http_info', kwargs)

    def patch_lifecycle_rules(
        self,
        lifecycle: 'models.LifecycleRulePatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket IDs. If after filtering, there is not at least one resource that matches each of the elements of `bucket_ids`, then an error is returned. This cannot be provided together with the `bucket_names` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket names. If there is not at least one resource that matches each of the elements of `bucket_names`, then an error is returned. This cannot be provided together with the `bucket_ids` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        confirm_date: Annotated[Optional[StrictBool], Field(description="If set to `true`, then confirm the date of `keep_current_version_until` is correct.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH lifecycle-rules
        
        Modify an existing lifecycle rule by name or id. If `ids` is specified, `bucket_names` or `bucket_ids` is also required.
        
        :param lifecycle: (required)
        :type lifecycle: LifecycleRulePatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param buckets: A list of buckets to query for. Overrides bucket_ids and bucket_names keyword arguments.
        :type buckets: ReferenceType or List[ReferenceType], optional
        :param bucket_ids: A comma-separated list of bucket IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `bucket_ids`, then an
                        error is returned. This cannot be provided together with the `bucket_names`
                        query parameter. This can be provided with the `ids` query parameter but not
                        with `names`.
        :type bucket_ids: List[str]
        :param bucket_names: A comma-separated list of bucket names. If there is not at least one resource
                            that matches each of the elements of `bucket_names`, then an error is
                            returned. This cannot be provided together with the `bucket_ids` query
                            parameter. This can be provided with the `ids` query parameter but not with
                            `names`.
        :type bucket_names: List[str]
        :param confirm_date: If set to `true`, then confirm the date of `keep_current_version_until` is
                            correct.
        :type confirm_date: bool
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            lifecycle=lifecycle,
            bucket_ids=bucket_ids,
            bucket_names=bucket_names,
            confirm_date=confirm_date,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(buckets, ['bucket_ids', 'bucket_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['bucket_ids', 'bucket_names', 'ids', 'names'], kwargs)
        return self._call_api('LifecycleRulesApi', 'api26_lifecycle_rules_patch_with_http_info', kwargs)

    def post_lifecycle_rules(
        self,
        rule: 'models.LifecycleRulePost',
        confirm_date: Annotated[Optional[StrictBool], Field(description="If set to `true`, then confirm the date of `keep_current_version_until` is correct.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST lifecycle-rules
        
        Creates a lifecycle rule. `bucket` and `keep_previous_version_for` are required. If `rule_id` is not specified, it will be automatically generated in the format "fbRuleIdX".
        
        :param rule: (required)
        :type rule: LifecycleRulePost
        :param confirm_date: If set to `true`, then confirm the date of `keep_current_version_until` is
                            correct.
        :type confirm_date: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            rule=rule,
            confirm_date=confirm_date,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('LifecycleRulesApi', 'api26_lifecycle_rules_post_with_http_info', kwargs)

    def delete_link_aggregation_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE link-aggregation-groups
        
        Remove a link aggregation group to unbind the ports.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('LinkAggregationGroupsApi', 'api26_link_aggregation_groups_delete_with_http_info', kwargs)

    def get_link_aggregation_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET link-aggregation-groups
        
        List the status and attributes of the Ethernet ports in the configured link aggregation groups.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('LinkAggregationGroupsApi', 'api26_link_aggregation_groups_get_with_http_info', kwargs)

    def patch_link_aggregation_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        link_aggregation_group: Optional['models.LinkAggregationGroupPatch'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH link-aggregation-groups
        
        Modify link aggregation groups by adding and removing Ethernet ports.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param link_aggregation_group:
        :type link_aggregation_group: LinkAggregationGroupPatch
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            link_aggregation_group=link_aggregation_group,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('LinkAggregationGroupsApi', 'api26_link_aggregation_groups_patch_with_http_info', kwargs)

    def post_link_aggregation_groups(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        link_aggregation_group: 'models.LinkAggregationGroup',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST link-aggregation-groups
        
        Create a link aggregation group of Ethernet ports on the array.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param link_aggregation_group: (required)
        :type link_aggregation_group: LinkAggregationGroup
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            link_aggregation_group=link_aggregation_group,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('LinkAggregationGroupsApi', 'api26_link_aggregation_groups_post_with_http_info', kwargs)

    def get_logs_async_download(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET logs-async/download
        
        Download the files which contain a history of log events from the array to provide to Pure Technical Services for analysis.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('LogsApi', 'api26_logs_async_download_get_with_http_info', kwargs)

    def get_logs_async(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET logs-async
        
        List the attributes and status of preparation for a history of log events from the array to provide to Pure Technical Services for analysis.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('LogsApi', 'api26_logs_async_get_with_http_info', kwargs)

    def patch_logs_async(
        self,
        logs_async: 'models.LogsAsync',
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH logs-async
        
        Start the preparation for a history of log events from the array to provide to Pure Technical Services for analysis.
        
        :param logs_async: (required)
        :type logs_async: LogsAsync
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            logs_async=logs_async,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('LogsApi', 'api26_logs_async_patch_with_http_info', kwargs)

    def get_logs(
        self,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET logs
        
        Download a history of log events from the array to provide to Pure Technical Services for analysis.
        
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            end_time=end_time,
            start_time=start_time,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('LogsApi', 'api26_logs_get_with_http_info', kwargs)

    def delete_network_interfaces(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE network-interfaces
        
        Remove a data VIP. Once removed, any clients connected through the data VIP will lose their connection to the file system.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('NetworkInterfacesApi', 'api26_network_interfaces_delete_with_http_info', kwargs)

    def get_network_interfaces(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET network-interfaces
        
        List network interfaces and their attributes.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('NetworkInterfacesApi', 'api26_network_interfaces_get_with_http_info', kwargs)

    def patch_network_interfaces(
        self,
        network_interface: 'models.NetworkInterfacePatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH network-interfaces
        
        Modify the attributes of a data VIP.
        
        :param network_interface: (required)
        :type network_interface: NetworkInterfacePatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            network_interface=network_interface,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('NetworkInterfacesApi', 'api26_network_interfaces_patch_with_http_info', kwargs)

    def get_network_interfaces_ping(
        self,
        destination: Annotated[StrictStr, Field(..., description="A destination specified by user to run the network diagnosis against. Can be a hostname or an IP.")],
        component_name: Annotated[Optional[StrictStr], Field(description="Used by ping and trace to specify where to run the operation. Valid values are controllers and blades from hardware list. If not specified, defaults to all available controllers and selected blades.")] = None,
        count: Annotated[Optional[StrictInt], Field(description="Used by ping to specify the number of packets to send. If not specified, defaults to 1.")] = None,
        packet_size: Annotated[Optional[StrictInt], Field(description="Used by ping to specify the number of data bytes to be sent per packet. If not specified, defaults to 56.")] = None,
        print_latency: Annotated[Optional[StrictBool], Field(description="Used by ping to specify whether or not to print the full user-to-user latency. If not specified, defaults to false.")] = None,
        resolve_hostname: Annotated[Optional[StrictBool], Field(description="Used by ping and trace to specify whether or not to map IP addresses to host names. If not specified, defaults to true.")] = None,
        source: Annotated[Optional[StrictStr], Field(description="Used by ping and trace to specify the property where to start to run the specified operation. The property can be subnet or IP.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET network-interfaces/ping
        
        Display network interface ping result.
        
        :param destination: A destination specified by user to run the network diagnosis against. Can be a
                            hostname or an IP. (required)
        :type destination: str
        :param component_name: Used by ping and trace to specify where to run the operation. Valid values are
                            controllers and blades from hardware list. If not specified, defaults to
                            all available controllers and selected blades.
        :type component_name: str
        :param count: Used by ping to specify the number of packets to send. If not specified,
                    defaults to 1.
        :type count: int
        :param packet_size: Used by ping to specify the number of data bytes to be sent per packet. If not
                            specified, defaults to 56.
        :type packet_size: int
        :param print_latency: Used by ping to specify whether or not to print the full user-to-user latency.
                            If not specified, defaults to false.
        :type print_latency: bool
        :param resolve_hostname: Used by ping and trace to specify whether or not to map IP addresses to host
                                names. If not specified, defaults to true.
        :type resolve_hostname: bool
        :param source: Used by ping and trace to specify the property where to start to run the
                    specified operation. The property can be subnet or IP.
        :type source: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            destination=destination,
            component_name=component_name,
            count=count,
            packet_size=packet_size,
            print_latency=print_latency,
            resolve_hostname=resolve_hostname,
            source=source,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('NetworkInterfacesApi', 'api26_network_interfaces_ping_get_with_http_info', kwargs)

    def post_network_interfaces(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        network_interface: 'models.NetworkInterface',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST network-interfaces
        
        Create a data VIP to export a file system.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param network_interface: (required)
        :type network_interface: NetworkInterface
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            network_interface=network_interface,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('NetworkInterfacesApi', 'api26_network_interfaces_post_with_http_info', kwargs)

    def get_network_interfaces_trace(
        self,
        destination: Annotated[StrictStr, Field(..., description="A destination specified by user to run the network diagnosis against. Can be a hostname or an IP.")],
        component_name: Annotated[Optional[StrictStr], Field(description="Used by ping and trace to specify where to run the operation. Valid values are controllers and blades from hardware list. If not specified, defaults to all available controllers and selected blades.")] = None,
        discover_mtu: Annotated[Optional[StrictBool], Field(description="Used by trace to specify whether or not to discover the MTU along the path being traced. If not specified, defaults to false.")] = None,
        fragment_packet: Annotated[Optional[StrictBool], Field(description="Used by trace to specify whether or not to fragment packets. If not specified, defaults to true.")] = None,
        method: Annotated[Optional[StrictStr], Field(description="Used by trace to specify which method to use for trace operations. Valid values are `icmp`, `tcp`, and `udp`. If not specified, defaults to 'udp'.")] = None,
        port: Annotated[Optional[StrictStr], Field(description="Used by trace to specify a destination port.")] = None,
        resolve_hostname: Annotated[Optional[StrictBool], Field(description="Used by ping and trace to specify whether or not to map IP addresses to host names. If not specified, defaults to true.")] = None,
        source: Annotated[Optional[StrictStr], Field(description="Used by ping and trace to specify the property where to start to run the specified operation. The property can be subnet or IP.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET network-interfaces/trace
        
        Display network interface trace result.
        
        :param destination: A destination specified by user to run the network diagnosis against. Can be a
                            hostname or an IP. (required)
        :type destination: str
        :param component_name: Used by ping and trace to specify where to run the operation. Valid values are
                            controllers and blades from hardware list. If not specified, defaults to
                            all available controllers and selected blades.
        :type component_name: str
        :param discover_mtu: Used by trace to specify whether or not to discover the MTU along the path being
                            traced. If not specified, defaults to false.
        :type discover_mtu: bool
        :param fragment_packet: Used by trace to specify whether or not to fragment packets. If not specified,
                                defaults to true.
        :type fragment_packet: bool
        :param method: Used by trace to specify which method to use for trace operations. Valid values
                    are `icmp`, `tcp`, and `udp`. If not specified, defaults to 'udp'.
        :type method: str
        :param port: Used by trace to specify a destination port.
        :type port: str
        :param resolve_hostname: Used by ping and trace to specify whether or not to map IP addresses to host
                                names. If not specified, defaults to true.
        :type resolve_hostname: bool
        :param source: Used by ping and trace to specify the property where to start to run the
                    specified operation. The property can be subnet or IP.
        :type source: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            destination=destination,
            component_name=component_name,
            discover_mtu=discover_mtu,
            fragment_packet=fragment_packet,
            method=method,
            port=port,
            resolve_hostname=resolve_hostname,
            source=source,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('NetworkInterfacesApi', 'api26_network_interfaces_trace_get_with_http_info', kwargs)

    def delete_object_store_access_keys(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-access-keys
        
        Delete an object store access key. Once an access key has been deleted, it cannot be recovered.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('ObjectStoreAccessKeysApi', 'api26_object_store_access_keys_delete_with_http_info', kwargs)

    def get_object_store_access_keys(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-access-keys
        
        List object store access keys.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('ObjectStoreAccessKeysApi', 'api26_object_store_access_keys_get_with_http_info', kwargs)

    def patch_object_store_access_keys(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        object_store_access_key: 'models.ObjectStoreAccessKey',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH object-store-access-keys
        
        Enable or disable object store access keys.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param object_store_access_key: (required)
        :type object_store_access_key: ObjectStoreAccessKey
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            object_store_access_key=object_store_access_key,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('ObjectStoreAccessKeysApi', 'api26_object_store_access_keys_patch_with_http_info', kwargs)

    def post_object_store_access_keys(
        self,
        object_store_access_key: 'models.ObjectStoreAccessKeyPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names to import. To import a set of credentials, this field must be specified with the `secret_access_key` body parameter. If both of these are not specified, the system will generate a new set of credentials.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-access-keys
        
        Create or import object store access keys.
        
        :param object_store_access_key: (required)
        :type object_store_access_key: ObjectStoreAccessKeyPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param names: A comma-separated list of resource names to import. To import a set of
                    credentials, this field must be specified with the `secret_access_key` body
                    parameter. If both of these are not specified, the system will generate a new
                    set of credentials.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            object_store_access_key=object_store_access_key,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('ObjectStoreAccessKeysApi', 'api26_object_store_access_keys_post_with_http_info', kwargs)

    def delete_object_store_accounts(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-accounts
        
        Delete an object store account.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('ObjectStoreAccountsApi', 'api26_object_store_accounts_delete_with_http_info', kwargs)

    def get_object_store_accounts(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-accounts
        
        List object store accounts and their attributes.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('ObjectStoreAccountsApi', 'api26_object_store_accounts_get_with_http_info', kwargs)

    def post_object_store_accounts(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-accounts
        
        Create an object store account.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('ObjectStoreAccountsApi', 'api26_object_store_accounts_post_with_http_info', kwargs)

    def delete_object_store_remote_credentials(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-remote-credentials
        
        Delete object store remote credentials.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('ObjectStoreRemoteCredentialsApi', 'api26_object_store_remote_credentials_delete_with_http_info', kwargs)

    def get_object_store_remote_credentials(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-remote-credentials
        
        List object store remote credentials used by bucket replica links to access buckets on remote arrays or targets.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('ObjectStoreRemoteCredentialsApi', 'api26_object_store_remote_credentials_get_with_http_info', kwargs)

    def patch_object_store_remote_credentials(
        self,
        remote_credentials: 'models.ObjectStoreRemoteCredentials',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH object-store-remote-credentials
        
        Rename and/or change the access key/secret key pair for object store remote credentials.
        
        :param remote_credentials: (required)
        :type remote_credentials: ObjectStoreRemoteCredentials
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            remote_credentials=remote_credentials,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('ObjectStoreRemoteCredentialsApi', 'api26_object_store_remote_credentials_patch_with_http_info', kwargs)

    def post_object_store_remote_credentials(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        remote_credentials: 'models.ObjectStoreRemoteCredentialsPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-remote-credentials
        
        Create object store remote credentials to set up bucket replicat links to a remote array or target.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param remote_credentials: (required)
        :type remote_credentials: ObjectStoreRemoteCredentialsPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            remote_credentials=remote_credentials,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('ObjectStoreRemoteCredentialsApi', 'api26_object_store_remote_credentials_post_with_http_info', kwargs)

    def delete_object_store_users(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-users
        
        Delete an object store user.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('ObjectStoreUsersApi', 'api26_object_store_users_delete_with_http_info', kwargs)

    def get_object_store_users(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-users
        
        List object store users and their attributes.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('ObjectStoreUsersApi', 'api26_object_store_users_get_with_http_info', kwargs)

    def delete_object_store_users_object_store_access_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-users/object-store-access-policies
        
        Revoke an object store users access policy.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('ObjectStoreUsersApi', 'api26_object_store_users_object_store_access_policies_delete_with_http_info', kwargs)

    def get_object_store_users_object_store_access_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-users/object-store-access-policies
        
        List object store users and their access policies.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('ObjectStoreUsersApi', 'api26_object_store_users_object_store_access_policies_get_with_http_info', kwargs)

    def post_object_store_users_object_store_access_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-users/object-store-access-policies
        
        Grant access policies to an object store user.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('ObjectStoreUsersApi', 'api26_object_store_users_object_store_access_policies_post_with_http_info', kwargs)

    def post_object_store_users(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        full_access: Annotated[Optional[StrictBool], Field(description="If set to `true`, creates an object store user with full permissions. If set to `false`, creates an object store user with no permission. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-users
        
        Create object store users to administer object storage for an object store account.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param full_access: If set to `true`, creates an object store user with full permissions. If set to
                            `false`, creates an object store user with no permission. If not specified,
                            defaults to `false`.
        :type full_access: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            full_access=full_access,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('ObjectStoreUsersApi', 'api26_object_store_users_post_with_http_info', kwargs)

    def delete_object_store_virtual_hosts(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-virtual-hosts
        
        Delete an object store virtual host.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('ObjectStoreVirtualHostsApi', 'api26_object_store_virtual_hosts_delete_with_http_info', kwargs)

    def get_object_store_virtual_hosts(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-virtual-hosts
        
        List object store virtual hosts.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('ObjectStoreVirtualHostsApi', 'api26_object_store_virtual_hosts_get_with_http_info', kwargs)

    def post_object_store_virtual_hosts(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-virtual-hosts
        
        Create an object store virtual host. An example of a hostname is buckethost.example.com. A hostname cannot exceed 255 characters in length, it cannot be an IP address, only 10 hostnames are supported, supersets or subsets of existing hostnames with the same root are not allowed. The default hostname is s3.amazonaws.com and it cannot be deleted.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('ObjectStoreVirtualHostsApi', 'api26_object_store_virtual_hosts_post_with_http_info', kwargs)

    def get_policies_all(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET policies-all
        
        List all policies of all types.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('PoliciesAllApi', 'api26_policies_all_get_with_http_info', kwargs)

    def get_policies_all_members(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        member_types: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member types. Valid values are `file-systems`, `file-system-snapshots`, `file-system-replica-links`, and `object-store-users`. Different endpoints may accept different subsets of these values.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        remote_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system IDs. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_names` query parameter.")] = None,
        remote_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_ids` query parameter.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET policies-all/members
        
        List policies (of all types) mapped to other entities (file systems, snapshots, file system replica links, and object store users).
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param remote_file_systems: A list of remote_file_systems to query for. Overrides remote_file_system_ids and remote_file_system_names keyword arguments.
        :type remote_file_systems: ReferenceType or List[ReferenceType], optional
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param member_types: A comma-separated list of member types. Valid values are `file-systems`, `file-
                            system-snapshots`, `file-system-replica-links`, and `object-store-users`.
                            Different endpoints may accept different subsets of these values.
        :type member_types: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_file_system_ids: A comma-separated list of remote file system IDs. If there is not at least one
                                    resource that matches each of the elements, then an error is returned.
                                    This cannot be provided together with the `remote_file_system_names`
                                    query parameter.
        :type remote_file_system_ids: List[str]
        :param remote_file_system_names: A comma-separated list of remote file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with the `remote_file_system_ids` query
                                        parameter.
        :type remote_file_system_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            member_ids=member_ids,
            member_names=member_names,
            member_types=member_types,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            remote_file_system_ids=remote_file_system_ids,
            remote_file_system_names=remote_file_system_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _process_references(remote_file_systems, ['remote_file_system_ids', 'remote_file_system_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['local_file_system_ids', 'local_file_system_names', 'member_ids', 'member_names', 'member_types', 'policy_ids', 'policy_names', 'remote_file_system_ids', 'remote_file_system_names', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('PoliciesAllApi', 'api26_policies_all_members_get_with_http_info', kwargs)

    def delete_nfs_export_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        versions: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of versions. This is an optional query param used for concurrency control. The ordering should match the names or ids query param. This will fail with a 412 Precondition failed if the resource was changed and the current version of the resource doesn't match the value in the query param.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE nfs-export-policies
        
        Delete one or more NFS export policies.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param versions: A comma-separated list of versions. This is an optional query param used for
                        concurrency control. The ordering should match the names or ids query param.
                        This will fail with a 412 Precondition failed if the resource was changed
                        and the current version of the resource doesn't match the value in the query
                        param.
        :type versions: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            versions=versions,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'versions'], kwargs)
        return self._call_api('PoliciesNFSApi', 'api26_nfs_export_policies_delete_with_http_info', kwargs)

    def get_nfs_export_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET nfs-export-policies
        
        Displays a list of NFS export policies.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('PoliciesNFSApi', 'api26_nfs_export_policies_get_with_http_info', kwargs)

    def patch_nfs_export_policies(
        self,
        policy: 'models.NfsExportPolicy',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        versions: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of versions. This is an optional query param used for concurrency control. The ordering should match the names or ids query param. This will fail with a 412 Precondition failed if the resource was changed and the current version of the resource doesn't match the value in the query param.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH nfs-export-policies
        
        Modify an existing NFS export policy's attributes.
        
        :param policy: (required)
        :type policy: NfsExportPolicy
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param versions: A comma-separated list of versions. This is an optional query param used for
                        concurrency control. The ordering should match the names or ids query param.
                        This will fail with a 412 Precondition failed if the resource was changed
                        and the current version of the resource doesn't match the value in the query
                        param.
        :type versions: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            policy=policy,
            ids=ids,
            names=names,
            versions=versions,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'versions'], kwargs)
        return self._call_api('PoliciesNFSApi', 'api26_nfs_export_policies_patch_with_http_info', kwargs)

    def post_nfs_export_policies(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policy: Optional['models.NfsExportPolicyPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST nfs-export-policies
        
        Create a new NFS export policy.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param policy:
        :type policy: NfsExportPolicyPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            policy=policy,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('PoliciesNFSApi', 'api26_nfs_export_policies_post_with_http_info', kwargs)

    def delete_nfs_export_policies_rules(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        versions: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of versions. This is an optional query param used for concurrency control. The ordering should match the names or ids query param. This will fail with a 412 Precondition failed if the resource was changed and the current version of the resource doesn't match the value in the query param.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE nfs-export-policies/rules
        
        Delete one or more NFS export policy rules. One of the following is required: `ids` or `names`.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param versions: A comma-separated list of versions. This is an optional query param used for
                        concurrency control. The ordering should match the names or ids query param.
                        This will fail with a 412 Precondition failed if the resource was changed
                        and the current version of the resource doesn't match the value in the query
                        param.
        :type versions: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            versions=versions,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'versions'], kwargs)
        return self._call_api('PoliciesNFSApi', 'api26_nfs_export_policies_rules_delete_with_http_info', kwargs)

    def get_nfs_export_policies_rules(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET nfs-export-policies/rules
        
        Displays a list of NFS export policy rules. The default sort is by policy name, then index.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesNFSApi', 'api26_nfs_export_policies_rules_get_with_http_info', kwargs)

    def patch_nfs_export_policies_rules(
        self,
        rule: 'models.NfsExportPolicyRule',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        before_rule_id: Annotated[Optional[StrictStr], Field(description="The id of the rule to insert or move a rule before. This cannot be provided together with the `before_rule_name` query parameter.")] = None,
        before_rule_name: Annotated[Optional[StrictStr], Field(description="The name of the rule to insert or move a rule before. This cannot be provided together with the `before_rule_id` query parameter.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        versions: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of versions. This is an optional query param used for concurrency control. The ordering should match the names or ids query param. This will fail with a 412 Precondition failed if the resource was changed and the current version of the resource doesn't match the value in the query param.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH nfs-export-policies/rules
        
        Modify an existing NFS export policy rule. If `before_rule_id` or `before_rule_name` are specified, the rule will be moved before that rule. Rules are ordered in three groups; ip addresses, other and `*` and can only be moved within the appropriate group. One of the following is required: `ids` or `names`.
        
        :param rule: (required)
        :type rule: NfsExportPolicyRule
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param before_rule_id: The id of the rule to insert or move a rule before. This cannot be provided
                            together with the `before_rule_name` query parameter.
        :type before_rule_id: str
        :param before_rule_name: The name of the rule to insert or move a rule before. This cannot be provided
                                together with the `before_rule_id` query parameter.
        :type before_rule_name: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param versions: A comma-separated list of versions. This is an optional query param used for
                        concurrency control. The ordering should match the names or ids query param.
                        This will fail with a 412 Precondition failed if the resource was changed
                        and the current version of the resource doesn't match the value in the query
                        param.
        :type versions: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            rule=rule,
            before_rule_id=before_rule_id,
            before_rule_name=before_rule_name,
            ids=ids,
            names=names,
            versions=versions,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'versions'], kwargs)
        return self._call_api('PoliciesNFSApi', 'api26_nfs_export_policies_rules_patch_with_http_info', kwargs)

    def post_nfs_export_policies_rules(
        self,
        rule: 'models.NfsExportPolicyRule',
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        before_rule_id: Annotated[Optional[StrictStr], Field(description="The id of the rule to insert or move a rule before. This cannot be provided together with the `before_rule_name` query parameter.")] = None,
        before_rule_name: Annotated[Optional[StrictStr], Field(description="The name of the rule to insert or move a rule before. This cannot be provided together with the `before_rule_id` query parameter.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        versions: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of versions. This is an optional query param used for concurrency control. The ordering should match the names or ids query param. This will fail with a 412 Precondition failed if the resource was changed and the current version of the resource doesn't match the value in the query param.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST nfs-export-policies/rules
        
        Add a NFS export policy rule. Rules are ordered in three groups; ip addresses, other and `*`. The new rule will be added at the end of the appropriate group if neither `before_rule_id` and `before_rule_name` are specified. Rules can only be inserted into the appropriate group. Either `policy_ids` or `policy_names` parameter is required.
        
        :param rule: (required)
        :type rule: NfsExportPolicyRule
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param before_rule_id: The id of the rule to insert or move a rule before. This cannot be provided
                            together with the `before_rule_name` query parameter.
        :type before_rule_id: str
        :param before_rule_name: The name of the rule to insert or move a rule before. This cannot be provided
                                together with the `before_rule_id` query parameter.
        :type before_rule_name: str
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param versions: A comma-separated list of versions. This is an optional query param used for
                        concurrency control. The ordering should match the names or ids query param.
                        This will fail with a 412 Precondition failed if the resource was changed
                        and the current version of the resource doesn't match the value in the query
                        param.
        :type versions: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            rule=rule,
            before_rule_id=before_rule_id,
            before_rule_name=before_rule_name,
            policy_ids=policy_ids,
            policy_names=policy_names,
            versions=versions,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['policy_ids', 'policy_names', 'versions'], kwargs)
        return self._call_api('PoliciesNFSApi', 'api26_nfs_export_policies_rules_post_with_http_info', kwargs)

    def delete_object_store_access_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-access-policies
        
        Delete one or more access policies.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('PoliciesObjectStoreAccessApi', 'api26_object_store_access_policies_delete_with_http_info', kwargs)

    def get_object_store_access_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        exclude_rules: Annotated[Optional[StrictBool], Field(description="If true, the rules field in each policy will be null. If false, each returned policy will include its list of rules in the response. If not specified, defaults to `false`.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-access-policies
        
        List access policies and their attributes.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param exclude_rules: If true, the rules field in each policy will be null. If false, each returned
                            policy will include its list of rules in the response. If not specified,
                            defaults to `false`.
        :type exclude_rules: bool
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            exclude_rules=exclude_rules,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('PoliciesObjectStoreAccessApi', 'api26_object_store_access_policies_get_with_http_info', kwargs)

    def delete_object_store_access_policies_object_store_users(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-access-policies/object-store-users
        
        Revokes an object store user's access policy.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesObjectStoreAccessApi', 'api26_object_store_access_policies_object_store_users_delete_with_http_info', kwargs)

    def get_object_store_access_policies_object_store_users(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-access-policies/object-store-users
        
        List object store users and their access policies.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesObjectStoreAccessApi', 'api26_object_store_access_policies_object_store_users_get_with_http_info', kwargs)

    def post_object_store_access_policies_object_store_users(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-access-policies/object-store-users
        
        Grant access policies to an object store user.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesObjectStoreAccessApi', 'api26_object_store_access_policies_object_store_users_post_with_http_info', kwargs)

    def patch_object_store_access_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        enforce_action_restrictions: Annotated[Optional[StrictBool], Field(description="Certain combinations of actions and other rule elements are inherently ignored if specified together in a rule. If set to `true`, operations which attempt to set these combinations will fail. If set to `false`, such operations will instead be allowed. Defaults to `true`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        policy: Optional['models.ObjectStoreAccessPolicyPatch'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH object-store-access-policies
        
        Modify the rules of an object store access policy.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param enforce_action_restrictions: Certain combinations of actions and other rule elements are inherently ignored
                                            if specified together in a rule. If set to `true`, operations which
                                            attempt to set these combinations will fail. If set to `false`, such
                                            operations will instead be allowed. Defaults to `true`.
        :type enforce_action_restrictions: bool
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param policy:
        :type policy: ObjectStoreAccessPolicyPatch
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            enforce_action_restrictions=enforce_action_restrictions,
            ids=ids,
            names=names,
            policy=policy,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('PoliciesObjectStoreAccessApi', 'api26_object_store_access_policies_patch_with_http_info', kwargs)

    def post_object_store_access_policies(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        enforce_action_restrictions: Annotated[Optional[StrictBool], Field(description="Certain combinations of actions and other rule elements are inherently ignored if specified together in a rule. If set to `true`, operations which attempt to set these combinations will fail. If set to `false`, such operations will instead be allowed. Defaults to `true`.")] = None,
        policy: Optional['models.ObjectStoreAccessPolicyPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-access-policies
        
        Create a new access policy.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param enforce_action_restrictions: Certain combinations of actions and other rule elements are inherently ignored
                                            if specified together in a rule. If set to `true`, operations which
                                            attempt to set these combinations will fail. If set to `false`, such
                                            operations will instead be allowed. Defaults to `true`.
        :type enforce_action_restrictions: bool
        :param policy:
        :type policy: ObjectStoreAccessPolicyPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            enforce_action_restrictions=enforce_action_restrictions,
            policy=policy,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('PoliciesObjectStoreAccessApi', 'api26_object_store_access_policies_post_with_http_info', kwargs)

    def delete_object_store_access_policies_rules(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-access-policies-rules
        
        Delete one or more access policy rules.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesObjectStoreAccessApi', 'api26_object_store_access_policies_rules_delete_with_http_info', kwargs)

    def get_object_store_access_policies_rules(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-access-policies-rules
        
        List access policy rules and their attributes.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            names=names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesObjectStoreAccessApi', 'api26_object_store_access_policies_rules_get_with_http_info', kwargs)

    def patch_object_store_access_policies_rules(
        self,
        rule: 'models.PolicyRuleObjectAccess',
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        enforce_action_restrictions: Annotated[Optional[StrictBool], Field(description="Certain combinations of actions and other rule elements are inherently ignored if specified together in a rule. If set to `true`, operations which attempt to set these combinations will fail. If set to `false`, such operations will instead be allowed. Defaults to `true`.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH object-store-access-policies-rules
        
        Modify an access policy rule's attributes.
        
        :param rule: (required)
        :type rule: PolicyRuleObjectAccess
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param enforce_action_restrictions: Certain combinations of actions and other rule elements are inherently ignored
                                            if specified together in a rule. If set to `true`, operations which
                                            attempt to set these combinations will fail. If set to `false`, such
                                            operations will instead be allowed. Defaults to `true`.
        :type enforce_action_restrictions: bool
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            rule=rule,
            enforce_action_restrictions=enforce_action_restrictions,
            names=names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesObjectStoreAccessApi', 'api26_object_store_access_policies_rules_patch_with_http_info', kwargs)

    def post_object_store_access_policies_rules(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        rule: 'models.PolicyRuleObjectAccessPost',
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        enforce_action_restrictions: Annotated[Optional[StrictBool], Field(description="Certain combinations of actions and other rule elements are inherently ignored if specified together in a rule. If set to `true`, operations which attempt to set these combinations will fail. If set to `false`, such operations will instead be allowed. Defaults to `true`.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-access-policies-rules
        
        Create a new access policy rule.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param rule: (required)
        :type rule: PolicyRuleObjectAccessPost
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param enforce_action_restrictions: Certain combinations of actions and other rule elements are inherently ignored
                                            if specified together in a rule. If set to `true`, operations which
                                            attempt to set these combinations will fail. If set to `false`, such
                                            operations will instead be allowed. Defaults to `true`.
        :type enforce_action_restrictions: bool
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            rule=rule,
            enforce_action_restrictions=enforce_action_restrictions,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesObjectStoreAccessApi', 'api26_object_store_access_policies_rules_post_with_http_info', kwargs)

    def get_object_store_access_policy_actions(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-access-policy-actions
        
        List valid actions for access policy rules. Each action is either a valid AWS S3 action (prefixed by `s3:`) or our special wildcard action (`s3:*`). Each action, when included in a rule, may restrict which other properties may be set for that rule.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('PoliciesObjectStoreAccessApi', 'api26_object_store_access_policy_actions_get_with_http_info', kwargs)

    def delete_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE policies
        
        Delete one or more snapshot scheduling policies.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('PoliciesSnapshotApi', 'api26_policies_delete_with_http_info', kwargs)

    def delete_policies_file_system_replica_links(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE policies/file-system-replica-links
        
        Remove a snapshot scheduling policy mapped to a file system replica link.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            member_ids=member_ids,
            policy_ids=policy_ids,
            policy_names=policy_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(members, ['member_ids'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['local_file_system_ids', 'local_file_system_names', 'member_ids', 'policy_ids', 'policy_names', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('PoliciesSnapshotApi', 'api26_policies_file_system_replica_links_delete_with_http_info', kwargs)

    def get_policies_file_system_replica_links(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        remote_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system IDs. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_names` query parameter.")] = None,
        remote_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_ids` query parameter.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET policies/file-system-replica-links
        
        List snapshot scheduling policies for file system replica links.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param remote_file_systems: A list of remote_file_systems to query for. Overrides remote_file_system_ids and remote_file_system_names keyword arguments.
        :type remote_file_systems: ReferenceType or List[ReferenceType], optional
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_file_system_ids: A comma-separated list of remote file system IDs. If there is not at least one
                                    resource that matches each of the elements, then an error is returned.
                                    This cannot be provided together with the `remote_file_system_names`
                                    query parameter.
        :type remote_file_system_ids: List[str]
        :param remote_file_system_names: A comma-separated list of remote file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with the `remote_file_system_ids` query
                                        parameter.
        :type remote_file_system_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            member_ids=member_ids,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            remote_file_system_ids=remote_file_system_ids,
            remote_file_system_names=remote_file_system_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(members, ['member_ids'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _process_references(remote_file_systems, ['remote_file_system_ids', 'remote_file_system_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['local_file_system_ids', 'local_file_system_names', 'member_ids', 'policy_ids', 'policy_names', 'remote_file_system_ids', 'remote_file_system_names', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('PoliciesSnapshotApi', 'api26_policies_file_system_replica_links_get_with_http_info', kwargs)

    def post_policies_file_system_replica_links(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST policies/file-system-replica-links
        
        Add a snapshot scheduling policy to a file system replica link.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            member_ids=member_ids,
            policy_ids=policy_ids,
            policy_names=policy_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(members, ['member_ids'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['local_file_system_ids', 'local_file_system_names', 'member_ids', 'policy_ids', 'policy_names', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('PoliciesSnapshotApi', 'api26_policies_file_system_replica_links_post_with_http_info', kwargs)

    def delete_policies_file_system_snapshots(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE policies/file-system-snapshots
        
        Remove the snapshot scheduling policy mapped to a file system.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesSnapshotApi', 'api26_policies_file_system_snapshots_delete_with_http_info', kwargs)

    def get_policies_file_system_snapshots(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET policies/file-system-snapshots
        
        List file system snapshots mapped to a snapshot scheduling policy.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesSnapshotApi', 'api26_policies_file_system_snapshots_get_with_http_info', kwargs)

    def delete_policies_file_systems(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE policies/file-systems
        
        Remove the snapshot scheduling policy mapped to a file system.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesSnapshotApi', 'api26_policies_file_systems_delete_with_http_info', kwargs)

    def get_policies_file_systems(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET policies/file-systems
        
        List file systems mapped to a snapshot scheduling policy.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesSnapshotApi', 'api26_policies_file_systems_get_with_http_info', kwargs)

    def post_policies_file_systems(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST policies/file-systems
        
        Map a file system to a snapshot scheduling policy.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesSnapshotApi', 'api26_policies_file_systems_post_with_http_info', kwargs)

    def get_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET policies
        
        Display snapshot scheduling policies and their attributes.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('PoliciesSnapshotApi', 'api26_policies_get_with_http_info', kwargs)

    def get_policies_members(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        member_types: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member types. Valid values are `file-systems`, `file-system-snapshots`, `file-system-replica-links`, and `object-store-users`. Different endpoints may accept different subsets of these values.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        remote_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system IDs. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_names` query parameter.")] = None,
        remote_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_ids` query parameter.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET policies/members
        
        List snapshot scheduling policies mapped to file systems, snapshots, and file system replica links.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param remote_file_systems: A list of remote_file_systems to query for. Overrides remote_file_system_ids and remote_file_system_names keyword arguments.
        :type remote_file_systems: ReferenceType or List[ReferenceType], optional
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param member_types: A comma-separated list of member types. Valid values are `file-systems`, `file-
                            system-snapshots`, `file-system-replica-links`, and `object-store-users`.
                            Different endpoints may accept different subsets of these values.
        :type member_types: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_file_system_ids: A comma-separated list of remote file system IDs. If there is not at least one
                                    resource that matches each of the elements, then an error is returned.
                                    This cannot be provided together with the `remote_file_system_names`
                                    query parameter.
        :type remote_file_system_ids: List[str]
        :param remote_file_system_names: A comma-separated list of remote file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with the `remote_file_system_ids` query
                                        parameter.
        :type remote_file_system_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            member_ids=member_ids,
            member_names=member_names,
            member_types=member_types,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            remote_file_system_ids=remote_file_system_ids,
            remote_file_system_names=remote_file_system_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _process_references(remote_file_systems, ['remote_file_system_ids', 'remote_file_system_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['local_file_system_ids', 'local_file_system_names', 'member_ids', 'member_names', 'member_types', 'policy_ids', 'policy_names', 'remote_file_system_ids', 'remote_file_system_names', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('PoliciesSnapshotApi', 'api26_policies_members_get_with_http_info', kwargs)

    def patch_policies(
        self,
        policy: 'models.PolicyPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        destroy_snapshots: Annotated[Optional[StrictBool], Field(description="This parameter must be set to `true` in order to modify a policy such that local or remote snapshots would be destroyed.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH policies
        
        Modify a snapshot scheduling policys attributes for when and how often snapshots are created and how long they are retained.
        
        :param policy: (required)
        :type policy: PolicyPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param destroy_snapshots: This parameter must be set to `true` in order to modify a policy such that local
                                or remote snapshots would be destroyed.
        :type destroy_snapshots: bool
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            policy=policy,
            destroy_snapshots=destroy_snapshots,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('PoliciesSnapshotApi', 'api26_policies_patch_with_http_info', kwargs)

    def post_policies(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policy: Optional['models.Policy'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST policies
        
        Create a new snapshot scheduling policy with rule attributes to capture file system snapshots for a set period of time and frequency, as well as how long snapshots are retained before being destroyed and eradicated.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param policy:
        :type policy: Policy
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            policy=policy,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('PoliciesSnapshotApi', 'api26_policies_post_with_http_info', kwargs)

    def delete_quotas_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        gids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of group IDs. If there is not at least one resource that matches each of the elements of `gids`, then an error is returned. This cannot be provided together with `group_names` query parameter.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group names. If there is not at least one resource that matches each of the elements of `group_names`, then an error is returned. This cannot be provided together with `gids` query parameter.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE quotas/groups
        
        Delete a hard limit quota for a group.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param gids: A comma-separated list of group IDs. If there is not at least one resource that
                    matches each of the elements of `gids`, then an error is returned. This
                    cannot be provided together with `group_names` query parameter.
        :type gids: List[int]
        :param group_names: A comma-separated list of group names. If there is not at least one resource
                            that matches each of the elements of `group_names`, then an error is
                            returned. This cannot be provided together with `gids` query parameter.
        :type group_names: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            gids=gids,
            group_names=group_names,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(groups, ['group_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'gids', 'group_names', 'names'], kwargs)
        return self._call_api('QuotasApi', 'api26_quotas_groups_delete_with_http_info', kwargs)

    def get_quotas_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        gids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of group IDs. If there is not at least one resource that matches each of the elements of `gids`, then an error is returned. This cannot be provided together with `group_names` query parameter.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group names. If there is not at least one resource that matches each of the elements of `group_names`, then an error is returned. This cannot be provided together with `gids` query parameter.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET quotas/groups
        
        List groups with hard limit quotas.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param gids: A comma-separated list of group IDs. If there is not at least one resource that
                    matches each of the elements of `gids`, then an error is returned. This
                    cannot be provided together with `group_names` query parameter.
        :type gids: List[int]
        :param group_names: A comma-separated list of group names. If there is not at least one resource
                            that matches each of the elements of `group_names`, then an error is
                            returned. This cannot be provided together with `gids` query parameter.
        :type group_names: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            gids=gids,
            group_names=group_names,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(groups, ['group_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'gids', 'group_names', 'names', 'sort'], kwargs)
        return self._call_api('QuotasApi', 'api26_quotas_groups_get_with_http_info', kwargs)

    def patch_quotas_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        gids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of group IDs. If there is not at least one resource that matches each of the elements of `gids`, then an error is returned. This cannot be provided together with `group_names` query parameter.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group names. If there is not at least one resource that matches each of the elements of `group_names`, then an error is returned. This cannot be provided together with `gids` query parameter.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        quota: Optional['models.GroupQuotaPatch'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH quotas/groups
        
        Modify a quota for a group. Note that if you modify a group's quota to a lower value and that group's usage has already exceeded the new value, writes will automatically halt until usage decreases below the new quota setting.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param gids: A comma-separated list of group IDs. If there is not at least one resource that
                    matches each of the elements of `gids`, then an error is returned. This
                    cannot be provided together with `group_names` query parameter.
        :type gids: List[int]
        :param group_names: A comma-separated list of group names. If there is not at least one resource
                            that matches each of the elements of `group_names`, then an error is
                            returned. This cannot be provided together with `gids` query parameter.
        :type group_names: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param quota:
        :type quota: GroupQuotaPatch
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            gids=gids,
            group_names=group_names,
            names=names,
            quota=quota,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(groups, ['group_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'gids', 'group_names', 'names'], kwargs)
        return self._call_api('QuotasApi', 'api26_quotas_groups_patch_with_http_info', kwargs)

    def post_quotas_groups(
        self,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        gids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of group IDs. If there is not at least one resource that matches each of the elements of `gids`, then an error is returned. This cannot be provided together with `group_names` query parameter.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group names. If there is not at least one resource that matches each of the elements of `group_names`, then an error is returned. This cannot be provided together with `gids` query parameter.")] = None,
        quota: Optional['models.GroupQuotaPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST quotas/groups
        
        Create a hard limit quota for a group.
        
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param gids: A comma-separated list of group IDs. If there is not at least one resource that
                    matches each of the elements of `gids`, then an error is returned. This
                    cannot be provided together with `group_names` query parameter.
        :type gids: List[int]
        :param group_names: A comma-separated list of group names. If there is not at least one resource
                            that matches each of the elements of `group_names`, then an error is
                            returned. This cannot be provided together with `gids` query parameter.
        :type group_names: List[str]
        :param quota:
        :type quota: GroupQuotaPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            gids=gids,
            group_names=group_names,
            quota=quota,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(groups, ['group_names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'gids', 'group_names'], kwargs)
        return self._call_api('QuotasApi', 'api26_quotas_groups_post_with_http_info', kwargs)

    def get_quotas_settings(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET quotas-settings
        
        List notification attributes of a group or user quota.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('QuotasApi', 'api26_quotas_settings_get_with_http_info', kwargs)

    def patch_quotas_settings(
        self,
        quota_setting: 'models.QuotaSetting',
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH quotas-settings
        
        Modify the notification attributes of a group or user quota.
        
        :param quota_setting: (required)
        :type quota_setting: QuotaSetting
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            quota_setting=quota_setting,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('QuotasApi', 'api26_quotas_settings_patch_with_http_info', kwargs)

    def delete_quotas_users(
        self,
        users: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        uids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of user IDs. If there is not at least one resource that matches each of the elements of `uids`, then an error is returned. This cannot be provided together with `user_names` query parameter.")] = None,
        user_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of user names. If there is not at least one resource that matches each of the elements of `user_names`, then an error is returned. This cannot be provided together with `uids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE quotas/users
        
        Delete a hard limit file system quota for a user.
        
        :param users: A list of users to query for. Overrides user_names keyword argument.
        :type users: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param uids: A comma-separated list of user IDs. If there is not at least one resource that
                    matches each of the elements of `uids`, then an error is returned. This
                    cannot be provided together with `user_names` query parameter.
        :type uids: List[int]
        :param user_names: A comma-separated list of user names. If there is not at least one resource that
                        matches each of the elements of `user_names`, then an error is returned.
                        This cannot be provided together with `uids` query parameter.
        :type user_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            names=names,
            uids=uids,
            user_names=user_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _process_references(users, ['user_names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'names', 'uids', 'user_names'], kwargs)
        return self._call_api('QuotasApi', 'api26_quotas_users_delete_with_http_info', kwargs)

    def get_quotas_users(
        self,
        users: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        uids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of user IDs. If there is not at least one resource that matches each of the elements of `uids`, then an error is returned. This cannot be provided together with `user_names` query parameter.")] = None,
        user_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of user names. If there is not at least one resource that matches each of the elements of `user_names`, then an error is returned. This cannot be provided together with `uids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET quotas/users
        
        List users with hard limit file system quotas.
        
        :param users: A list of users to query for. Overrides user_names keyword argument.
        :type users: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param uids: A comma-separated list of user IDs. If there is not at least one resource that
                    matches each of the elements of `uids`, then an error is returned. This
                    cannot be provided together with `user_names` query parameter.
        :type uids: List[int]
        :param user_names: A comma-separated list of user names. If there is not at least one resource that
                        matches each of the elements of `user_names`, then an error is returned.
                        This cannot be provided together with `uids` query parameter.
        :type user_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            uids=uids,
            user_names=user_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _process_references(users, ['user_names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'names', 'sort', 'uids', 'user_names'], kwargs)
        return self._call_api('QuotasApi', 'api26_quotas_users_get_with_http_info', kwargs)

    def patch_quotas_users(
        self,
        users: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        uids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of user IDs. If there is not at least one resource that matches each of the elements of `uids`, then an error is returned. This cannot be provided together with `user_names` query parameter.")] = None,
        user_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of user names. If there is not at least one resource that matches each of the elements of `user_names`, then an error is returned. This cannot be provided together with `uids` query parameter.")] = None,
        quota: Optional['models.UserQuotaPatch'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH quotas/users
        
        Modify the attributes of a hard limit file system quota. Note that if you modify a user's quota to a lower value and that users usage has already exceeded the new value, writes will automatically halt until usage decreases below the new quota setting.
        
        :param users: A list of users to query for. Overrides user_names keyword argument.
        :type users: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param uids: A comma-separated list of user IDs. If there is not at least one resource that
                    matches each of the elements of `uids`, then an error is returned. This
                    cannot be provided together with `user_names` query parameter.
        :type uids: List[int]
        :param user_names: A comma-separated list of user names. If there is not at least one resource that
                        matches each of the elements of `user_names`, then an error is returned.
                        This cannot be provided together with `uids` query parameter.
        :type user_names: List[str]
        :param quota:
        :type quota: UserQuotaPatch
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            names=names,
            uids=uids,
            user_names=user_names,
            quota=quota,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _process_references(users, ['user_names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'names', 'uids', 'user_names'], kwargs)
        return self._call_api('QuotasApi', 'api26_quotas_users_patch_with_http_info', kwargs)

    def post_quotas_users(
        self,
        users: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        uids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of user IDs. If there is not at least one resource that matches each of the elements of `uids`, then an error is returned. This cannot be provided together with `user_names` query parameter.")] = None,
        user_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of user names. If there is not at least one resource that matches each of the elements of `user_names`, then an error is returned. This cannot be provided together with `uids` query parameter.")] = None,
        quota: Optional['models.UserQuotaPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST quotas/users
        
        Create a hard limit file system quota for a user.
        
        :param users: A list of users to query for. Overrides user_names keyword argument.
        :type users: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param uids: A comma-separated list of user IDs. If there is not at least one resource that
                    matches each of the elements of `uids`, then an error is returned. This
                    cannot be provided together with `user_names` query parameter.
        :type uids: List[int]
        :param user_names: A comma-separated list of user names. If there is not at least one resource that
                        matches each of the elements of `user_names`, then an error is returned.
                        This cannot be provided together with `uids` query parameter.
        :type user_names: List[str]
        :param quota:
        :type quota: UserQuotaPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            uids=uids,
            user_names=user_names,
            quota=quota,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(users, ['user_names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'uids', 'user_names'], kwargs)
        return self._call_api('QuotasApi', 'api26_quotas_users_post_with_http_info', kwargs)

    def get_rapid_data_locking(
        self,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Get the status of the Rapid Data Locking feature.
        
        Displays the status of the Rapid Data Locking feature.
        
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('RDLApi', 'api26_rapid_data_locking_get_with_http_info', kwargs)

    def patch_rapid_data_locking(
        self,
        rapid_data_locking: 'models.RapidDataLocking',
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modifies the Rapid Data Locking feature.
        
        Modifies the Rapid Data Locking feature. Note that the feature can only be enabled if there are no file systems nor buckets created on the array. Once enabled, the feature cannot be modified.
        
        :param rapid_data_locking: (required)
        :type rapid_data_locking: RapidDataLocking
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            rapid_data_locking=rapid_data_locking,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('RDLApi', 'api26_rapid_data_locking_patch_with_http_info', kwargs)

    def post_rapid_data_locking_rotate(
        self,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Rotates the external keys on the associated EKM appliance.
        
        Rotates the external keys on the associated EKM appliance.
        
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('RDLApi', 'api26_rapid_data_locking_rotate_post_with_http_info', kwargs)

    def get_rapid_data_locking_test(
        self,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Displays Rapid Data Locking test results.
        
        Displays a detailed result of a Rapid Data Locking test.
        
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('RDLApi', 'api26_rapid_data_locking_test_get_with_http_info', kwargs)

    def get_roles(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET roles
        
        List roles and permission attributes for role-based access control (RBAC).
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('RolesApi', 'api26_roles_get_with_http_info', kwargs)

    def get_smtp_servers(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET smtp-servers
        
        List SMTP server attributes for the array network.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SMTPApi', 'api26_smtp_servers_get_with_http_info', kwargs)

    def patch_smtp_servers(
        self,
        smtp: 'models.SmtpServer',
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH smtp-servers
        
        Modify SMTP server attributes such as the relay host and sender domain.
        
        :param smtp: (required)
        :type smtp: SmtpServer
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            smtp=smtp,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('SMTPApi', 'api26_smtp_servers_patch_with_http_info', kwargs)

    def get_snmp_agents(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET snmp-agents
        
        List SNMP agent attributes.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SNMPAgentsApi', 'api26_snmp_agents_get_with_http_info', kwargs)

    def get_snmp_agents_mib(
        self,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET snmp-agents-mib
        
        List the SNMP MIB text.
        
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('SNMPAgentsApi', 'api26_snmp_agents_mib_get_with_http_info', kwargs)

    def patch_snmp_agents(
        self,
        snmp_agent: 'models.SnmpAgent',
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH snmp-agents
        
        Modify SNMP agent attributes.
        
        :param snmp_agent: (required)
        :type snmp_agent: SnmpAgent
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            snmp_agent=snmp_agent,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('SNMPAgentsApi', 'api26_snmp_agents_patch_with_http_info', kwargs)

    def delete_snmp_managers(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE snmp-managers
        
        Remove an SNMP manager.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SNMPManagersApi', 'api26_snmp_managers_delete_with_http_info', kwargs)

    def get_snmp_managers(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET snmp-managers
        
        List SNMP managers and their attributes.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SNMPManagersApi', 'api26_snmp_managers_get_with_http_info', kwargs)

    def patch_snmp_managers(
        self,
        snmp_manager: 'models.SnmpManager',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH snmp-managers
        
        Modify SNMP manager attributes such as versions.
        
        :param snmp_manager: (required)
        :type snmp_manager: SnmpManager
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            snmp_manager=snmp_manager,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SNMPManagersApi', 'api26_snmp_managers_patch_with_http_info', kwargs)

    def post_snmp_managers(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        snmp_manager: 'models.SnmpManagerPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST snmp-managers
        
        Create an SNMP manager.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param snmp_manager: (required)
        :type snmp_manager: SnmpManagerPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            snmp_manager=snmp_manager,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('SNMPManagersApi', 'api26_snmp_managers_post_with_http_info', kwargs)

    def get_snmp_managers_test(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET snmp-managers/test
        
        Test if the configuration of an SNMP manager is valid.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SNMPManagersApi', 'api26_snmp_managers_test_get_with_http_info', kwargs)

    def get_sessions(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List session data
        
        Displays session data for user login events performed in the Purity//FB GUI, CLI, and REST API.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SessionsApi', 'api26_sessions_get_with_http_info', kwargs)

    def delete_subnets(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE subnets
        
        Remove an array subnet.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SubnetsApi', 'api26_subnets_delete_with_http_info', kwargs)

    def get_subnets(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET subnets
        
        List the arrays subnets.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SubnetsApi', 'api26_subnets_get_with_http_info', kwargs)

    def patch_subnets(
        self,
        subnet: 'models.Subnet',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH subnets
        
        Modify array subnet attributes.
        
        :param subnet: (required)
        :type subnet: Subnet
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            subnet=subnet,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SubnetsApi', 'api26_subnets_patch_with_http_info', kwargs)

    def post_subnets(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        subnet: 'models.Subnet',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST subnets
        
        Create an array subnet.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param subnet: (required)
        :type subnet: Subnet
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            subnet=subnet,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('SubnetsApi', 'api26_subnets_post_with_http_info', kwargs)

    def get_support(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET support
        
        List Phone Home and Remote Assistance settings.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SupportApi', 'api26_support_get_with_http_info', kwargs)

    def patch_support(
        self,
        support: 'models.Support',
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH support
        
        Modify Phone Home and Remote Assistance settings.
        
        :param support: (required)
        :type support: Support
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            support=support,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('SupportApi', 'api26_support_patch_with_http_info', kwargs)

    def get_support_test(
        self,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        test_type: Annotated[Optional[StrictStr], Field(description="Specify the type of test. Valid values are `all`, `phonehome` and `remote-assist`. If not specified, defaults to `all`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET support-test
        
        Test if the Phone Home and Remote Assistance settings are functioning properly.
        
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param test_type: Specify the type of test. Valid values are `all`, `phonehome` and `remote-
                        assist`. If not specified, defaults to `all`.
        :type test_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            filter=str(filter) if isinstance(filter, Filter) else filter,
            sort=sort,
            test_type=test_type,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('SupportApi', 'api26_support_test_get_with_http_info', kwargs)

    def delete_syslog_servers(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE syslog-servers
        
        Delete a configured syslog server and stop forwarding syslog messages.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SyslogApi', 'api26_syslog_servers_delete_with_http_info', kwargs)

    def get_syslog_servers(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET syslog-servers
        
        Return a list of configured syslog servers.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SyslogApi', 'api26_syslog_servers_get_with_http_info', kwargs)

    def patch_syslog_servers(
        self,
        syslog_server: 'models.SyslogServerPostOrPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH syslog-servers
        
        Modify the URI of a configured syslog server.
        
        :param syslog_server: (required)
        :type syslog_server: SyslogServerPostOrPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            syslog_server=syslog_server,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SyslogApi', 'api26_syslog_servers_patch_with_http_info', kwargs)

    def post_syslog_servers(
        self,
        syslog_server: 'models.SyslogServerPostOrPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST syslog-servers
        
        Configure a new syslog server. Transmission of syslog messages is enabled immediately.
        
        :param syslog_server: (required)
        :type syslog_server: SyslogServerPostOrPatch
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            syslog_server=syslog_server,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('SyslogApi', 'api26_syslog_servers_post_with_http_info', kwargs)

    def get_syslog_servers_settings(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET syslog-servers/settings
        
        List the certificate or certificate group associated with the syslog servers.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SyslogApi', 'api26_syslog_servers_settings_get_with_http_info', kwargs)

    def patch_syslog_servers_settings(
        self,
        syslog_server_settings: 'models.SyslogServerSettings',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH syslog-servers/settings
        
        Modify the certificate or certificate group associated with the syslog servers.
        
        :param syslog_server_settings: (required)
        :type syslog_server_settings: SyslogServerSettings
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            syslog_server_settings=syslog_server_settings,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SyslogApi', 'api26_syslog_servers_settings_patch_with_http_info', kwargs)

    def get_syslog_servers_test(
        self,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET syslog-servers/test
        
        Send test messages to conifgured remote syslog servers.
        
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('SyslogApi', 'api26_syslog_servers_test_get_with_http_info', kwargs)

    def delete_targets(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE targets
        
        Delete the connection to the target for replication.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('TargetsApi', 'api26_targets_delete_with_http_info', kwargs)

    def get_targets(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET targets
        
        List targets used for replication.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('TargetsApi', 'api26_targets_get_with_http_info', kwargs)

    def patch_targets(
        self,
        target: 'models.Target',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH targets
        
        Modify the target attributes for replication.
        
        :param target: (required)
        :type target: Target
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            target=target,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('TargetsApi', 'api26_targets_patch_with_http_info', kwargs)

    def get_targets_performance_replication(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET targets/performance/replication
        
        List replication performance metrics for targets.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            end_time=end_time,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('TargetsApi', 'api26_targets_performance_replication_get_with_http_info', kwargs)

    def post_targets(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        target: 'models.TargetPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST targets
        
        Add a target for replication.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param target: (required)
        :type target: TargetPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            target=target,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('TargetsApi', 'api26_targets_post_with_http_info', kwargs)

    def get_usage_groups(
        self,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        gids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of group IDs. If there is not at least one resource that matches each of the elements of `gids`, then an error is returned. This cannot be provided together with `group_names` query parameter.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group names. If there is not at least one resource that matches each of the elements of `group_names`, then an error is returned. This cannot be provided together with `gids` query parameter.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET usage/groups
        
        List groups with hard limit quotas and their file system usage.
        
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param gids: A comma-separated list of group IDs. If there is not at least one resource that
                    matches each of the elements of `gids`, then an error is returned. This
                    cannot be provided together with `group_names` query parameter.
        :type gids: List[int]
        :param group_names: A comma-separated list of group names. If there is not at least one resource
                            that matches each of the elements of `group_names`, then an error is
                            returned. This cannot be provided together with `gids` query parameter.
        :type group_names: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            gids=gids,
            group_names=group_names,
            limit=limit,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(groups, ['group_names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'gids', 'group_names', 'sort'], kwargs)
        return self._call_api('UsageApi', 'api26_usage_groups_get_with_http_info', kwargs)

    def get_usage_users(
        self,
        users: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        uids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of user IDs. If there is not at least one resource that matches each of the elements of `uids`, then an error is returned. This cannot be provided together with `user_names` query parameter.")] = None,
        user_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of user names. If there is not at least one resource that matches each of the elements of `user_names`, then an error is returned. This cannot be provided together with `uids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET usage/users
        
        List users with hard limit quotas and their file system usage.
        
        :param users: A list of users to query for. Overrides user_names keyword argument.
        :type users: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param uids: A comma-separated list of user IDs. If there is not at least one resource that
                    matches each of the elements of `uids`, then an error is returned. This
                    cannot be provided together with `user_names` query parameter.
        :type uids: List[int]
        :param user_names: A comma-separated list of user names. If there is not at least one resource that
                        matches each of the elements of `user_names`, then an error is returned.
                        This cannot be provided together with `uids` query parameter.
        :type user_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            offset=offset,
            sort=sort,
            uids=uids,
            user_names=user_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(users, ['user_names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'sort', 'uids', 'user_names'], kwargs)
        return self._call_api('UsageApi', 'api26_usage_users_get_with_http_info', kwargs)

    def get_versions(
        self,
        async_req=False,  # type: bool
        _return_http_data_only=False,  # type: bool
        _preload_content=True,  # type: bool
        _request_timeout=None,  # type: Optional[int]
    ):
        # type: (...) -> dict
        """
        Get available API versions. No authentication is required to access this
        endpoint.  The response will be a ValidResponse with version ids listed as items.

        Args:

            async_req (bool, optional):
                Request runs in separate thread and method returns
                multiprocessing.pool.ApplyResult.
            _return_http_data_only (bool, optional):
                Returns only data field.
            _preload_content (bool, optional):
                Response is converted into objects.
            _request_timeout (int, optional):
                Total request timeout in seconds.

        Returns:
            ValidResponse: If the call was successful.
            ErrorResponse: If the call was not successful.

        Raises:
            PureError: If calling the API fails.
            ValueError: If a parameter is of an invalid type.
            TypeError: If invalid or missing parameters are used.
        """
        kwargs = dict(
            async_req=async_req,
            _return_http_data_only=_return_http_data_only,
            _preload_content=_preload_content,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        return self._call_api('AuthorizationApi', 'api_api_version_get_with_http_info', kwargs, response_creator=self._create_api_versions_response)

    def logout(
        self,
        async_req=False,  # type: bool
        _return_http_data_only=False,  # type: bool
        _preload_content=True,  # type: bool
        _request_timeout=None,  # type: Optional[int]
    ):
        # type: (...) -> None
        """
        Invalidate a REST session token.

        Args:

            async_req (bool, optional):
                Request runs in separate thread and method returns
                multiprocessing.pool.ApplyResult.
            _return_http_data_only (bool, optional):
                Returns only data field.
            _preload_content (bool, optional):
                Response is converted into objects.
            _request_timeout (int, optional):
                Total request timeout in seconds.

        Returns:
            ValidResponse: If the call was successful.
            ErrorResponse: If the call was not successful.

        Raises:
            PureError: If calling the API fails.
            ValueError: If a parameter is of an invalid type.
            TypeError: If invalid or missing parameters are used.
        """
        kwargs = dict(
            async_req=async_req,
            _return_http_data_only=_return_http_data_only,
            _preload_content=_preload_content,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        res = self._call_api('AuthorizationApi', 'api_logout_post_with_http_info', kwargs, response_creator=self._create_logout_response)
        # Note: The normal behavior when a call returns a 401 or 403 authentication error status
        # is to reset the authentication token and retry. This effectively logs the client in again.
        # Setting _retries to 0 prevents this behavior for any future calls with this client.
        self._retries = 0
        return res

    def _set_auth_header(self, refresh=False):
        """
        Set the authorization or x-auth-token header of the internal client with the access
        token.

        Args:
            refresh (bool, optional): Whether to retrieve a new access token.
                Defaults to False.

        Raises:
            PureError: If there was an error retrieving the access token.
        """
        if isinstance(self._token_man, TokenManager):
            self._api_client.set_default_header(Headers.authorization,
                                                self._token_man.get_header(refresh=refresh))
        else:
            self._api_client.set_default_header(Headers.x_auth_token,
                                                self._token_man.get_session_token(refresh=refresh))

    def _call_api(self, api_class_name, api_function_name, kwargs, response_creator=None):
        """
        Call the API function and process the response. May call the API
        repeatedly if the request failed for a reason that may not persist in
        the next call.

        Args:
            api_function (function): Swagger-generated function to call.
            kwargs (dict): kwargs to pass to the function.
            response_creator: optional method to generate a ValidResponse from a non-standard endpoint.
                              If None, use the standard _create_valid_response method.

        Returns:
            ValidResponse: If the call was successful.
            ErrorResponse: If the call was not successful.

        Raises:
            PureError: If calling the API fails.
            ValueError: If a parameter is of an invalid type.
            TypeError: If invalid or missing parameters are used.
        """
        kwargs['_request_timeout'] = self._timeout
        if 'x_request_id' in kwargs and not kwargs['x_request_id']:
            kwargs['x_request_id'] = str(uuid.uuid4())

        if kwargs.get('authorization') is not None:
            warnings.warn("authorization parameter is deprecated, and will be removed soon.", DeprecationWarning)

        retries = self._retries
        api_function = getattr(self.__get_api_instance(api_class_name), api_function_name)
        while True:
            try:
                response = api_function(**kwargs)
                # Call was successful (200)
                if response_creator:
                    return response_creator(response, api_function, kwargs)
                else:
                    return self._create_valid_response(response, api_function, kwargs)
            except ApiException as error:
                # If no chance for retries, return the error
                if retries == 0:
                    return self._create_error_response(error)
                # If bad request or not found, return the error (it will never work)
                elif error.status in [400, 404]:
                    return self._create_error_response(error)
                # If authentication error, reset access token and retry
                elif error.status in [401, 403]:
                    self._set_auth_header(refresh=True)
                # If rate limit error, wait the proper time and try again
                elif error.status == 429:
                    # If the the minute limit hit, wait that long
                    if (int(error.headers.get(Headers.x_ratelimit_remaining_min))
                            == int(error.headers.get(Headers.x_ratelimit_min))):
                        time.sleep(60)
                    # Otherwise it was the second limit and only wait a second
                    time.sleep(1)
                # If some internal server error we know nothing about, return
                elif error.status == 500:
                    return self._create_error_response(error)
                # If internal server errors that has to do with timeouts, try again
                elif error.status > 500:
                    pass
                # If error with the swagger client, raise the error
                else:
                    raise PureError(error)
            retries = retries - 1

    def __get_api_instance(self, api_class):
        """
        Get the API instance for the given class.

        Args:
            api_class (class): Swagger-generated api class.

        Returns:
            class: API instance for the given class.
        """
        if api_class not in self.__apis_instances:
            self.__apis_instances[api_class] = getattr(api, api_class)(self._api_client)
        return self.__apis_instances[api_class]

    def _create_valid_response(self, response: ApiResponse, endpoint, kwargs):
        """
        Create a ValidResponse from a Swagger response.

        Args:
            response ApiResponse:
                Body, status, header tuple as returned from Swagger client.
            endpoint (function):
                The function of the Swagger client that was called.
            kwargs (dict):
                The processed kwargs that were passed to the endpoint function.

        Returns:
            ValidResponse
        """
        if response.headers and "content-type" in response.headers.keys() and response.headers["content-type"] in ["application/octet-stream", "text/plain"]:
            body = self._create_file(response)
        else:
            body = response.data
        headers = response.headers

        continuation_token = getattr(body, "continuation_token", None)
        total_item_count = getattr(body, "total_item_count", None)
        total = getattr(body, "total", None)
        more_items_remaining = getattr(body, "more_items_remaining", None)
        items = None

        if body is not None:
            # if body is a file then should be a singleton list
            body_items = [body] if type(body) == str else body.items
            items = iter(ItemIterator(self, endpoint, kwargs,
                                      continuation_token, total_item_count,
                                      body_items,
                                      headers.get(Headers.x_request_id, None),
                                      more_items_remaining or False))
        return ValidResponse(response.status_code, continuation_token, total_item_count,
                             items, headers, total, more_items_remaining)

    def _create_file(self, response):
        path = tempfile.mkdtemp(dir=self._api_client.configuration.temp_folder_path)

        content_disposition = response.headers["Content-Disposition"]
        if content_disposition:
            filename = re.search(r'filename=[\'"]?([^\'"\s]+)[\'"]?',
                                 content_disposition).group(1)
            path = os.path.join(os.path.dirname(path), filename)

        with open(path, "wb") as f:
            response_data = response.data
            if type(response_data) == str:
                response_data = response_data.encode('utf-8')
            f.write(response_data)

        return path

    def _create_api_versions_response(self, response: ApiResponse, endpoint, kwargs):
        """
        Create a ValidResponse from an ApiVersion Swagger response.

        Args:
            response ApiResponse:
                Body, status, header tuple as returned from Swagger client.
            endpoint (function):
                The function of the Swagger client that was called.
            kwargs (dict):
                The processed kwargs that were passed to the endpoint function.

        Returns:
            ValidResponse
        """
        body = response.data
        headers = response.headers

        continuation_token = None
        total_item_count = None
        total = None
        more_items_remaining = None
        items = None

        if body is not None:
            # if body is a file then should be a singleton list
            body_items = [body] if type(body) == str else body.versions
            items = iter(ItemIterator(self, endpoint, kwargs,
                                      continuation_token, total_item_count,
                                      body_items,
                                      headers.get(Headers.x_request_id, None),
                                      more_items_remaining or False))
        response = ValidResponse(response.status_code, continuation_token, total_item_count,
                                 items, headers, total, more_items_remaining)
        return response


    def _create_logout_response(self, response: ApiResponse, endpoint, kwargs):
        """
           A logout response only contains the status field.
        """
        headers = response.headers

        continuation_token = None
        total_item_count = None
        total = None
        more_items_remaining = None
        items = None
        return ValidResponse(response.status_code, continuation_token, total_item_count,
                             items, headers, total, more_items_remaining)


    def _create_error_response(self, error):
        """
        Create an ErrorResponse from a Swagger error.

        Args:
            error (ApiException):
                Error returned by Swagger client.

        Returns:
            ErrorResponse
        """
        status = error.status
        try:
            body = json.loads(error.body)
        except Exception:
            errors = [ApiError(None, "Response is not a valid JSON")]
            return ErrorResponse(status, errors, headers=error.headers)

        if not isinstance(body, dict):
            errors = [ApiError(None, "Response is not an Error object")]
            return ErrorResponse(status, errors, headers=error.headers)

        if status in [403, 429]:
            # Parse differently if the error message came from kong
            errors = [ApiError(None, body.get(Responses.message, None))]
        else:
            errors = [ApiError(err.get(Responses.context, None),
                               err.get(Responses.message, None))
                      for err in body.get(Responses.errors, [])]
        return ErrorResponse(status, errors, headers=error.headers)


def _process_references(
    references: Optional[Union[ReferenceType, List[ReferenceType]]],
    params: List[str],
    kwargs: Dict[str, Any]
) -> None:

    """Process reference objects into a list of ids or names.
    Removes ids and names arguments.

    :param references: The references from which to extract ids or names.
    :type references: ReferenceType or List[ReferenceType], optional

    :param params: The parameters to be overridden.
    :type params: List[str]

    :param kwargs: The kwargs to process.
    :type kwargs: Dict[str, Any]

    :raise PureError: If a reference does not have an id or name.

    """
    if references is not None:
        if not isinstance(references, list):
            references = [references]
        for param in params:
            kwargs.pop(param, None)
        all_have_id = all(ref.id is not None for ref in references)
        all_have_name = all(ref.name is not None for ref in references)
        id_param = [param for param in params if param.endswith("ids")]
        name_param = [param for param in params if param.endswith("names")]
        if all_have_id and len(id_param) > 0:
            kwargs[id_param[0]] = [ref.id for ref in references]
        elif all_have_name and len(name_param) > 0:
            kwargs[name_param[0]] = [ref.name for ref in references]
        else:
            raise PureError('Invalid reference for {}'.format(", ".join(params)))


def _fixup_list_type_params(
    params: List[str],
    kwargs: Dict[str, Any]
) -> None:

    """Process object into a list if it expected to be list type.

    :param params: The parameters to be overridden.
    :type params: List[str]

    :param kwargs: The kwargs to process.
    :type kwargs: Dict[str, Any]

    """
    for _param in params:
        _value = kwargs.get(_param, None)
        if _value is not None and not isinstance(_value, list):
            _param_type = type(_value).__name__.replace("'", '')
            warnings.warn(f"'{_param}' parameter, invalid type: expected List[{_param_type}] but received {_param_type}, converting to list. Please revisit code.", SyntaxWarning)
            kwargs[_param] = [_value]


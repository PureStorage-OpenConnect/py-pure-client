import json
import ssl
import time
import urllib3
import uuid
import warnings

from typing import Any, Dict, List, Optional, Tuple, Union
from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, conint, conlist, constr, validator
from typing_extensions import Annotated

from pypureclient.reference_type import ReferenceType
from pypureclient._version import __default_user_agent__ as DEFAULT_USER_AGENT
from pypureclient.api_token_manager import APITokenManager
from pypureclient.client_settings import resolve_ssl_validation
from pypureclient.exceptions import PureError
from pypureclient.keywords import Headers, Responses
from pypureclient.properties import Property, Filter
from pypureclient.responses import ValidResponse, ErrorResponse, ApiError, ItemIterator, ResponseHeaders
from pypureclient.token_manager import TokenManager

from .api_client import ApiClient
from .api_response import ApiResponse
from .rest import ApiException
from .configuration import Configuration

from . import api
from . import models


class Client(object):
    DEFAULT_RETRIES = 5
    USER_AGENT = DEFAULT_USER_AGENT

    def __init__(self, target, id_token=None, private_key_file=None, private_key_password=None,
                 username=None, client_id=None, key_id=None, issuer=None, api_token=None,
                 retries=DEFAULT_RETRIES, timeout=None, ssl_cert=None, user_agent=None,
                 verify_ssl=None):
        """
        Initialize a FlashBlade Client. id_token is generated based on app ID and private
        key info. Either id_token or api_token could be used for authentication. Only one
        authentication option is allowed.

        Keyword args:
            target (str, required):
                The target array's IP or hostname.
            id_token (str, optional):
                The security token that represents the identity of the party on
                behalf of whom the request is being made, issued by an enabled
                API client on the array. Overrides given private key.
            private_key_file (str, optional):
                The path of the private key to use. Defaults to None.
            private_key_password (str, optional):
                The password of the private key. Defaults to None.
            username (str, optional):
                Username of the user the token should be issued for. This must
                be a valid user in the system.
            client_id (str, optional):
                ID of API client that issued the identity token.
            key_id (str, optional):
                Key ID of API client that issued the identity token.
            issuer (str, optional):
                API client's trusted identity issuer on the array.
            api_token (str, optional):
                API token for the user.
            retries (int, optional):
                The number of times to retry an API call if it fails for a
                non-blocking reason. Defaults to 5.
            timeout int or (float, float), optional:
                The timeout duration in seconds, either in total time or
                (connect and read) times. Defaults to None.
            ssl_cert (str, optional):
                SSL certificate to use. Defaults to None.
            user_agent (str, optional):
                User-Agent request header to use.
            verify_ssl (bool | str, optional):
                Controls SSL certificate validation.
                `True` specifies that the server validation uses default trust anchors;
                `False` switches certificate validation off, **not safe!**;
                It also accepts string value for a path to directory with certificates.

        Raises:
            PureError: If it could not create an ID or access token
        """
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        config = Configuration()
        config.verify_ssl = resolve_ssl_validation(verify_ssl)
        config.ssl_ca_cert = ssl_cert
        config.host = self._get_base_url(target)

        effective_user_agent = user_agent or self.USER_AGENT

        if id_token and api_token:
            raise PureError("Only one authentication option is allowed. Please use either id_token or api_token and try again!")
        elif private_key_file and private_key_password and username and \
                key_id and client_id and issuer and api_token:
            raise PureError("id_token is generated based on app ID and private key info. Please use either id_token or api_token and try again!")
        elif api_token:
            api_token_auth_endpoint = self._get_api_token_endpoint(target)
            api_token_dispose_endpoint = self._get_api_token_dispose_endpoint(target)
            self._token_man = APITokenManager(
                api_token_auth_endpoint,
                api_token,
                verify_ssl=config.verify_ssl,
                token_dispose_endpoint=api_token_dispose_endpoint,
                user_agent=effective_user_agent
            )
        else:
            auth_endpoint = 'https://{}/oauth2/1.0/token'.format(target)
            headers = {
                'kid': key_id
            }
            payload = {
                'iss': issuer,
                'aud': client_id,
                'sub': username,
            }
            self._token_man = TokenManager(auth_endpoint, id_token, private_key_file, private_key_password,
                                           payload=payload, headers=headers, verify_ssl=config.verify_ssl)

        self._api_client = ApiClient(configuration=config)
        self._api_client.user_agent = effective_user_agent
        self._set_agent_header()
        self._set_auth_header()
        self.models = models

        # Read timeout and retries
        self._retries = retries
        self._timeout = timeout
        self.__apis_instances = {
            'AuthorizationApi': api.AuthorizationApi(self._api_client)
        }

    def __del__(self):
        # Cleanup this REST API client resources
        _api_client_attr = getattr(self, '_api_client', None) # using getattr to avoid raising exception, if we failed too early
        if _api_client_attr:
            _api_client_attr.close()

    def get_access_token(self, refresh=False):
        """
        Get the last used access token.

        Args:
            refresh (bool, optional):
                Whether to retrieve a new access token. Defaults to False.

        Returns:
            str

        Raises:
            PureError: If there was an error retrieving an access token.
        """
        return self._token_man.get_access_token(refresh)

    def disable_verify_ssl(self):
        """ Change our certificate requirements so that a certificate is not validated. """
        self._api_client.rest_client.pool_manager.connection_pool_kw['cert_reqs'] = ssl.CERT_NONE

    def enable_verify_ssl(self, ca_certs_file_path=None):
        """ Change our certificate requirements so that a certificate is required and validated.
        Optionally, if a CA certificate(s) file path is provided, configure the client to use
        that CA certificate file.
        """
        if ca_certs_file_path:
            self.configure_ca_certificate_file(ca_certs_file_path)
        self._api_client.rest_client.pool_manager.connection_pool_kw['cert_reqs'] = ssl.CERT_REQUIRED

    def configure_ca_certificate_file(self, ca_certs_file_path):
        """"
        :param ca_certs_file_path: The path to the CA certificate(s) file to use.
        :return:
        """
        self._api_client.rest_client.pool_manager.connection_pool_kw['ca_certs'] = ca_certs_file_path

    def delete_api_clients(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE api-clients  # noqa: E501
        
        Delete the API client.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_api_clients_delete_with_http_info(ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('APIClientsApi', 'api20_api_clients_delete_with_http_info', kwargs)

    def get_api_clients(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET api-clients  # noqa: E501
        
        List an API client and its configuration attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_api_clients_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('APIClientsApi', 'api20_api_clients_get_with_http_info', kwargs)

    def patch_api_clients(
        self,
        api_clients: 'models.ApiClient',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH api-clients  # noqa: E501
        
        Modify an API client. Newly created API clients can be enabled by setting the `enabled` parameter to `true`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_api_clients_patch_with_http_info(api_clients, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param api_clients: (required)
        :type api_clients: models.ApiClient
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            api_clients=api_clients,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('APIClientsApi', 'api20_api_clients_patch_with_http_info', kwargs)

    def post_api_clients(
        self,
        api_client: 'models.ApiClientsPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST api-clients  # noqa: E501
        
        Create an API client to authorize Access Token or Bearer Tokens for use on the array. Required fields include `issuer`, `public_key`, and `access_token_ttl_in_ms`. After creating an API client, it can only be enabled by an authorized user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_api_clients_post_with_http_info(api_client, names, async_req=True)
        >>> result = thread.get()
        
        :param api_client: (required)
        :type api_client: models.ApiClientsPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            api_client=api_client,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('APIClientsApi', 'api20_api_clients_post_with_http_info', kwargs)

    def delete_active_directory(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        local_only: Annotated[Optional[StrictBool], Field(description="If specified as `true`, only delete the Active Directory configuration on the local array, without deleting the computer account created in the Active Directory domain. If not specified, defaults to `false`.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE active-directory  # noqa: E501
        
        Delete an Active Directory account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_active_directory_delete_with_http_info(ids, local_only, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param local_only: If specified as `true`, only delete the Active Directory configuration on the
                        local array, without deleting the computer account created in the Active
                        Directory domain. If not specified, defaults to `false`.
        :type local_only: bool
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            local_only=local_only,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('ActiveDirectoryApi', 'api20_active_directory_delete_with_http_info', kwargs)

    def get_active_directory(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET active-directory  # noqa: E501
        
        List an Active Directory account and its configuration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_active_directory_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('ActiveDirectoryApi', 'api20_active_directory_get_with_http_info', kwargs)

    def patch_active_directory(
        self,
        active_directory: 'models.ActiveDirectoryPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH active-directory  # noqa: E501
        
        Modify the configuration of an Active Directory account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_active_directory_patch_with_http_info(active_directory, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param active_directory: (required)
        :type active_directory: models.ActiveDirectoryPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            active_directory=active_directory,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('ActiveDirectoryApi', 'api20_active_directory_patch_with_http_info', kwargs)

    def post_active_directory(
        self,
        active_directory: 'models.ActiveDirectoryPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        join_existing_account: Annotated[Optional[StrictBool], Field(description="If specified as `true`, the domain is searched for a pre-existing computer account to join to, and no new account will be created within the domain. The `user` specified when joining to a pre-existing account must have permissions to 'read attributes from' and 'reset the password of' the pre-existing account. `service_principal_names`, `encryption_types`, and `join_ou` will be read from the pre-existing account and cannot be specified when joining to an existing account. If not specified, defaults to `false`.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST active-directory  # noqa: E501
        
        Join an Active Directory domain and generate keytabs for the registered SPNs and supported encryption types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_active_directory_post_with_http_info(active_directory, join_existing_account, names, async_req=True)
        >>> result = thread.get()
        
        :param active_directory: (required)
        :type active_directory: models.ActiveDirectoryPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param join_existing_account: If specified as `true`, the domain is searched for a pre-existing computer
                                    account to join to, and no new account will be created within the domain.
                                    The `user` specified when joining to a pre-existing account must have
                                    permissions to 'read attributes from' and 'reset the password of' the
                                    pre-existing account. `service_principal_names`, `encryption_types`, and
                                    `join_ou` will be read from the pre-existing account and cannot be
                                    specified when joining to an existing account. If not specified, defaults
                                    to `false`.
        :type join_existing_account: bool
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            active_directory=active_directory,
            join_existing_account=join_existing_account,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('ActiveDirectoryApi', 'api20_active_directory_post_with_http_info', kwargs)

    def get_active_directory_test(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET active-directory/test  # noqa: E501
        
        Testing if the configuration of an Active Directory account is valid.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_active_directory_test_get_with_http_info(filter, ids, limit, names, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('ActiveDirectoryApi', 'api20_active_directory_test_get_with_http_info', kwargs)

    def delete_admins_api_tokens(
        self,
        admins: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        admin_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of admin IDs. If after filtering, there is not at least one admin resource that matches each of the elements, then an error is returned. This cannot be provided together with the `admin_names` query parameter.")] = None,
        admin_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of admin names. If there is not at least one admin resource that matches each of the elements, then an error is returned. This cannot be provided together with `admin_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE admins/api-tokens  # noqa: E501
        
        Deletes the API tokens of the specified administrators.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_admins_api_tokens_delete_with_http_info(admin_ids, admin_names, async_req=True)
        >>> result = thread.get()
        
        :param admins: A list of admins to query for. Overrides admin_ids and admin_names keyword arguments.
        :type admins: ReferenceType or List[ReferenceType], optional
        :param admin_ids: A comma-separated list of admin IDs. If after filtering, there is not at least
                        one admin resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `admin_names` query
                        parameter.
        :type admin_ids: List[str]
        :param admin_names: A comma-separated list of admin names. If there is not at least one admin
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `admin_ids` query parameter.
        :type admin_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            admin_ids=admin_ids,
            admin_names=admin_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(admins, ['admin_ids', 'admin_names'], kwargs)
        _fixup_list_type_params(['admin_ids', 'admin_names'], kwargs)
        return self._call_api('AdministratorsApi', 'api20_admins_api_tokens_delete_with_http_info', kwargs)

    def get_admins_api_tokens(
        self,
        admins: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        admin_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of admin IDs. If after filtering, there is not at least one admin resource that matches each of the elements, then an error is returned. This cannot be provided together with the `admin_names` query parameter.")] = None,
        admin_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of admin names. If there is not at least one admin resource that matches each of the elements, then an error is returned. This cannot be provided together with `admin_ids` query parameter.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        expose_api_token: Annotated[Optional[StrictBool], Field(description="If `true`, exposes the API token of the current user.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET admins/api-tokens  # noqa: E501
        
        Displays API tokens for the specified administrators.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_admins_api_tokens_get_with_http_info(admin_ids, admin_names, continuation_token, expose_api_token, filter, limit, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param admins: A list of admins to query for. Overrides admin_ids and admin_names keyword arguments.
        :type admins: ReferenceType or List[ReferenceType], optional
        :param admin_ids: A comma-separated list of admin IDs. If after filtering, there is not at least
                        one admin resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `admin_names` query
                        parameter.
        :type admin_ids: List[str]
        :param admin_names: A comma-separated list of admin names. If there is not at least one admin
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `admin_ids` query parameter.
        :type admin_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param expose_api_token: If `true`, exposes the API token of the current user.
        :type expose_api_token: bool
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            admin_ids=admin_ids,
            admin_names=admin_names,
            continuation_token=continuation_token,
            expose_api_token=expose_api_token,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(admins, ['admin_ids', 'admin_names'], kwargs)
        _fixup_list_type_params(['admin_ids', 'admin_names', 'sort'], kwargs)
        return self._call_api('AdministratorsApi', 'api20_admins_api_tokens_get_with_http_info', kwargs)

    def post_admins_api_tokens(
        self,
        admins: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        admin_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of admin IDs. If after filtering, there is not at least one admin resource that matches each of the elements, then an error is returned. This cannot be provided together with the `admin_names` query parameter.")] = None,
        admin_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of admin names. If there is not at least one admin resource that matches each of the elements, then an error is returned. This cannot be provided together with `admin_ids` query parameter.")] = None,
        timeout: Annotated[Optional[StrictInt], Field(description="The duration of API token validity, in milliseconds.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST admins/api-tokens  # noqa: E501
        
        Creates API tokens for the specified administrators.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_admins_api_tokens_post_with_http_info(admin_ids, admin_names, timeout, async_req=True)
        >>> result = thread.get()
        
        :param admins: A list of admins to query for. Overrides admin_ids and admin_names keyword arguments.
        :type admins: ReferenceType or List[ReferenceType], optional
        :param admin_ids: A comma-separated list of admin IDs. If after filtering, there is not at least
                        one admin resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `admin_names` query
                        parameter.
        :type admin_ids: List[str]
        :param admin_names: A comma-separated list of admin names. If there is not at least one admin
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `admin_ids` query parameter.
        :type admin_names: List[str]
        :param timeout: The duration of API token validity, in milliseconds.
        :type timeout: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            admin_ids=admin_ids,
            admin_names=admin_names,
            timeout=timeout,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(admins, ['admin_ids', 'admin_names'], kwargs)
        _fixup_list_type_params(['admin_ids', 'admin_names'], kwargs)
        return self._call_api('AdministratorsApi', 'api20_admins_api_tokens_post_with_http_info', kwargs)

    def delete_admins_cache(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE admins/cache  # noqa: E501
        
        Delete cached administrator role information by name or ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_admins_cache_delete_with_http_info(ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('AdministratorsApi', 'api20_admins_cache_delete_with_http_info', kwargs)

    def get_admins_cache(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        refresh: Annotated[Optional[StrictBool], Field(description="Whether to refresh the user info from directory service. If not specified, defaults to `false`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET admins/cache  # noqa: E501
        
        List cached administrator information used to determine role based access control privileges.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_admins_cache_get_with_http_info(continuation_token, filter, ids, limit, names, offset, refresh, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param refresh: Whether to refresh the user info from directory service. If not specified,
                        defaults to `false`.
        :type refresh: bool
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            refresh=refresh,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('AdministratorsApi', 'api20_admins_cache_get_with_http_info', kwargs)

    def get_admins(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        expose_api_token: Annotated[Optional[StrictBool], Field(description="If `true`, exposes the API token of the current user.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET admins  # noqa: E501
        
        List the administrator's attributes, including the API token and public key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_admins_get_with_http_info(continuation_token, expose_api_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param expose_api_token: If `true`, exposes the API token of the current user.
        :type expose_api_token: bool
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            expose_api_token=expose_api_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('AdministratorsApi', 'api20_admins_get_with_http_info', kwargs)

    def patch_admins(
        self,
        admin: 'models.AdminPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH admins  # noqa: E501
        
        Modify the attributes of the administrator.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_admins_patch_with_http_info(admin, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param admin: (required)
        :type admin: models.AdminPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            admin=admin,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('AdministratorsApi', 'api20_admins_patch_with_http_info', kwargs)

    def delete_alert_watchers(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE alert-watchers  # noqa: E501
        
        Delete an alert watcher.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_alert_watchers_delete_with_http_info(ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('AlertWatchersApi', 'api20_alert_watchers_delete_with_http_info', kwargs)

    def get_alert_watchers(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET alert-watchers  # noqa: E501
        
        List alert watchers that are configured to receive alert messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_alert_watchers_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('AlertWatchersApi', 'api20_alert_watchers_get_with_http_info', kwargs)

    def patch_alert_watchers(
        self,
        alert_watcher: 'models.AlertWatcher',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH alert-watchers  # noqa: E501
        
        Modify an alert watcher’s configuration. Enable or disable an alert watcher privilege and select the level of alert notification of an alert watcher. Alert notification levels are `info`, `warning`, or `critical`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_alert_watchers_patch_with_http_info(alert_watcher, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param alert_watcher: (required)
        :type alert_watcher: models.AlertWatcher
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            alert_watcher=alert_watcher,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('AlertWatchersApi', 'api20_alert_watchers_patch_with_http_info', kwargs)

    def post_alert_watchers(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        alert_watcher: Optional['models.AlertWatcherPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST alert-watchers  # noqa: E501
        
        Create an alert watcher to receive array alert messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_alert_watchers_post_with_http_info(names, alert_watcher, async_req=True)
        >>> result = thread.get()
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param alert_watcher:
        :type alert_watcher: AlertWatcherPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            alert_watcher=alert_watcher,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('AlertWatchersApi', 'api20_alert_watchers_post_with_http_info', kwargs)

    def get_alert_watchers_test(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET alert-watchers/test  # noqa: E501
        
        Test an alert watcher's contact information to verify alerts can be sent and received.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_alert_watchers_test_get_with_http_info(filter, ids, names, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            filter=filter,
            ids=ids,
            names=names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('AlertWatchersApi', 'api20_alert_watchers_test_get_with_http_info', kwargs)

    def get_alerts(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET alerts  # noqa: E501
        
        Returns a list of alerts which have been generated by the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_alerts_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('AlertsApi', 'api20_alerts_get_with_http_info', kwargs)

    def patch_alerts(
        self,
        alerts_settings: 'models.Alert',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH alerts  # noqa: E501
        
        Make changes to an alert. This is currently limited to the alert's `flagged` property.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_alerts_patch_with_http_info(alerts_settings, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param alerts_settings: (required)
        :type alerts_settings: models.Alert
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            alerts_settings=alerts_settings,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('AlertsApi', 'api20_alerts_patch_with_http_info', kwargs)

    def get_array_connections_connection_key(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET array-connections/connection-key  # noqa: E501
        
        List connection keys used to authenticate the connection from one array to another.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_array_connections_connection_key_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api20_array_connections_connection_key_get_with_http_info', kwargs)

    def post_array_connections_connection_key(
        self,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST array-connections/connection-key  # noqa: E501
        
        Create an array connection key allowing one array to connect to another for replication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_array_connections_connection_key_post_with_http_info(async_req=True)
        >>> result = thread.get()
        
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api20_array_connections_connection_key_post_with_http_info', kwargs)

    def delete_array_connections(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE array-connections  # noqa: E501
        
        Delete a connection to an array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_array_connections_delete_with_http_info(ids, remote_ids, remote_names, async_req=True)
        >>> result = thread.get()
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['ids', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api20_array_connections_delete_with_http_info', kwargs)

    def get_array_connections(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET array-connections  # noqa: E501
        
        List connected arrays for replication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_array_connections_get_with_http_info(continuation_token, filter, ids, limit, offset, remote_ids, remote_names, sort, async_req=True)
        >>> result = thread.get()
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            offset=offset,
            remote_ids=remote_ids,
            remote_names=remote_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['ids', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api20_array_connections_get_with_http_info', kwargs)

    def patch_array_connections(
        self,
        array_connection: 'models.ArrayConnection',
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH array-connections  # noqa: E501
        
        Modify the configuration of a connected array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_array_connections_patch_with_http_info(array_connection, ids, remote_ids, remote_names, async_req=True)
        >>> result = thread.get()
        
        :param array_connection: (required)
        :type array_connection: models.ArrayConnection
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            array_connection=array_connection,
            ids=ids,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['ids', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api20_array_connections_patch_with_http_info', kwargs)

    def get_array_connections_path(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET array-connections/path  # noqa: E501
        
        List network path details of connected arrays.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_array_connections_path_get_with_http_info(continuation_token, filter, ids, limit, offset, remote_ids, remote_names, sort, async_req=True)
        >>> result = thread.get()
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            offset=offset,
            remote_ids=remote_ids,
            remote_names=remote_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['ids', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api20_array_connections_path_get_with_http_info', kwargs)

    def get_array_connections_performance_replication(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Display the metric of a specified object type. Valid values are `all`, `file-system`, and `object-store`. If not specified, defaults to `all`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET array-connections/performance/replication  # noqa: E501
        
        List performance metrics of file systems or objects being replicated from one array to another.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_array_connections_performance_replication_get_with_http_info(continuation_token, end_time, filter, ids, limit, offset, remote_ids, remote_names, resolution, sort, start_time, total_only, type, async_req=True)
        >>> result = thread.get()
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param type: Display the metric of a specified object type. Valid values are `all`, `file-
                    system`, and `object-store`. If not specified, defaults to `all`.
        :type type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            end_time=end_time,
            filter=filter,
            ids=ids,
            limit=limit,
            offset=offset,
            remote_ids=remote_ids,
            remote_names=remote_names,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_only=total_only,
            type=type,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['ids', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api20_array_connections_performance_replication_get_with_http_info', kwargs)

    def post_array_connections(
        self,
        array_connection: 'models.ArrayConnectionPost',
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST array-connections  # noqa: E501
        
        Create a connection to an array for replication and configure network settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_array_connections_post_with_http_info(array_connection, async_req=True)
        >>> result = thread.get()
        
        :param array_connection: (required)
        :type array_connection: models.ArrayConnectionPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            array_connection=array_connection,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api20_array_connections_post_with_http_info', kwargs)

    def get_arrays_eula(
        self,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET arrays/eula  # noqa: E501
        
        List the End User Agreement and signature.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_arrays_eula_get_with_http_info(continuation_token, filter, limit, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('ArraysApi', 'api20_arrays_eula_get_with_http_info', kwargs)

    def patch_arrays_eula(
        self,
        eula: 'models.Eula',
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH arrays/eula  # noqa: E501
        
        Modifies the signature on the End User Agreement.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_arrays_eula_patch_with_http_info(eula, async_req=True)
        >>> result = thread.get()
        
        :param eula: (required)
        :type eula: models.Eula
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            eula=eula,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api20_arrays_eula_patch_with_http_info', kwargs)

    def get_arrays(
        self,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET arrays  # noqa: E501
        
        List array attributes such as the array name, ID, version, and NTP servers.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_arrays_get_with_http_info(continuation_token, filter, limit, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('ArraysApi', 'api20_arrays_get_with_http_info', kwargs)

    def get_arrays_http_specific_performance(
        self,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET arrays/http-specific-performance  # noqa: E501
        
        List the HTTP performance metrics of the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_arrays_http_specific_performance_get_with_http_info(end_time, resolution, start_time, async_req=True)
        >>> result = thread.get()
        
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            end_time=end_time,
            resolution=resolution,
            start_time=start_time,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api20_arrays_http_specific_performance_get_with_http_info', kwargs)

    def get_arrays_nfs_specific_performance(
        self,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET arrays/nfs-specific-performance  # noqa: E501
        
        List the NFS performance metrics of the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_arrays_nfs_specific_performance_get_with_http_info(end_time, resolution, start_time, async_req=True)
        >>> result = thread.get()
        
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            end_time=end_time,
            resolution=resolution,
            start_time=start_time,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api20_arrays_nfs_specific_performance_get_with_http_info', kwargs)

    def patch_arrays(
        self,
        array: 'models.Array',
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH arrays  # noqa: E501
        
        Modify the general configuration of the array including banner text, array name, NTP servers, and time zone.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_arrays_patch_with_http_info(array, async_req=True)
        >>> result = thread.get()
        
        :param array: (required)
        :type array: models.Array
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            array=array,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api20_arrays_patch_with_http_info', kwargs)

    def get_arrays_performance(
        self,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        protocol: Annotated[Optional[StrictStr], Field(description="Display the performance of a specified protocol. Valid values are `all`, `HTTP`, `SMB`, `NFS`, and `S3`. If not specified, defaults to `all`, which will provide the combined performance of all available protocols.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET arrays/performance  # noqa: E501
        
        Lists the overall performance metrics of the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_arrays_performance_get_with_http_info(end_time, protocol, resolution, start_time, async_req=True)
        >>> result = thread.get()
        
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param protocol: Display the performance of a specified protocol. Valid values are `all`, `HTTP`,
                        `SMB`, `NFS`, and `S3`. If not specified, defaults to `all`, which will
                        provide the combined performance of all available protocols.
        :type protocol: str
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            end_time=end_time,
            protocol=protocol,
            resolution=resolution,
            start_time=start_time,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api20_arrays_performance_get_with_http_info', kwargs)

    def get_arrays_performance_replication(
        self,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Display the metric of a specified object type. Valid values are `all`, `file-system`, and `object-store`. If not specified, defaults to `all`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET arrays/performance/replication  # noqa: E501
        
        List replication performance metrics.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_arrays_performance_replication_get_with_http_info(end_time, resolution, start_time, type, async_req=True)
        >>> result = thread.get()
        
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param type: Display the metric of a specified object type. Valid values are `all`, `file-
                    system`, and `object-store`. If not specified, defaults to `all`.
        :type type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            end_time=end_time,
            resolution=resolution,
            start_time=start_time,
            type=type,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api20_arrays_performance_replication_get_with_http_info', kwargs)

    def get_arrays_s3_specific_performance(
        self,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET arrays/s3-specific-performance  # noqa: E501
        
        List the S3 performance metrics of the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_arrays_s3_specific_performance_get_with_http_info(end_time, resolution, start_time, async_req=True)
        >>> result = thread.get()
        
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            end_time=end_time,
            resolution=resolution,
            start_time=start_time,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api20_arrays_s3_specific_performance_get_with_http_info', kwargs)

    def get_arrays_space(
        self,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Display the metric of a specified object type. Valid values are `array`, `file-system`, and `object-store`. If not specified, defaults to `array`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET arrays/space  # noqa: E501
        
        List available and used storage space on the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_arrays_space_get_with_http_info(end_time, resolution, start_time, type, async_req=True)
        >>> result = thread.get()
        
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param type: Display the metric of a specified object type. Valid values are `array`, `file-
                    system`, and `object-store`. If not specified, defaults to `array`.
        :type type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            end_time=end_time,
            resolution=resolution,
            start_time=start_time,
            type=type,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api20_arrays_space_get_with_http_info', kwargs)

    def get_arrays_supported_time_zones(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET arrays/supported-time-zones  # noqa: E501
        
        List supported time zones for the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_arrays_supported_time_zones_get_with_http_info(continuation_token, filter, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('ArraysApi', 'api20_arrays_supported_time_zones_get_with_http_info', kwargs)

    def get_audits(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET audits  # noqa: E501
        
        List the array audit trail to view activities that were performed on the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_audits_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('AuditsApi', 'api20_audits_get_with_http_info', kwargs)

    def get_blades(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET blades  # noqa: E501
        
        List array blade information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_blades_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('BladesApi', 'api20_blades_get_with_http_info', kwargs)

    def delete_bucket_replica_links(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        local_bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local bucket IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_bucket_names` query parameter.")] = None,
        local_bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local bucket names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_bucket_ids` query parameter.")] = None,
        remote_bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote bucket names. If there is not at least one resource that matches each of the elements, then an error is returned.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE bucket-replica-links  # noqa: E501
        
        Delete a bucket replica link.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_bucket_replica_links_delete_with_http_info(ids, local_bucket_ids, local_bucket_names, remote_bucket_names, remote_ids, remote_names, async_req=True)
        >>> result = thread.get()
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param remote_buckets: A list of remote_buckets to query for. Overrides remote_bucket_names keyword argument.
        :type remote_buckets: ReferenceType or List[ReferenceType], optional
        :param local_buckets: A list of local_buckets to query for. Overrides local_bucket_ids and local_bucket_names keyword arguments.
        :type local_buckets: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param local_bucket_ids: A comma-separated list of local bucket IDs. If after filtering, there is not at
                                least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `local_bucket_names`
                                query parameter.
        :type local_bucket_ids: List[str]
        :param local_bucket_names: A comma-separated list of local bucket names. If there is not at least one
                                resource that matches each of the elements, then an error is returned.
                                This cannot be provided together with `local_bucket_ids` query parameter.
        :type local_bucket_names: List[str]
        :param remote_bucket_names: A comma-separated list of remote bucket names. If there is not at least one
                                    resource that matches each of the elements, then an error is returned.
        :type remote_bucket_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            local_bucket_ids=local_bucket_ids,
            local_bucket_names=local_bucket_names,
            remote_bucket_names=remote_bucket_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids'], kwargs)
        _process_references(local_buckets, ['local_bucket_ids', 'local_bucket_names'], kwargs)
        _process_references(remote_buckets, ['remote_bucket_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['ids', 'local_bucket_ids', 'local_bucket_names', 'remote_bucket_names', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('BucketReplicaLinksApi', 'api20_bucket_replica_links_delete_with_http_info', kwargs)

    def get_bucket_replica_links(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        local_bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local bucket IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_bucket_names` query parameter.")] = None,
        local_bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local bucket names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_bucket_ids` query parameter.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        remote_bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote bucket names. If there is not at least one resource that matches each of the elements, then an error is returned.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET bucket-replica-links  # noqa: E501
        
        List bucket replica links for object replication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_bucket_replica_links_get_with_http_info(continuation_token, filter, ids, limit, local_bucket_ids, local_bucket_names, offset, remote_bucket_names, remote_ids, remote_names, sort, async_req=True)
        >>> result = thread.get()
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param remote_buckets: A list of remote_buckets to query for. Overrides remote_bucket_names keyword argument.
        :type remote_buckets: ReferenceType or List[ReferenceType], optional
        :param local_buckets: A list of local_buckets to query for. Overrides local_bucket_ids and local_bucket_names keyword arguments.
        :type local_buckets: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param local_bucket_ids: A comma-separated list of local bucket IDs. If after filtering, there is not at
                                least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `local_bucket_names`
                                query parameter.
        :type local_bucket_ids: List[str]
        :param local_bucket_names: A comma-separated list of local bucket names. If there is not at least one
                                resource that matches each of the elements, then an error is returned.
                                This cannot be provided together with `local_bucket_ids` query parameter.
        :type local_bucket_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param remote_bucket_names: A comma-separated list of remote bucket names. If there is not at least one
                                    resource that matches each of the elements, then an error is returned.
        :type remote_bucket_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            local_bucket_ids=local_bucket_ids,
            local_bucket_names=local_bucket_names,
            offset=offset,
            remote_bucket_names=remote_bucket_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids'], kwargs)
        _process_references(local_buckets, ['local_bucket_ids', 'local_bucket_names'], kwargs)
        _process_references(remote_buckets, ['remote_bucket_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['ids', 'local_bucket_ids', 'local_bucket_names', 'remote_bucket_names', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('BucketReplicaLinksApi', 'api20_bucket_replica_links_get_with_http_info', kwargs)

    def patch_bucket_replica_links(
        self,
        bucket_replica_link: 'models.BucketReplicaLink',
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        local_bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local bucket IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_bucket_names` query parameter.")] = None,
        local_bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local bucket names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_bucket_ids` query parameter.")] = None,
        remote_bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote bucket names. If there is not at least one resource that matches each of the elements, then an error is returned.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH bucket-replica-links  # noqa: E501
        
        Modify the configuration of a bucket replica link including whether the link is paused and the object store remote credentials used.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_bucket_replica_links_patch_with_http_info(bucket_replica_link, ids, local_bucket_ids, local_bucket_names, remote_bucket_names, remote_ids, remote_names, async_req=True)
        >>> result = thread.get()
        
        :param bucket_replica_link: (required)
        :type bucket_replica_link: models.BucketReplicaLink
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param remote_buckets: A list of remote_buckets to query for. Overrides remote_bucket_names keyword argument.
        :type remote_buckets: ReferenceType or List[ReferenceType], optional
        :param local_buckets: A list of local_buckets to query for. Overrides local_bucket_ids and local_bucket_names keyword arguments.
        :type local_buckets: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param local_bucket_ids: A comma-separated list of local bucket IDs. If after filtering, there is not at
                                least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `local_bucket_names`
                                query parameter.
        :type local_bucket_ids: List[str]
        :param local_bucket_names: A comma-separated list of local bucket names. If there is not at least one
                                resource that matches each of the elements, then an error is returned.
                                This cannot be provided together with `local_bucket_ids` query parameter.
        :type local_bucket_names: List[str]
        :param remote_bucket_names: A comma-separated list of remote bucket names. If there is not at least one
                                    resource that matches each of the elements, then an error is returned.
        :type remote_bucket_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            bucket_replica_link=bucket_replica_link,
            ids=ids,
            local_bucket_ids=local_bucket_ids,
            local_bucket_names=local_bucket_names,
            remote_bucket_names=remote_bucket_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids'], kwargs)
        _process_references(local_buckets, ['local_bucket_ids', 'local_bucket_names'], kwargs)
        _process_references(remote_buckets, ['remote_bucket_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['ids', 'local_bucket_ids', 'local_bucket_names', 'remote_bucket_names', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('BucketReplicaLinksApi', 'api20_bucket_replica_links_patch_with_http_info', kwargs)

    def post_bucket_replica_links(
        self,
        bucket_replica_link: 'models.BucketReplicaLinkPost',
        remote_credential: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local bucket IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_bucket_names` query parameter.")] = None,
        local_bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local bucket names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_bucket_ids` query parameter.")] = None,
        remote_bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote bucket names. If there is not at least one resource that matches each of the elements, then an error is returned.")] = None,
        remote_credentials_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote credentials IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_credentials_names` query parameter.")] = None,
        remote_credentials_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote credentials names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_credentials_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST bucket-replica-links  # noqa: E501
        
        Create a bucket replica link for object replication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_bucket_replica_links_post_with_http_info(bucket_replica_link, local_bucket_ids, local_bucket_names, remote_bucket_names, remote_credentials_ids, remote_credentials_names, async_req=True)
        >>> result = thread.get()
        
        :param bucket_replica_link: (required)
        :type bucket_replica_link: models.BucketReplicaLinkPost
        :param remote_credential: A list of remote_credential to query for. Overrides remote_credentials_ids and remote_credentials_names keyword arguments.
        :type remote_credential: ReferenceType or List[ReferenceType], optional
        :param remote_buckets: A list of remote_buckets to query for. Overrides remote_bucket_names keyword argument.
        :type remote_buckets: ReferenceType or List[ReferenceType], optional
        :param local_buckets: A list of local_buckets to query for. Overrides local_bucket_ids and local_bucket_names keyword arguments.
        :type local_buckets: ReferenceType or List[ReferenceType], optional
        :param local_bucket_ids: A comma-separated list of local bucket IDs. If after filtering, there is not at
                                least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `local_bucket_names`
                                query parameter.
        :type local_bucket_ids: List[str]
        :param local_bucket_names: A comma-separated list of local bucket names. If there is not at least one
                                resource that matches each of the elements, then an error is returned.
                                This cannot be provided together with `local_bucket_ids` query parameter.
        :type local_bucket_names: List[str]
        :param remote_bucket_names: A comma-separated list of remote bucket names. If there is not at least one
                                    resource that matches each of the elements, then an error is returned.
        :type remote_bucket_names: List[str]
        :param remote_credentials_ids: A comma-separated list of remote credentials IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `remote_credentials_names` query parameter.
        :type remote_credentials_ids: List[str]
        :param remote_credentials_names: A comma-separated list of remote credentials names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with the `remote_credentials_ids` query
                                        parameter.
        :type remote_credentials_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            bucket_replica_link=bucket_replica_link,
            local_bucket_ids=local_bucket_ids,
            local_bucket_names=local_bucket_names,
            remote_bucket_names=remote_bucket_names,
            remote_credentials_ids=remote_credentials_ids,
            remote_credentials_names=remote_credentials_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(local_buckets, ['local_bucket_ids', 'local_bucket_names'], kwargs)
        _process_references(remote_buckets, ['remote_bucket_names'], kwargs)
        _process_references(remote_credential, ['remote_credentials_ids', 'remote_credentials_names'], kwargs)
        _fixup_list_type_params(['local_bucket_ids', 'local_bucket_names', 'remote_bucket_names', 'remote_credentials_ids', 'remote_credentials_names'], kwargs)
        return self._call_api('BucketReplicaLinksApi', 'api20_bucket_replica_links_post_with_http_info', kwargs)

    def delete_buckets(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE buckets  # noqa: E501
        
        Delete object store buckets.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_buckets_delete_with_http_info(ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('BucketsApi', 'api20_buckets_delete_with_http_info', kwargs)

    def get_buckets(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. If not set, lists both objects that are destroyed and those that are not destroyed. If object name(s) are specified in the `names` parameter, then each object referenced must exist. If `destroyed` is set to `true`, then each object referenced must also be destroyed. If `destroyed` is set to `false`, then each object referenced must also not be destroyed. An error is returned if any of these conditions are not met.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET buckets  # noqa: E501
        
        List object store bucket attributes such as creation time and space usage.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_buckets_get_with_http_info(continuation_token, destroyed, filter, ids, limit, names, offset, sort, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        If not set, lists both objects that are destroyed and those that are not
                        destroyed. If object name(s) are specified in the `names` parameter, then
                        each object referenced must exist. If `destroyed` is set to `true`, then
                        each object referenced must also be destroyed. If `destroyed` is set to
                        `false`, then each object referenced must also not be destroyed. An error is
                        returned if any of these conditions are not met.
        :type destroyed: bool
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('BucketsApi', 'api20_buckets_get_with_http_info', kwargs)

    def patch_buckets(
        self,
        bucket: 'models.Bucket',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH buckets  # noqa: E501
        
        Modify object store bucket attributes such as destroyed and versioning.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_buckets_patch_with_http_info(bucket, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param bucket: (required)
        :type bucket: models.Bucket
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            bucket=bucket,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('BucketsApi', 'api20_buckets_patch_with_http_info', kwargs)

    def get_buckets_performance(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET buckets/performance  # noqa: E501
        
        List performance metrics for a bucket.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_buckets_performance_get_with_http_info(continuation_token, end_time, filter, ids, limit, names, offset, resolution, sort, start_time, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            end_time=end_time,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('BucketsApi', 'api20_buckets_performance_get_with_http_info', kwargs)

    def post_buckets(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        bucket: 'models.BucketPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST buckets  # noqa: E501
        
        Create a new object store bucket.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_buckets_post_with_http_info(names, bucket, async_req=True)
        >>> result = thread.get()
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param bucket: (required)
        :type bucket: models.BucketPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            bucket=bucket,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('BucketsApi', 'api20_buckets_post_with_http_info', kwargs)

    def get_buckets_s3_specific_performance(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET buckets/s3-specific-performance  # noqa: E501
        
        List performance metrics specific to S3 operations for a bucket.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_buckets_s3_specific_performance_get_with_http_info(continuation_token, end_time, filter, ids, limit, names, offset, resolution, sort, start_time, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            end_time=end_time,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('BucketsApi', 'api20_buckets_s3_specific_performance_get_with_http_info', kwargs)

    def delete_certificate_groups_certificates(
        self,
        certificates: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group ids. If there is not at least one resource that matches each of the elements of `certificate_group_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_names` parameter.")] = None,
        certificate_group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group names. If there is not at least one resource that matches each of the elements of `certificate_group_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_ids` parameter.")] = None,
        certificate_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate ids. If there is not at least one resource that matches each of the elements of `certificate_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_names` parameter.")] = None,
        certificate_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate names. If there is not at least one resource that matches each of the elements of `certificate_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_ids` parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE certificate-groups/certificates  # noqa: E501
        
        Delete one or more certificate groups.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_certificate_groups_certificates_delete_with_http_info(certificate_group_ids, certificate_group_names, certificate_ids, certificate_names, async_req=True)
        >>> result = thread.get()
        
        :param certificates: A list of certificates to query for. Overrides certificate_ids and certificate_names keyword arguments.
        :type certificates: ReferenceType or List[ReferenceType], optional
        :param certificate_groups: A list of certificate_groups to query for. Overrides certificate_group_ids and certificate_group_names keyword arguments.
        :type certificate_groups: ReferenceType or List[ReferenceType], optional
        :param certificate_group_ids: A comma-separated list of certificate group ids. If there is not at least one
                                    resource that matches each of the elements of `certificate_group_ids`,
                                    then an error is returned. This cannot be provided in conjunction with
                                    the `certificate_group_names` parameter.
        :type certificate_group_ids: List[str]
        :param certificate_group_names: A comma-separated list of certificate group names. If there is not at least one
                                        resource that matches each of the elements of `certificate_group_names`,
                                        then an error is returned. This cannot be provided in conjunction with
                                        the `certificate_group_ids` parameter.
        :type certificate_group_names: List[str]
        :param certificate_ids: A comma-separated list of certificate ids. If there is not at least one resource
                                that matches each of the elements of `certificate_ids`, then an error is
                                returned. This cannot be provided in conjunction with the
                                `certificate_names` parameter.
        :type certificate_ids: List[str]
        :param certificate_names: A comma-separated list of certificate names. If there is not at least one
                                resource that matches each of the elements of `certificate_names`, then an
                                error is returned. This cannot be provided in conjunction with the
                                `certificate_ids` parameter.
        :type certificate_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            certificate_group_ids=certificate_group_ids,
            certificate_group_names=certificate_group_names,
            certificate_ids=certificate_ids,
            certificate_names=certificate_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(certificate_groups, ['certificate_group_ids', 'certificate_group_names'], kwargs)
        _process_references(certificates, ['certificate_ids', 'certificate_names'], kwargs)
        _fixup_list_type_params(['certificate_group_ids', 'certificate_group_names', 'certificate_ids', 'certificate_names'], kwargs)
        return self._call_api('CertificateGroupsApi', 'api20_certificate_groups_certificates_delete_with_http_info', kwargs)

    def get_certificate_groups_certificates(
        self,
        certificates: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group ids. If there is not at least one resource that matches each of the elements of `certificate_group_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_names` parameter.")] = None,
        certificate_group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group names. If there is not at least one resource that matches each of the elements of `certificate_group_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_ids` parameter.")] = None,
        certificate_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate ids. If there is not at least one resource that matches each of the elements of `certificate_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_names` parameter.")] = None,
        certificate_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate names. If there is not at least one resource that matches each of the elements of `certificate_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_ids` parameter.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET certificate-groups/certificates  # noqa: E501
        
        List membership associations between groups and certificates on the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_certificate_groups_certificates_get_with_http_info(certificate_group_ids, certificate_group_names, certificate_ids, certificate_names, continuation_token, filter, limit, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param certificates: A list of certificates to query for. Overrides certificate_ids and certificate_names keyword arguments.
        :type certificates: ReferenceType or List[ReferenceType], optional
        :param certificate_groups: A list of certificate_groups to query for. Overrides certificate_group_ids and certificate_group_names keyword arguments.
        :type certificate_groups: ReferenceType or List[ReferenceType], optional
        :param certificate_group_ids: A comma-separated list of certificate group ids. If there is not at least one
                                    resource that matches each of the elements of `certificate_group_ids`,
                                    then an error is returned. This cannot be provided in conjunction with
                                    the `certificate_group_names` parameter.
        :type certificate_group_ids: List[str]
        :param certificate_group_names: A comma-separated list of certificate group names. If there is not at least one
                                        resource that matches each of the elements of `certificate_group_names`,
                                        then an error is returned. This cannot be provided in conjunction with
                                        the `certificate_group_ids` parameter.
        :type certificate_group_names: List[str]
        :param certificate_ids: A comma-separated list of certificate ids. If there is not at least one resource
                                that matches each of the elements of `certificate_ids`, then an error is
                                returned. This cannot be provided in conjunction with the
                                `certificate_names` parameter.
        :type certificate_ids: List[str]
        :param certificate_names: A comma-separated list of certificate names. If there is not at least one
                                resource that matches each of the elements of `certificate_names`, then an
                                error is returned. This cannot be provided in conjunction with the
                                `certificate_ids` parameter.
        :type certificate_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            certificate_group_ids=certificate_group_ids,
            certificate_group_names=certificate_group_names,
            certificate_ids=certificate_ids,
            certificate_names=certificate_names,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(certificate_groups, ['certificate_group_ids', 'certificate_group_names'], kwargs)
        _process_references(certificates, ['certificate_ids', 'certificate_names'], kwargs)
        _fixup_list_type_params(['certificate_group_ids', 'certificate_group_names', 'certificate_ids', 'certificate_names', 'sort'], kwargs)
        return self._call_api('CertificateGroupsApi', 'api20_certificate_groups_certificates_get_with_http_info', kwargs)

    def post_certificate_groups_certificates(
        self,
        certificates: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group ids. If there is not at least one resource that matches each of the elements of `certificate_group_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_names` parameter.")] = None,
        certificate_group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group names. If there is not at least one resource that matches each of the elements of `certificate_group_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_ids` parameter.")] = None,
        certificate_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate ids. If there is not at least one resource that matches each of the elements of `certificate_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_names` parameter.")] = None,
        certificate_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate names. If there is not at least one resource that matches each of the elements of `certificate_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_ids` parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST certificate-groups/certificates  # noqa: E501
        
        Add one or more certificates to one or more certificate groups on the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_certificate_groups_certificates_post_with_http_info(certificate_group_ids, certificate_group_names, certificate_ids, certificate_names, async_req=True)
        >>> result = thread.get()
        
        :param certificates: A list of certificates to query for. Overrides certificate_ids and certificate_names keyword arguments.
        :type certificates: ReferenceType or List[ReferenceType], optional
        :param certificate_groups: A list of certificate_groups to query for. Overrides certificate_group_ids and certificate_group_names keyword arguments.
        :type certificate_groups: ReferenceType or List[ReferenceType], optional
        :param certificate_group_ids: A comma-separated list of certificate group ids. If there is not at least one
                                    resource that matches each of the elements of `certificate_group_ids`,
                                    then an error is returned. This cannot be provided in conjunction with
                                    the `certificate_group_names` parameter.
        :type certificate_group_ids: List[str]
        :param certificate_group_names: A comma-separated list of certificate group names. If there is not at least one
                                        resource that matches each of the elements of `certificate_group_names`,
                                        then an error is returned. This cannot be provided in conjunction with
                                        the `certificate_group_ids` parameter.
        :type certificate_group_names: List[str]
        :param certificate_ids: A comma-separated list of certificate ids. If there is not at least one resource
                                that matches each of the elements of `certificate_ids`, then an error is
                                returned. This cannot be provided in conjunction with the
                                `certificate_names` parameter.
        :type certificate_ids: List[str]
        :param certificate_names: A comma-separated list of certificate names. If there is not at least one
                                resource that matches each of the elements of `certificate_names`, then an
                                error is returned. This cannot be provided in conjunction with the
                                `certificate_ids` parameter.
        :type certificate_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            certificate_group_ids=certificate_group_ids,
            certificate_group_names=certificate_group_names,
            certificate_ids=certificate_ids,
            certificate_names=certificate_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(certificate_groups, ['certificate_group_ids', 'certificate_group_names'], kwargs)
        _process_references(certificates, ['certificate_ids', 'certificate_names'], kwargs)
        _fixup_list_type_params(['certificate_group_ids', 'certificate_group_names', 'certificate_ids', 'certificate_names'], kwargs)
        return self._call_api('CertificateGroupsApi', 'api20_certificate_groups_certificates_post_with_http_info', kwargs)

    def delete_certificate_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE certificate-groups  # noqa: E501
        
        Delete one or more certificate groups from the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_certificate_groups_delete_with_http_info(ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('CertificateGroupsApi', 'api20_certificate_groups_delete_with_http_info', kwargs)

    def get_certificate_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET certificate-groups  # noqa: E501
        
        Display all array certificate groups.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_certificate_groups_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('CertificateGroupsApi', 'api20_certificate_groups_get_with_http_info', kwargs)

    def post_certificate_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST certificate-groups  # noqa: E501
        
        Create one or more certificate groups on the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_certificate_groups_post_with_http_info(names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('CertificateGroupsApi', 'api20_certificate_groups_post_with_http_info', kwargs)

    def get_certificate_groups_uses(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET certificate-groups/uses  # noqa: E501
        
        List how certificate groups are being used and by what.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_certificate_groups_uses_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('CertificateGroupsApi', 'api20_certificate_groups_uses_get_with_http_info', kwargs)

    def delete_certificates_certificate_groups(
        self,
        certificates: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group ids. If there is not at least one resource that matches each of the elements of `certificate_group_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_names` parameter.")] = None,
        certificate_group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group names. If there is not at least one resource that matches each of the elements of `certificate_group_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_ids` parameter.")] = None,
        certificate_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate ids. If there is not at least one resource that matches each of the elements of `certificate_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_names` parameter.")] = None,
        certificate_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate names. If there is not at least one resource that matches each of the elements of `certificate_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_ids` parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE certificates/certificate-groups  # noqa: E501
        
        Remove one or more certificates from one or more certificate groups.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_certificates_certificate_groups_delete_with_http_info(certificate_group_ids, certificate_group_names, certificate_ids, certificate_names, async_req=True)
        >>> result = thread.get()
        
        :param certificates: A list of certificates to query for. Overrides certificate_ids and certificate_names keyword arguments.
        :type certificates: ReferenceType or List[ReferenceType], optional
        :param certificate_groups: A list of certificate_groups to query for. Overrides certificate_group_ids and certificate_group_names keyword arguments.
        :type certificate_groups: ReferenceType or List[ReferenceType], optional
        :param certificate_group_ids: A comma-separated list of certificate group ids. If there is not at least one
                                    resource that matches each of the elements of `certificate_group_ids`,
                                    then an error is returned. This cannot be provided in conjunction with
                                    the `certificate_group_names` parameter.
        :type certificate_group_ids: List[str]
        :param certificate_group_names: A comma-separated list of certificate group names. If there is not at least one
                                        resource that matches each of the elements of `certificate_group_names`,
                                        then an error is returned. This cannot be provided in conjunction with
                                        the `certificate_group_ids` parameter.
        :type certificate_group_names: List[str]
        :param certificate_ids: A comma-separated list of certificate ids. If there is not at least one resource
                                that matches each of the elements of `certificate_ids`, then an error is
                                returned. This cannot be provided in conjunction with the
                                `certificate_names` parameter.
        :type certificate_ids: List[str]
        :param certificate_names: A comma-separated list of certificate names. If there is not at least one
                                resource that matches each of the elements of `certificate_names`, then an
                                error is returned. This cannot be provided in conjunction with the
                                `certificate_ids` parameter.
        :type certificate_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            certificate_group_ids=certificate_group_ids,
            certificate_group_names=certificate_group_names,
            certificate_ids=certificate_ids,
            certificate_names=certificate_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(certificate_groups, ['certificate_group_ids', 'certificate_group_names'], kwargs)
        _process_references(certificates, ['certificate_ids', 'certificate_names'], kwargs)
        _fixup_list_type_params(['certificate_group_ids', 'certificate_group_names', 'certificate_ids', 'certificate_names'], kwargs)
        return self._call_api('CertificatesApi', 'api20_certificates_certificate_groups_delete_with_http_info', kwargs)

    def get_certificates_certificate_groups(
        self,
        certificates: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group ids. If there is not at least one resource that matches each of the elements of `certificate_group_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_names` parameter.")] = None,
        certificate_group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group names. If there is not at least one resource that matches each of the elements of `certificate_group_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_ids` parameter.")] = None,
        certificate_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate ids. If there is not at least one resource that matches each of the elements of `certificate_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_names` parameter.")] = None,
        certificate_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate names. If there is not at least one resource that matches each of the elements of `certificate_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_ids` parameter.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET certificates/certificate-groups  # noqa: E501
        
        List membership associations between groups and certificates.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_certificates_certificate_groups_get_with_http_info(certificate_group_ids, certificate_group_names, certificate_ids, certificate_names, continuation_token, filter, limit, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param certificates: A list of certificates to query for. Overrides certificate_ids and certificate_names keyword arguments.
        :type certificates: ReferenceType or List[ReferenceType], optional
        :param certificate_groups: A list of certificate_groups to query for. Overrides certificate_group_ids and certificate_group_names keyword arguments.
        :type certificate_groups: ReferenceType or List[ReferenceType], optional
        :param certificate_group_ids: A comma-separated list of certificate group ids. If there is not at least one
                                    resource that matches each of the elements of `certificate_group_ids`,
                                    then an error is returned. This cannot be provided in conjunction with
                                    the `certificate_group_names` parameter.
        :type certificate_group_ids: List[str]
        :param certificate_group_names: A comma-separated list of certificate group names. If there is not at least one
                                        resource that matches each of the elements of `certificate_group_names`,
                                        then an error is returned. This cannot be provided in conjunction with
                                        the `certificate_group_ids` parameter.
        :type certificate_group_names: List[str]
        :param certificate_ids: A comma-separated list of certificate ids. If there is not at least one resource
                                that matches each of the elements of `certificate_ids`, then an error is
                                returned. This cannot be provided in conjunction with the
                                `certificate_names` parameter.
        :type certificate_ids: List[str]
        :param certificate_names: A comma-separated list of certificate names. If there is not at least one
                                resource that matches each of the elements of `certificate_names`, then an
                                error is returned. This cannot be provided in conjunction with the
                                `certificate_ids` parameter.
        :type certificate_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            certificate_group_ids=certificate_group_ids,
            certificate_group_names=certificate_group_names,
            certificate_ids=certificate_ids,
            certificate_names=certificate_names,
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(certificate_groups, ['certificate_group_ids', 'certificate_group_names'], kwargs)
        _process_references(certificates, ['certificate_ids', 'certificate_names'], kwargs)
        _fixup_list_type_params(['certificate_group_ids', 'certificate_group_names', 'certificate_ids', 'certificate_names', 'sort'], kwargs)
        return self._call_api('CertificatesApi', 'api20_certificates_certificate_groups_get_with_http_info', kwargs)

    def post_certificates_certificate_groups(
        self,
        certificates: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group ids. If there is not at least one resource that matches each of the elements of `certificate_group_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_names` parameter.")] = None,
        certificate_group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group names. If there is not at least one resource that matches each of the elements of `certificate_group_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_ids` parameter.")] = None,
        certificate_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate ids. If there is not at least one resource that matches each of the elements of `certificate_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_names` parameter.")] = None,
        certificate_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate names. If there is not at least one resource that matches each of the elements of `certificate_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_ids` parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST certificates/certificate-groups  # noqa: E501
        
        Add one or more certificates to one or more certificate groups.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_certificates_certificate_groups_post_with_http_info(certificate_group_ids, certificate_group_names, certificate_ids, certificate_names, async_req=True)
        >>> result = thread.get()
        
        :param certificates: A list of certificates to query for. Overrides certificate_ids and certificate_names keyword arguments.
        :type certificates: ReferenceType or List[ReferenceType], optional
        :param certificate_groups: A list of certificate_groups to query for. Overrides certificate_group_ids and certificate_group_names keyword arguments.
        :type certificate_groups: ReferenceType or List[ReferenceType], optional
        :param certificate_group_ids: A comma-separated list of certificate group ids. If there is not at least one
                                    resource that matches each of the elements of `certificate_group_ids`,
                                    then an error is returned. This cannot be provided in conjunction with
                                    the `certificate_group_names` parameter.
        :type certificate_group_ids: List[str]
        :param certificate_group_names: A comma-separated list of certificate group names. If there is not at least one
                                        resource that matches each of the elements of `certificate_group_names`,
                                        then an error is returned. This cannot be provided in conjunction with
                                        the `certificate_group_ids` parameter.
        :type certificate_group_names: List[str]
        :param certificate_ids: A comma-separated list of certificate ids. If there is not at least one resource
                                that matches each of the elements of `certificate_ids`, then an error is
                                returned. This cannot be provided in conjunction with the
                                `certificate_names` parameter.
        :type certificate_ids: List[str]
        :param certificate_names: A comma-separated list of certificate names. If there is not at least one
                                resource that matches each of the elements of `certificate_names`, then an
                                error is returned. This cannot be provided in conjunction with the
                                `certificate_ids` parameter.
        :type certificate_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            certificate_group_ids=certificate_group_ids,
            certificate_group_names=certificate_group_names,
            certificate_ids=certificate_ids,
            certificate_names=certificate_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(certificate_groups, ['certificate_group_ids', 'certificate_group_names'], kwargs)
        _process_references(certificates, ['certificate_ids', 'certificate_names'], kwargs)
        _fixup_list_type_params(['certificate_group_ids', 'certificate_group_names', 'certificate_ids', 'certificate_names'], kwargs)
        return self._call_api('CertificatesApi', 'api20_certificates_certificate_groups_post_with_http_info', kwargs)

    def delete_certificates(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE certificates  # noqa: E501
        
        Delete a CA certificate from the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_certificates_delete_with_http_info(ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('CertificatesApi', 'api20_certificates_delete_with_http_info', kwargs)

    def get_certificates(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET certificates  # noqa: E501
        
        List array certificates and their attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_certificates_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('CertificatesApi', 'api20_certificates_get_with_http_info', kwargs)

    def patch_certificates(
        self,
        certificate: 'models.CertificatePatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH certificates  # noqa: E501
        
        Modify SSL certificate attributes such as passphrases and intermediate certificates.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_certificates_patch_with_http_info(certificate, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param certificate: (required)
        :type certificate: models.CertificatePatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            certificate=certificate,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('CertificatesApi', 'api20_certificates_patch_with_http_info', kwargs)

    def post_certificates(
        self,
        certificate: 'models.CertificatePost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST certificates  # noqa: E501
        
        Upload a CA certificate to the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_certificates_post_with_http_info(certificate, names, async_req=True)
        >>> result = thread.get()
        
        :param certificate: (required)
        :type certificate: models.CertificatePost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            certificate=certificate,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('CertificatesApi', 'api20_certificates_post_with_http_info', kwargs)

    def get_certificates_uses(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET certificates/uses  # noqa: E501
        
        List how certificates are being used and by what.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_certificates_uses_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('CertificatesApi', 'api20_certificates_uses_get_with_http_info', kwargs)

    def get_arrays_clients_performance(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET clients-performance  # noqa: E501
        
        List NFS client I/O performance metrics.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_arrays_clients_performance_get_with_http_info(filter, limit, names, sort, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            filter=filter,
            limit=limit,
            names=names,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('ClientsApi', 'api20_arrays_clients_performance_get_with_http_info', kwargs)

    def get_dns(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET dns  # noqa: E501
        
        List DNS attributes for the array's administrative network.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_dns_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('DNSApi', 'api20_dns_get_with_http_info', kwargs)

    def patch_dns(
        self,
        dns: 'models.Dns',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH dns  # noqa: E501
        
        Modify DNS attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_dns_patch_with_http_info(dns, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param dns: (required)
        :type dns: models.Dns
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            dns=dns,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('DNSApi', 'api20_dns_patch_with_http_info', kwargs)

    def get_directory_services(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET directory-services  # noqa: E501
        
        List directory service configuration information for the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_directory_services_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api20_directory_services_get_with_http_info', kwargs)

    def patch_directory_services(
        self,
        directory_service: 'models.DirectoryService',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH directory-services  # noqa: E501
        
        Modifies and tests the directory service configuration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_directory_services_patch_with_http_info(directory_service, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param directory_service: (required)
        :type directory_service: models.DirectoryService
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            directory_service=directory_service,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api20_directory_services_patch_with_http_info', kwargs)

    def get_directory_services_roles(
        self,
        roles: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `role_names` or `role_ids` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        role_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of role_ids. If after filtering, there is not at least one resource that matches each of the elements of `role_ids`, then an error is returned. This cannot be provided together with the `ids` or `role_names` query parameters.")] = None,
        role_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of role_names. If there is not at least one resource that matches each of the elements of `role_names`, then an error is returned. This cannot be provided together with the `ids` or `role_ids` query parameters.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET directory-service/roles  # noqa: E501
        
        Return array's RBAC group configuration settings for manageability.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_directory_services_roles_get_with_http_info(continuation_token, filter, ids, limit, offset, role_ids, role_names, sort, async_req=True)
        >>> result = thread.get()
        
        :param roles: A list of roles to query for. Overrides role_ids and role_names keyword arguments.
        :type roles: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `role_names` or
                    `role_ids` query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param role_ids: A comma-separated list of role_ids. If after filtering, there is not at least
                        one resource that matches each of the elements of `role_ids`, then an error
                        is returned. This cannot be provided together with the `ids` or `role_names`
                        query parameters.
        :type role_ids: List[str]
        :param role_names: A comma-separated list of role_names. If there is not at least one resource that
                        matches each of the elements of `role_names`, then an error is returned.
                        This cannot be provided together with the `ids` or `role_ids` query
                        parameters.
        :type role_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            offset=offset,
            role_ids=role_ids,
            role_names=role_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids'], kwargs)
        _process_references(roles, ['role_ids', 'role_names'], kwargs)
        _fixup_list_type_params(['ids', 'role_ids', 'role_names', 'sort'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api20_directory_services_roles_get_with_http_info', kwargs)

    def patch_directory_services_roles(
        self,
        directory_service_roles: 'models.DirectoryServiceRole',
        roles: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `role_names` or `role_ids` query parameters.")] = None,
        role_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of role_ids. If after filtering, there is not at least one resource that matches each of the elements of `role_ids`, then an error is returned. This cannot be provided together with the `ids` or `role_names` query parameters.")] = None,
        role_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of role_names. If there is not at least one resource that matches each of the elements of `role_names`, then an error is returned. This cannot be provided together with the `ids` or `role_ids` query parameters.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH directory-service/roles  # noqa: E501
        
        Update an RBAC group configuration setting for manageability.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_directory_services_roles_patch_with_http_info(directory_service_roles, ids, role_ids, role_names, async_req=True)
        >>> result = thread.get()
        
        :param directory_service_roles: (required)
        :type directory_service_roles: models.DirectoryServiceRole
        :param roles: A list of roles to query for. Overrides role_ids and role_names keyword arguments.
        :type roles: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `role_names` or
                    `role_ids` query parameters.
        :type ids: List[str]
        :param role_ids: A comma-separated list of role_ids. If after filtering, there is not at least
                        one resource that matches each of the elements of `role_ids`, then an error
                        is returned. This cannot be provided together with the `ids` or `role_names`
                        query parameters.
        :type role_ids: List[str]
        :param role_names: A comma-separated list of role_names. If there is not at least one resource that
                        matches each of the elements of `role_names`, then an error is returned.
                        This cannot be provided together with the `ids` or `role_ids` query
                        parameters.
        :type role_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            directory_service_roles=directory_service_roles,
            ids=ids,
            role_ids=role_ids,
            role_names=role_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids'], kwargs)
        _process_references(roles, ['role_ids', 'role_names'], kwargs)
        _fixup_list_type_params(['ids', 'role_ids', 'role_names'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api20_directory_services_roles_patch_with_http_info', kwargs)

    def get_directory_services_test(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET directory-services/test  # noqa: E501
        
        Test the configured directory services on the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_directory_services_test_get_with_http_info(filter, ids, limit, names, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api20_directory_services_test_get_with_http_info', kwargs)

    def patch_directory_services_test(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        directory_service: Annotated[Optional['models.DirectoryService'], Field(description="An optional directory service configuration that, if provided, will be used to overwrite aspects of the existing directory service objects when performing tests.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH directory-service/test  # noqa: E501
        
        Test the configured directory services on the array. Optionally, provide modifications which will be used to perform the tests, but will not be applied to the current configuration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_directory_services_test_patch_with_http_info(filter, ids, names, sort, directory_service, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param directory_service: An optional directory service configuration that, if provided, will be used to
                                overwrite aspects of the existing directory service objects when
                                performing tests.
        :type directory_service: models.DirectoryService
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            filter=filter,
            ids=ids,
            names=names,
            sort=sort,
            directory_service=directory_service,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api20_directory_services_test_patch_with_http_info', kwargs)

    def get_file_system_replica_links(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        remote_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system IDs. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_names` query parameter.")] = None,
        remote_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_ids` query parameter.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-system-replica-links  # noqa: E501
        
        List file system replication link.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_file_system_replica_links_get_with_http_info(continuation_token, filter, ids, limit, local_file_system_ids, local_file_system_names, offset, remote_file_system_ids, remote_file_system_names, remote_ids, remote_names, sort, async_req=True)
        >>> result = thread.get()
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param remote_file_systems: A list of remote_file_systems to query for. Overrides remote_file_system_ids and remote_file_system_names keyword arguments.
        :type remote_file_systems: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param remote_file_system_ids: A comma-separated list of remote file system IDs. If there is not at least one
                                    resource that matches each of the elements, then an error is returned.
                                    This cannot be provided together with the `remote_file_system_names`
                                    query parameter.
        :type remote_file_system_ids: List[str]
        :param remote_file_system_names: A comma-separated list of remote file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with the `remote_file_system_ids` query
                                        parameter.
        :type remote_file_system_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            offset=offset,
            remote_file_system_ids=remote_file_system_ids,
            remote_file_system_names=remote_file_system_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids'], kwargs)
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(remote_file_systems, ['remote_file_system_ids', 'remote_file_system_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['ids', 'local_file_system_ids', 'local_file_system_names', 'remote_file_system_ids', 'remote_file_system_names', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('FileSystemReplicaLinksApi', 'api20_file_system_replica_links_get_with_http_info', kwargs)

    def delete_file_system_replica_links_policies(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE file-system-replica-links/policies  # noqa: E501
        
        Remove a policy from a file system replication link.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_file_system_replica_links_policies_delete_with_http_info(local_file_system_ids, local_file_system_names, member_ids, policy_ids, policy_names, remote_ids, remote_names, async_req=True)
        >>> result = thread.get()
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            member_ids=member_ids,
            policy_ids=policy_ids,
            policy_names=policy_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(members, ['member_ids'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['local_file_system_ids', 'local_file_system_names', 'member_ids', 'policy_ids', 'policy_names', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('FileSystemReplicaLinksApi', 'api20_file_system_replica_links_policies_delete_with_http_info', kwargs)

    def get_file_system_replica_links_policies(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        remote_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system IDs. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_names` query parameter.")] = None,
        remote_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_ids` query parameter.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-system-replica-links/policies  # noqa: E501
        
        List file system replication link policies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_file_system_replica_links_policies_get_with_http_info(continuation_token, filter, limit, local_file_system_ids, local_file_system_names, member_ids, offset, policy_ids, policy_names, remote_file_system_ids, remote_file_system_names, remote_ids, remote_names, sort, async_req=True)
        >>> result = thread.get()
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param remote_file_systems: A list of remote_file_systems to query for. Overrides remote_file_system_ids and remote_file_system_names keyword arguments.
        :type remote_file_systems: ReferenceType or List[ReferenceType], optional
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_file_system_ids: A comma-separated list of remote file system IDs. If there is not at least one
                                    resource that matches each of the elements, then an error is returned.
                                    This cannot be provided together with the `remote_file_system_names`
                                    query parameter.
        :type remote_file_system_ids: List[str]
        :param remote_file_system_names: A comma-separated list of remote file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with the `remote_file_system_ids` query
                                        parameter.
        :type remote_file_system_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            member_ids=member_ids,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            remote_file_system_ids=remote_file_system_ids,
            remote_file_system_names=remote_file_system_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(members, ['member_ids'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _process_references(remote_file_systems, ['remote_file_system_ids', 'remote_file_system_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['local_file_system_ids', 'local_file_system_names', 'member_ids', 'policy_ids', 'policy_names', 'remote_file_system_ids', 'remote_file_system_names', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('FileSystemReplicaLinksApi', 'api20_file_system_replica_links_policies_get_with_http_info', kwargs)

    def post_file_system_replica_links_policies(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST file-system-replica-links/policies  # noqa: E501
        
        Add a policy to a file system replication link.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_file_system_replica_links_policies_post_with_http_info(local_file_system_ids, local_file_system_names, member_ids, policy_ids, policy_names, remote_ids, remote_names, async_req=True)
        >>> result = thread.get()
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            member_ids=member_ids,
            policy_ids=policy_ids,
            policy_names=policy_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(members, ['member_ids'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['local_file_system_ids', 'local_file_system_names', 'member_ids', 'policy_ids', 'policy_names', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('FileSystemReplicaLinksApi', 'api20_file_system_replica_links_policies_post_with_http_info', kwargs)

    def post_file_system_replica_links(
        self,
        file_system_replica_link: 'models.FileSystemReplicaLink',
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        remote_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_ids` query parameter.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST file-system-replica-links  # noqa: E501
        
        Create a file system replication link.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_file_system_replica_links_post_with_http_info(file_system_replica_link, ids, local_file_system_ids, local_file_system_names, remote_file_system_names, remote_ids, remote_names, async_req=True)
        >>> result = thread.get()
        
        :param file_system_replica_link: (required)
        :type file_system_replica_link: models.FileSystemReplicaLink
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param remote_file_systems: A list of remote_file_systems to query for. Overrides remote_file_system_names keyword argument.
        :type remote_file_systems: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param remote_file_system_names: A comma-separated list of remote file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with the `remote_file_system_ids` query
                                        parameter.
        :type remote_file_system_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            file_system_replica_link=file_system_replica_link,
            ids=ids,
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            remote_file_system_names=remote_file_system_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids'], kwargs)
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(remote_file_systems, ['remote_file_system_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['ids', 'local_file_system_ids', 'local_file_system_names', 'remote_file_system_names', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('FileSystemReplicaLinksApi', 'api20_file_system_replica_links_post_with_http_info', kwargs)

    def get_file_system_replica_links_transfer(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        names_or_owners: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names_or_owner_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. Either the names of the snapshots or the owning file systems.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-system-replica-links/transfer  # noqa: E501
        
        List the transfer status details for file system replication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_file_system_replica_links_transfer_get_with_http_info(continuation_token, filter, ids, limit, names_or_owner_names, offset, remote_ids, remote_names, sort, total_only, async_req=True)
        >>> result = thread.get()
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param names_or_owners: A list of names_or_owners to query for. Overrides names_or_owner_names keyword argument.
        :type names_or_owners: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names_or_owner_names: A comma-separated list of resource names. Either the names of the snapshots or
                                    the owning file systems.
        :type names_or_owner_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names_or_owner_names=names_or_owner_names,
            offset=offset,
            remote_ids=remote_ids,
            remote_names=remote_names,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids'], kwargs)
        _process_references(names_or_owners, ['names_or_owner_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['ids', 'names_or_owner_names', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('FileSystemReplicaLinksApi', 'api20_file_system_replica_links_transfer_get_with_http_info', kwargs)

    def delete_file_system_snapshots(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE file-system-snapshots  # noqa: E501
        
        Delete a file system snapshot.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_file_system_snapshots_delete_with_http_info(ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('FileSystemSnapshotsApi', 'api20_file_system_snapshots_delete_with_http_info', kwargs)

    def get_file_system_snapshots(
        self,
        owners: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        names_or_owners: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. If not set, lists both objects that are destroyed and those that are not destroyed. If object name(s) are specified in the `names` parameter, then each object referenced must exist. If `destroyed` is set to `true`, then each object referenced must also be destroyed. If `destroyed` is set to `false`, then each object referenced must also not be destroyed. An error is returned if any of these conditions are not met.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names_or_owner_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. Either the names of the snapshots or the owning file systems.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        owner_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of owning file system IDs. If after filtering, there is not at least one resource that matches each of the elements of owner IDs, then an error is returned. This cannot be provided together with the `ids`, `names_or_owner_names`, or `names_or_sources` query parameters.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-system-snapshots  # noqa: E501
        
        List file system snapshots.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_file_system_snapshots_get_with_http_info(continuation_token, destroyed, filter, ids, limit, names_or_owner_names, offset, owner_ids, sort, total_only, async_req=True)
        >>> result = thread.get()
        
        :param owners: A list of owners to query for. Overrides owner_ids keyword argument.
        :type owners: ReferenceType or List[ReferenceType], optional
        :param names_or_owners: A list of names_or_owners to query for. Overrides names_or_owner_names keyword argument.
        :type names_or_owners: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        If not set, lists both objects that are destroyed and those that are not
                        destroyed. If object name(s) are specified in the `names` parameter, then
                        each object referenced must exist. If `destroyed` is set to `true`, then
                        each object referenced must also be destroyed. If `destroyed` is set to
                        `false`, then each object referenced must also not be destroyed. An error is
                        returned if any of these conditions are not met.
        :type destroyed: bool
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names_or_owner_names: A comma-separated list of resource names. Either the names of the snapshots or
                                    the owning file systems.
        :type names_or_owner_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param owner_ids: A comma-separated list of owning file system IDs. If after filtering, there is
                        not at least one resource that matches each of the elements of owner IDs,
                        then an error is returned. This cannot be provided together with the `ids`,
                        `names_or_owner_names`, or `names_or_sources` query parameters.
        :type owner_ids: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            ids=ids,
            limit=limit,
            names_or_owner_names=names_or_owner_names,
            offset=offset,
            owner_ids=owner_ids,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids'], kwargs)
        _process_references(names_or_owners, ['names_or_owner_names'], kwargs)
        _process_references(owners, ['owner_ids'], kwargs)
        _fixup_list_type_params(['ids', 'names_or_owner_names', 'owner_ids', 'sort'], kwargs)
        return self._call_api('FileSystemSnapshotsApi', 'api20_file_system_snapshots_get_with_http_info', kwargs)

    def patch_file_system_snapshots(
        self,
        file_system_snapshot: 'models.FileSystemSnapshot',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        latest_replica: Annotated[Optional[StrictBool], Field(description="Used when destroying a snapshot. If not present or `false`, and the snapshot is the latest replicated snapshot, then destroy will fail. If `true` or the snapshot is not the latest replicated snapshot, then destroy will be successful.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH file-system-snapshots  # noqa: E501
        
        Modify file system snapshot attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_file_system_snapshots_patch_with_http_info(file_system_snapshot, ids, latest_replica, names, async_req=True)
        >>> result = thread.get()
        
        :param file_system_snapshot: (required)
        :type file_system_snapshot: models.FileSystemSnapshot
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param latest_replica: Used when destroying a snapshot. If not present or `false`, and the snapshot is
                            the latest replicated snapshot, then destroy will fail. If `true` or the
                            snapshot is not the latest replicated snapshot, then destroy will be
                            successful.
        :type latest_replica: bool
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            file_system_snapshot=file_system_snapshot,
            ids=ids,
            latest_replica=latest_replica,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('FileSystemSnapshotsApi', 'api20_file_system_snapshots_patch_with_http_info', kwargs)

    def delete_file_system_snapshots_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE file-system-snapshots/policies  # noqa: E501
        
        Remove snapshot scheduling policies from a file system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_file_system_snapshots_policies_delete_with_http_info(member_ids, member_names, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('FileSystemSnapshotsApi', 'api20_file_system_snapshots_policies_delete_with_http_info', kwargs)

    def get_file_system_snapshots_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-system-snapshots/policies  # noqa: E501
        
        List file system snapshots mapped to snapshot scheduling policies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_file_system_snapshots_policies_get_with_http_info(continuation_token, filter, limit, member_ids, member_names, offset, policy_ids, policy_names, sort, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('FileSystemSnapshotsApi', 'api20_file_system_snapshots_policies_get_with_http_info', kwargs)

    def post_file_system_snapshots(
        self,
        sources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        send: Annotated[Optional[StrictBool], Field(description="Whether to replicate created snapshots immediately to other arrays. If it's `false`, created snapshots may still be replicated to other arrays according to policy.")] = None,
        source_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of source file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `source_ids`, then an error is returned. This cannot be provided together with the `names_or_sources` or `sources` query parameters.")] = None,
        source_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of names for the source of the object. If there is not at least one resource that matches each of the elements of `source_names`, an error is returned.")] = None,
        targets: Annotated[Optional[conlist(StrictStr)], Field(description="The target arrays to replicate created snapshots to. Only valid when `send` is `true`.")] = None,
        file_system_snapshot: Optional['models.FileSystemSnapshotPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST file-system-snapshots  # noqa: E501
        
        Create a snapshot for a specified source file system. If a source file system is not specified, creates snapshots for all file systems on the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_file_system_snapshots_post_with_http_info(send, source_ids, source_names, targets, file_system_snapshot, async_req=True)
        >>> result = thread.get()
        
        :param sources: A list of sources to query for. Overrides source_ids and source_names keyword arguments.
        :type sources: ReferenceType or List[ReferenceType], optional
        :param send: Whether to replicate created snapshots immediately to other arrays. If it's
                    `false`, created snapshots may still be replicated to other arrays according
                    to policy.
        :type send: bool
        :param source_ids: A comma-separated list of source file system IDs. If after filtering, there is
                        not at least one resource that matches each of the elements of `source_ids`,
                        then an error is returned. This cannot be provided together with the
                        `names_or_sources` or `sources` query parameters.
        :type source_ids: List[str]
        :param source_names: A comma-separated list of names for the source of the object. If there is not at
                            least one resource that matches each of the elements of `source_names`, an
                            error is returned.
        :type source_names: List[str]
        :param targets: The target arrays to replicate created snapshots to. Only valid when `send` is
                        `true`.
        :type targets: List[str]
        :param file_system_snapshot:
        :type file_system_snapshot: FileSystemSnapshotPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            send=send,
            source_ids=source_ids,
            source_names=source_names,
            targets=targets,
            file_system_snapshot=file_system_snapshot,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(sources, ['source_ids', 'source_names'], kwargs)
        _fixup_list_type_params(['source_ids', 'source_names', 'targets'], kwargs)
        return self._call_api('FileSystemSnapshotsApi', 'api20_file_system_snapshots_post_with_http_info', kwargs)

    def delete_file_system_snapshots_transfer(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE file-system-snapshots/transfer  # noqa: E501
        
        Delete file system snapshot transfers from the source array to the target array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_file_system_snapshots_transfer_delete_with_http_info(ids, names, remote_ids, remote_names, async_req=True)
        >>> result = thread.get()
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('FileSystemSnapshotsApi', 'api20_file_system_snapshots_transfer_delete_with_http_info', kwargs)

    def get_file_system_snapshots_transfer(
        self,
        names_or_owners: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names_or_owner_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. Either the names of the snapshots or the owning file systems.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-system-snapshots/transfer  # noqa: E501
        
        List file system snapshot transfers from the source array to the target array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_file_system_snapshots_transfer_get_with_http_info(continuation_token, filter, ids, limit, names_or_owner_names, offset, sort, total_only, async_req=True)
        >>> result = thread.get()
        
        :param names_or_owners: A list of names_or_owners to query for. Overrides names_or_owner_names keyword argument.
        :type names_or_owners: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names_or_owner_names: A comma-separated list of resource names. Either the names of the snapshots or
                                    the owning file systems.
        :type names_or_owner_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names_or_owner_names=names_or_owner_names,
            offset=offset,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids'], kwargs)
        _process_references(names_or_owners, ['names_or_owner_names'], kwargs)
        _fixup_list_type_params(['ids', 'names_or_owner_names', 'sort'], kwargs)
        return self._call_api('FileSystemSnapshotsApi', 'api20_file_system_snapshots_transfer_get_with_http_info', kwargs)

    def delete_file_systems(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE file-systems  # noqa: E501
        
        Deletes a file system. Deleting a file system is equivalent to eradication. A file system's `destroyed` parameter must be set to `true` before a file system can be deleted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_file_systems_delete_with_http_info(ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('FileSystemsApi', 'api20_file_systems_delete_with_http_info', kwargs)

    def get_file_systems(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. If not set, lists both objects that are destroyed and those that are not destroyed. If object name(s) are specified in the `names` parameter, then each object referenced must exist. If `destroyed` is set to `true`, then each object referenced must also be destroyed. If `destroyed` is set to `false`, then each object referenced must also not be destroyed. An error is returned if any of these conditions are not met.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-systems  # noqa: E501
        
        List one or more file systems on the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_file_systems_get_with_http_info(continuation_token, destroyed, filter, ids, limit, names, offset, sort, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        If not set, lists both objects that are destroyed and those that are not
                        destroyed. If object name(s) are specified in the `names` parameter, then
                        each object referenced must exist. If `destroyed` is set to `true`, then
                        each object referenced must also be destroyed. If `destroyed` is set to
                        `false`, then each object referenced must also not be destroyed. An error is
                        returned if any of these conditions are not met.
        :type destroyed: bool
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('FileSystemsApi', 'api20_file_systems_get_with_http_info', kwargs)

    def get_file_systems_groups_performance(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        gids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs. This cannot be provided together with `group_names` query parameter.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group names. This cannot be provided together with `gids` query parameter.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-systems/groups/performance  # noqa: E501
        
        List a group’s I/O performance metrics on a file system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_file_systems_groups_performance_get_with_http_info(file_system_ids, file_system_names, filter, gids, group_names, limit, names, sort, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param gids: A comma-separated list of group IDs. This cannot be provided together with
                    `group_names` query parameter.
        :type gids: List[str]
        :param group_names: A comma-separated list of group names. This cannot be provided together with
                            `gids` query parameter.
        :type group_names: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            filter=filter,
            gids=gids,
            group_names=group_names,
            limit=limit,
            names=names,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(groups, ['group_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'gids', 'group_names', 'names', 'sort'], kwargs)
        return self._call_api('FileSystemsApi', 'api20_file_systems_groups_performance_get_with_http_info', kwargs)

    def patch_file_systems(
        self,
        file_system: 'models.FileSystemPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        delete_link_on_eradication: Annotated[Optional[StrictBool], Field(description="If set to `true`, the file system can be destroyed, even if it has a replica link. If set to `false`, the file system cannot be destroyed if it has a replica link. Defaults to `false`.")] = None,
        discard_detailed_permissions: Annotated[Optional[StrictBool], Field(description="This parameter must be set to `true` in order to change a file system's `access_control_style` from a style that supports more detailed access control lists to a style that only supports less detailed mode bits as a form of permission control. This parameter may not be set to `true` any other time. Setting this parameter to `true` is acknowledgement that any more detailed access control lists currently set within the file system will be lost, and NFS permission controls will only be enforced at the granularity level of NFS mode bits.")] = None,
        discard_non_snapshotted_data: Annotated[Optional[StrictBool], Field(description="This parameter must be set to `true` in order to restore a file system from a snapshot or to demote a file system (which restores the file system from the common baseline snapshot). Setting this parameter to `true` is acknowledgement that any non-snapshotted data currently in the file system will be irretrievably lost.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        ignore_usage: Annotated[Optional[StrictBool], Field(description="Allow update operations that lead to a `hard_limit_enabled` file system with usage over its provisioned size. The update can be either setting `hard_limit_enabled` when usage is higher than provisioned size, or resize provisioned size to a value under usage when `hard_limit_enabled` is `true`.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH file-systems  # noqa: E501
        
        Modify a file system’s attributes including its export protocols and limits.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_file_systems_patch_with_http_info(file_system, delete_link_on_eradication, discard_detailed_permissions, discard_non_snapshotted_data, ids, ignore_usage, names, async_req=True)
        >>> result = thread.get()
        
        :param file_system: (required)
        :type file_system: models.FileSystemPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param delete_link_on_eradication: If set to `true`, the file system can be destroyed, even if it has a replica
                                        link. If set to `false`, the file system cannot be destroyed if it has a
                                        replica link. Defaults to `false`.
        :type delete_link_on_eradication: bool
        :param discard_detailed_permissions: This parameter must be set to `true` in order to change a file system's
                                            `access_control_style` from a style that supports more detailed access
                                            control lists to a style that only supports less detailed mode bits as
                                            a form of permission control. This parameter may not be set to `true`
                                            any other time. Setting this parameter to `true` is acknowledgement
                                            that any more detailed access control lists currently set within the
                                            file system will be lost, and NFS permission controls will only be
                                            enforced at the granularity level of NFS mode bits.
        :type discard_detailed_permissions: bool
        :param discard_non_snapshotted_data: This parameter must be set to `true` in order to restore a file system from a
                                            snapshot or to demote a file system (which restores the file system
                                            from the common baseline snapshot). Setting this parameter to `true` is
                                            acknowledgement that any non-snapshotted data currently in the file
                                            system will be irretrievably lost.
        :type discard_non_snapshotted_data: bool
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param ignore_usage: Allow update operations that lead to a `hard_limit_enabled` file system with
                            usage over its provisioned size. The update can be either setting
                            `hard_limit_enabled` when usage is higher than provisioned size, or resize
                            provisioned size to a value under usage when `hard_limit_enabled` is
                            `true`.
        :type ignore_usage: bool
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            file_system=file_system,
            delete_link_on_eradication=delete_link_on_eradication,
            discard_detailed_permissions=discard_detailed_permissions,
            discard_non_snapshotted_data=discard_non_snapshotted_data,
            ids=ids,
            ignore_usage=ignore_usage,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('FileSystemsApi', 'api20_file_systems_patch_with_http_info', kwargs)

    def get_file_systems_performance(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        protocol: Annotated[Optional[StrictStr], Field(description="Display the performance of a specified protocol. Valid values are `all`, `HTTP`, `SMB`, `NFS`, and `S3`. If not specified, defaults to `all`, which will provide the combined performance of all available protocols.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-systems/performance  # noqa: E501
        
        Displays the performance metrics for a file system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_file_systems_performance_get_with_http_info(continuation_token, end_time, filter, ids, limit, names, offset, protocol, resolution, sort, start_time, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param protocol: Display the performance of a specified protocol. Valid values are `all`, `HTTP`,
                        `SMB`, `NFS`, and `S3`. If not specified, defaults to `all`, which will
                        provide the combined performance of all available protocols.
        :type protocol: str
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            end_time=end_time,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            protocol=protocol,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('FileSystemsApi', 'api20_file_systems_performance_get_with_http_info', kwargs)

    def delete_file_systems_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE file-systems/policies  # noqa: E501
        
        Remove a snapshot scheduling policy from a file system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_file_systems_policies_delete_with_http_info(member_ids, member_names, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('FileSystemsApi', 'api20_file_systems_policies_delete_with_http_info', kwargs)

    def get_file_systems_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-systems/policies  # noqa: E501
        
        List file system snapshot scheduling policies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_file_systems_policies_get_with_http_info(continuation_token, filter, limit, member_ids, member_names, offset, policy_ids, policy_names, sort, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('FileSystemsApi', 'api20_file_systems_policies_get_with_http_info', kwargs)

    def post_file_systems_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST file-systems/policies  # noqa: E501
        
        Apply a snapshot scheduling policy to a file system. Only one file system can be mapped to a policy at a time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_file_systems_policies_post_with_http_info(member_ids, member_names, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('FileSystemsApi', 'api20_file_systems_policies_post_with_http_info', kwargs)

    def post_file_systems(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        file_system: 'models.FileSystemPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        discard_non_snapshotted_data: Annotated[Optional[StrictBool], Field(description="This parameter must be set to `true` in order to restore a file system from a snapshot or to demote a file system (which restores the file system from the common baseline snapshot). Setting this parameter to `true` is acknowledgement that any non-snapshotted data currently in the file system will be irretrievably lost.")] = None,
        overwrite: Annotated[Optional[StrictBool], Field(description="When used for snapshot restore, overwrites (`true`) an existing file system.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST file-systems  # noqa: E501
        
        Create a file system on the current array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_file_systems_post_with_http_info(names, file_system, discard_non_snapshotted_data, overwrite, async_req=True)
        >>> result = thread.get()
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param file_system: (required)
        :type file_system: models.FileSystemPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param discard_non_snapshotted_data: This parameter must be set to `true` in order to restore a file system from a
                                            snapshot or to demote a file system (which restores the file system
                                            from the common baseline snapshot). Setting this parameter to `true` is
                                            acknowledgement that any non-snapshotted data currently in the file
                                            system will be irretrievably lost.
        :type discard_non_snapshotted_data: bool
        :param overwrite: When used for snapshot restore, overwrites (`true`) an existing file system.
        :type overwrite: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            file_system=file_system,
            discard_non_snapshotted_data=discard_non_snapshotted_data,
            overwrite=overwrite,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('FileSystemsApi', 'api20_file_systems_post_with_http_info', kwargs)

    def get_file_systems_users_performance(
        self,
        users: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        uids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of user IDs. This cannot be provided together with `user_names` query parameter.")] = None,
        user_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of user names. This cannot be provided together with `uids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-systems/users/performance  # noqa: E501
        
        List a user’s I/O performance metrics on a file system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_file_systems_users_performance_get_with_http_info(file_system_ids, file_system_names, filter, limit, names, sort, total_only, uids, user_names, async_req=True)
        >>> result = thread.get()
        
        :param users: A list of users to query for. Overrides user_names keyword argument.
        :type users: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param uids: A comma-separated list of user IDs. This cannot be provided together with
                    `user_names` query parameter.
        :type uids: List[int]
        :param user_names: A comma-separated list of user names. This cannot be provided together with
                        `uids` query parameter.
        :type user_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            filter=filter,
            limit=limit,
            names=names,
            sort=sort,
            total_only=total_only,
            uids=uids,
            user_names=user_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _process_references(users, ['user_names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'names', 'sort', 'uids', 'user_names'], kwargs)
        return self._call_api('FileSystemsApi', 'api20_file_systems_users_performance_get_with_http_info', kwargs)

    def get_hardware(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET hardware  # noqa: E501
        
        List hardware slots and bays and the status of installed components.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_hardware_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('HardwareApi', 'api20_hardware_get_with_http_info', kwargs)

    def patch_hardware(
        self,
        hardware: 'models.Hardware',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH hardware  # noqa: E501
        
        Controls the visual identification light of the specified hardware component.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_hardware_patch_with_http_info(hardware, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param hardware: (required)
        :type hardware: models.Hardware
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            hardware=hardware,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('HardwareApi', 'api20_hardware_patch_with_http_info', kwargs)

    def get_hardware_connectors(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET hardware-connectors  # noqa: E501
        
        List array connection information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_hardware_connectors_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('HardwareConnectorsApi', 'api20_hardware_connectors_get_with_http_info', kwargs)

    def patch_hardware_connectors(
        self,
        hardware_connector: 'models.HardwareConnector',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH hardware-connectors  # noqa: E501
        
        Modify array connection information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_hardware_connectors_patch_with_http_info(hardware_connector, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param hardware_connector: (required)
        :type hardware_connector: models.HardwareConnector
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            hardware_connector=hardware_connector,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('HardwareConnectorsApi', 'api20_hardware_connectors_patch_with_http_info', kwargs)

    def delete_keytabs(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE keytabs  # noqa: E501
        
        Delete a Kerberos keytab file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_keytabs_delete_with_http_info(ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('KeytabsApi', 'api20_keytabs_delete_with_http_info', kwargs)

    def get_keytabs_download(
        self,
        keytabs: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        keytab_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of keytab IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `keytab_names` query parameter.")] = None,
        keytab_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of keytab names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `keytab_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET keytabs/download  # noqa: E501
        
        Download a Kerberos keytab file. The file can be downloaded in the native binary format or a base64 encoded format. If not specified, defaults to binary.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_keytabs_download_get_with_http_info(keytab_ids, keytab_names, async_req=True)
        >>> result = thread.get()
        
        :param keytabs: A list of keytabs to query for. Overrides keytab_ids and keytab_names keyword arguments.
        :type keytabs: ReferenceType or List[ReferenceType], optional
        :param keytab_ids: A comma-separated list of keytab IDs. If after filtering, there is not at least
                        one resource that matches each of the elements, then an error is returned.
                        This cannot be provided together with the `keytab_names` query parameter.
        :type keytab_ids: List[str]
        :param keytab_names: A comma-separated list of keytab names. If there is not at least one resource
                            that matches each of the elements, then an error is returned. This cannot
                            be provided together with `keytab_ids` query parameter.
        :type keytab_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            keytab_ids=keytab_ids,
            keytab_names=keytab_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(keytabs, ['keytab_ids', 'keytab_names'], kwargs)
        _fixup_list_type_params(['keytab_ids', 'keytab_names'], kwargs)
        return self._call_api('KeytabsApi', 'api20_keytabs_download_get_with_http_info', kwargs)

    def get_keytabs(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET keytabs  # noqa: E501
        
        List a Kerberos keytab file and its configuration information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_keytabs_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('KeytabsApi', 'api20_keytabs_get_with_http_info', kwargs)

    def post_keytabs(
        self,
        keytab: 'models.KeytabPost',
        name_prefixes: Annotated[Optional[StrictStr], Field(description="The prefix to use for the names of all Kerberos keytab objects that are being created.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST keytabs  # noqa: E501
        
        Import a Kerberos keytab file from a Key Distribution Center.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_keytabs_post_with_http_info(keytab, name_prefixes, async_req=True)
        >>> result = thread.get()
        
        :param keytab: (required)
        :type keytab: models.KeytabPost
        :param name_prefixes: The prefix to use for the names of all Kerberos keytab objects that are being
                            created.
        :type name_prefixes: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            keytab=keytab,
            name_prefixes=name_prefixes,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('KeytabsApi', 'api20_keytabs_post_with_http_info', kwargs)

    def post_keytabs_upload(
        self,
        keytab_file: Annotated[StrictStr, Field(..., description="The keytab file to upload.")],
        name_prefixes: Annotated[Optional[StrictStr], Field(description="The prefix to use for the names of all Kerberos keytab objects that are being created.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST keytabs/upload  # noqa: E501
        
        Upload a Kerberos keytab file to the array. The file can be uploaded in the native binary format or a base64 encoded format. If not specified, defaults to binary. The procedure to upload a file may vary depending on the type of REST client.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_keytabs_upload_post_with_http_info(keytab_file, name_prefixes, async_req=True)
        >>> result = thread.get()
        
        :param keytab_file: The keytab file to upload. (required)
        :type keytab_file: str
        :param name_prefixes: The prefix to use for the names of all Kerberos keytab objects that are being
                            created.
        :type name_prefixes: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            keytab_file=keytab_file,
            name_prefixes=name_prefixes,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('KeytabsApi', 'api20_keytabs_upload_post_with_http_info', kwargs)

    def delete_lifecycle_rules(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket IDs. If after filtering, there is not at least one resource that matches each of the elements of `bucket_ids`, then an error is returned. This cannot be provided together with the `bucket_names` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket names. If there is not at least one resource that matches each of the elements of `bucket_names`, then an error is returned. This cannot be provided together with the `bucket_ids` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE lifecycle-rules  # noqa: E501
        
        Deletes individual lifecycle rules by name or id, or deletes all rules for a bucket. If `ids` is specified, `bucket_names` or `bucket_ids` is also required. If `bucket_names` or `bucket_ids` are specified without `ids`, delete all the rules for the bucket.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_lifecycle_rules_delete_with_http_info(bucket_ids, bucket_names, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param buckets: A list of buckets to query for. Overrides bucket_ids and bucket_names keyword arguments.
        :type buckets: ReferenceType or List[ReferenceType], optional
        :param bucket_ids: A comma-separated list of bucket IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `bucket_ids`, then an
                        error is returned. This cannot be provided together with the `bucket_names`
                        query parameter. This can be provided with the `ids` query parameter but not
                        with `names`.
        :type bucket_ids: List[str]
        :param bucket_names: A comma-separated list of bucket names. If there is not at least one resource
                            that matches each of the elements of `bucket_names`, then an error is
                            returned. This cannot be provided together with the `bucket_ids` query
                            parameter. This can be provided with the `ids` query parameter but not with
                            `names`.
        :type bucket_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            bucket_ids=bucket_ids,
            bucket_names=bucket_names,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(buckets, ['bucket_ids', 'bucket_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['bucket_ids', 'bucket_names', 'ids', 'names'], kwargs)
        return self._call_api('LifecycleRulesApi', 'api20_lifecycle_rules_delete_with_http_info', kwargs)

    def get_lifecycle_rules(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket IDs. If after filtering, there is not at least one resource that matches each of the elements of `bucket_ids`, then an error is returned. This cannot be provided together with the `bucket_names` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket names. If there is not at least one resource that matches each of the elements of `bucket_names`, then an error is returned. This cannot be provided together with the `bucket_ids` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET lifecycle-rules  # noqa: E501
        
        Returns a list of lifecycle rules. If `names` is specified, list the individual rules. If `ids` is specified, `bucket_names` or `bucket_ids` is also required. If `bucket_names` or `bucket_ids` are specified without `ids`, list all the rules for the bucket.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_lifecycle_rules_get_with_http_info(bucket_ids, bucket_names, continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param buckets: A list of buckets to query for. Overrides bucket_ids and bucket_names keyword arguments.
        :type buckets: ReferenceType or List[ReferenceType], optional
        :param bucket_ids: A comma-separated list of bucket IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `bucket_ids`, then an
                        error is returned. This cannot be provided together with the `bucket_names`
                        query parameter. This can be provided with the `ids` query parameter but not
                        with `names`.
        :type bucket_ids: List[str]
        :param bucket_names: A comma-separated list of bucket names. If there is not at least one resource
                            that matches each of the elements of `bucket_names`, then an error is
                            returned. This cannot be provided together with the `bucket_ids` query
                            parameter. This can be provided with the `ids` query parameter but not with
                            `names`.
        :type bucket_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            bucket_ids=bucket_ids,
            bucket_names=bucket_names,
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(buckets, ['bucket_ids', 'bucket_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['bucket_ids', 'bucket_names', 'ids', 'names', 'sort'], kwargs)
        return self._call_api('LifecycleRulesApi', 'api20_lifecycle_rules_get_with_http_info', kwargs)

    def patch_lifecycle_rules(
        self,
        lifecycle: 'models.LifecycleRulePatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket IDs. If after filtering, there is not at least one resource that matches each of the elements of `bucket_ids`, then an error is returned. This cannot be provided together with the `bucket_names` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket names. If there is not at least one resource that matches each of the elements of `bucket_names`, then an error is returned. This cannot be provided together with the `bucket_ids` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH lifecycle-rules  # noqa: E501
        
        Modify an existing lifecycle rule by name or id. If `ids` is specified, `bucket_names` or `bucket_ids` is also required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_lifecycle_rules_patch_with_http_info(lifecycle, bucket_ids, bucket_names, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param lifecycle: (required)
        :type lifecycle: models.LifecycleRulePatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param buckets: A list of buckets to query for. Overrides bucket_ids and bucket_names keyword arguments.
        :type buckets: ReferenceType or List[ReferenceType], optional
        :param bucket_ids: A comma-separated list of bucket IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `bucket_ids`, then an
                        error is returned. This cannot be provided together with the `bucket_names`
                        query parameter. This can be provided with the `ids` query parameter but not
                        with `names`.
        :type bucket_ids: List[str]
        :param bucket_names: A comma-separated list of bucket names. If there is not at least one resource
                            that matches each of the elements of `bucket_names`, then an error is
                            returned. This cannot be provided together with the `bucket_ids` query
                            parameter. This can be provided with the `ids` query parameter but not with
                            `names`.
        :type bucket_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            lifecycle=lifecycle,
            bucket_ids=bucket_ids,
            bucket_names=bucket_names,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(buckets, ['bucket_ids', 'bucket_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['bucket_ids', 'bucket_names', 'ids', 'names'], kwargs)
        return self._call_api('LifecycleRulesApi', 'api20_lifecycle_rules_patch_with_http_info', kwargs)

    def post_lifecycle_rules(
        self,
        rule: 'models.LifecycleRulePost',
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST lifecycle-rules  # noqa: E501
        
        Creates a lifecycle rule. `bucket` and `keep_previous_version_for` are required. If `rule_id` is not specified, it will be automatically generated in the format "fbRuleIdX".  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_lifecycle_rules_post_with_http_info(rule, async_req=True)
        >>> result = thread.get()
        
        :param rule: (required)
        :type rule: models.LifecycleRulePost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            rule=rule,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('LifecycleRulesApi', 'api20_lifecycle_rules_post_with_http_info', kwargs)

    def delete_link_aggregation_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE link-aggregation-groups  # noqa: E501
        
        Remove a link aggregation group to unbind the ports.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_link_aggregation_groups_delete_with_http_info(ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('LinkAggregationGroupsApi', 'api20_link_aggregation_groups_delete_with_http_info', kwargs)

    def get_link_aggregation_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET link-aggregation-groups  # noqa: E501
        
        List the status and attributes of the Ethernet ports in the configured link aggregation groups.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_link_aggregation_groups_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('LinkAggregationGroupsApi', 'api20_link_aggregation_groups_get_with_http_info', kwargs)

    def patch_link_aggregation_groups(
        self,
        link_aggregation_group: 'models.Api20LinkAggregationGroupsPatchRequest',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH link-aggregation-groups  # noqa: E501
        
        Modify link aggregation groups by adding and removing Ethernet ports.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_link_aggregation_groups_patch_with_http_info(link_aggregation_group, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param link_aggregation_group: (required)
        :type link_aggregation_group: models.Api20LinkAggregationGroupsPatchRequest
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            link_aggregation_group=link_aggregation_group,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('LinkAggregationGroupsApi', 'api20_link_aggregation_groups_patch_with_http_info', kwargs)

    def post_link_aggregation_groups(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        link_aggregation_group: 'models.LinkAggregationGroup',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST link-aggregation-groups  # noqa: E501
        
        Create a link aggregation group of Ethernet ports on the array.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_link_aggregation_groups_post_with_http_info(names, link_aggregation_group, async_req=True)
        >>> result = thread.get()
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param link_aggregation_group: (required)
        :type link_aggregation_group: models.LinkAggregationGroup
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            link_aggregation_group=link_aggregation_group,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('LinkAggregationGroupsApi', 'api20_link_aggregation_groups_post_with_http_info', kwargs)

    def get_logs(
        self,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET logs  # noqa: E501
        
        Download a history of log events from the array to provide to Pure Technical Services for analysis.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_logs_get_with_http_info(end_time, start_time, async_req=True)
        >>> result = thread.get()
        
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            end_time=end_time,
            start_time=start_time,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('LogsApi', 'api20_logs_get_with_http_info', kwargs)

    def delete_network_interfaces(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE network-interfaces  # noqa: E501
        
        Remove a data VIP. Once removed, any clients connected through the data VIP will lose their connection to the file system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_network_interfaces_delete_with_http_info(ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('NetworkInterfacesApi', 'api20_network_interfaces_delete_with_http_info', kwargs)

    def get_network_interfaces(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET network-interfaces  # noqa: E501
        
        List network interfaces and their attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_network_interfaces_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('NetworkInterfacesApi', 'api20_network_interfaces_get_with_http_info', kwargs)

    def patch_network_interfaces(
        self,
        network_interface: 'models.NetworkInterfacePatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH network-interfaces  # noqa: E501
        
        Modify the attributes of a data VIP.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_network_interfaces_patch_with_http_info(network_interface, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param network_interface: (required)
        :type network_interface: models.NetworkInterfacePatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            network_interface=network_interface,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('NetworkInterfacesApi', 'api20_network_interfaces_patch_with_http_info', kwargs)

    def post_network_interfaces(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        network_interface: 'models.NetworkInterface',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST network-interfaces  # noqa: E501
        
        Create a data VIP to export a file system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_network_interfaces_post_with_http_info(names, network_interface, async_req=True)
        >>> result = thread.get()
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param network_interface: (required)
        :type network_interface: models.NetworkInterface
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            network_interface=network_interface,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('NetworkInterfacesApi', 'api20_network_interfaces_post_with_http_info', kwargs)

    def delete_object_store_access_keys(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-access-keys  # noqa: E501
        
        Delete an object store access key. Once an access key has been deleted, it cannot be recovered.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_object_store_access_keys_delete_with_http_info(names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('ObjectStoreAccessKeysApi', 'api20_object_store_access_keys_delete_with_http_info', kwargs)

    def get_object_store_access_keys(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-access-keys  # noqa: E501
        
        List object store access keys.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_object_store_access_keys_get_with_http_info(continuation_token, filter, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('ObjectStoreAccessKeysApi', 'api20_object_store_access_keys_get_with_http_info', kwargs)

    def patch_object_store_access_keys(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        object_store_access_key: 'models.ObjectStoreAccessKey',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH object-store-access-keys  # noqa: E501
        
        Enable or disable object store access keys.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_object_store_access_keys_patch_with_http_info(names, object_store_access_key, async_req=True)
        >>> result = thread.get()
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param object_store_access_key: (required)
        :type object_store_access_key: models.ObjectStoreAccessKey
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            object_store_access_key=object_store_access_key,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('ObjectStoreAccessKeysApi', 'api20_object_store_access_keys_patch_with_http_info', kwargs)

    def post_object_store_access_keys(
        self,
        object_store_access_key: 'models.ObjectStoreAccessKeyPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names to import. To import a set of credentials, this field must be specified with the `secret_access_key` body parameter. If both of these are not specified, the system will generate a new set of credentials.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-access-keys  # noqa: E501
        
        Create or import object store access keys.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_object_store_access_keys_post_with_http_info(object_store_access_key, names, async_req=True)
        >>> result = thread.get()
        
        :param object_store_access_key: (required)
        :type object_store_access_key: models.ObjectStoreAccessKeyPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param names: A comma-separated list of resource names to import. To import a set of
                    credentials, this field must be specified with the `secret_access_key` body
                    parameter. If both of these are not specified, the system will generate a new
                    set of credentials.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            object_store_access_key=object_store_access_key,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('ObjectStoreAccessKeysApi', 'api20_object_store_access_keys_post_with_http_info', kwargs)

    def get_object_store_access_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-access-policies  # noqa: E501
        
        List all access policy names and IDs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_object_store_access_policies_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('ObjectStoreAccessPoliciesApi', 'api20_object_store_access_policies_get_with_http_info', kwargs)

    def delete_object_store_access_policies_object_store_users(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-access-policies/object-store-users  # noqa: E501
        
        Revokes an object store user's access policy.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_object_store_access_policies_object_store_users_delete_with_http_info(member_ids, member_names, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('ObjectStoreAccessPoliciesApi', 'api20_object_store_access_policies_object_store_users_delete_with_http_info', kwargs)

    def get_object_store_access_policies_object_store_users(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-access-policies/object-store-users  # noqa: E501
        
        List object store users and their access policies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_object_store_access_policies_object_store_users_get_with_http_info(continuation_token, filter, limit, member_ids, member_names, offset, policy_ids, policy_names, sort, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('ObjectStoreAccessPoliciesApi', 'api20_object_store_access_policies_object_store_users_get_with_http_info', kwargs)

    def post_object_store_access_policies_object_store_users(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-access-policies/object-store-users  # noqa: E501
        
        Grant access policies to an object store user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_object_store_access_policies_object_store_users_post_with_http_info(member_ids, member_names, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('ObjectStoreAccessPoliciesApi', 'api20_object_store_access_policies_object_store_users_post_with_http_info', kwargs)

    def delete_object_store_accounts(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-accounts  # noqa: E501
        
        Delete an object store account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_object_store_accounts_delete_with_http_info(ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('ObjectStoreAccountsApi', 'api20_object_store_accounts_delete_with_http_info', kwargs)

    def get_object_store_accounts(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-accounts  # noqa: E501
        
        List object store accounts and their attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_object_store_accounts_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('ObjectStoreAccountsApi', 'api20_object_store_accounts_get_with_http_info', kwargs)

    def post_object_store_accounts(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-accounts  # noqa: E501
        
        Create an object store account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_object_store_accounts_post_with_http_info(names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('ObjectStoreAccountsApi', 'api20_object_store_accounts_post_with_http_info', kwargs)

    def delete_object_store_remote_credentials(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-remote-credentials  # noqa: E501
        
        Delete object store remote credentials.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_object_store_remote_credentials_delete_with_http_info(ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('ObjectStoreRemoteCredentialsApi', 'api20_object_store_remote_credentials_delete_with_http_info', kwargs)

    def get_object_store_remote_credentials(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-remote-credentials  # noqa: E501
        
        List object store remote credentials used by bucket replica links to access buckets on remote arrays or targets.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_object_store_remote_credentials_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('ObjectStoreRemoteCredentialsApi', 'api20_object_store_remote_credentials_get_with_http_info', kwargs)

    def patch_object_store_remote_credentials(
        self,
        remote_credentials: 'models.ObjectStoreRemoteCredentials',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH object-store-remote-credentials  # noqa: E501
        
        Rename and/or change the access key/secret key pair for object store remote credentials.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_object_store_remote_credentials_patch_with_http_info(remote_credentials, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param remote_credentials: (required)
        :type remote_credentials: models.ObjectStoreRemoteCredentials
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            remote_credentials=remote_credentials,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('ObjectStoreRemoteCredentialsApi', 'api20_object_store_remote_credentials_patch_with_http_info', kwargs)

    def post_object_store_remote_credentials(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        remote_credentials: 'models.ObjectStoreRemoteCredentialsPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-remote-credentials  # noqa: E501
        
        Create object store remote credentials to set up bucket replicat links to a remote array or target.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_object_store_remote_credentials_post_with_http_info(names, remote_credentials, async_req=True)
        >>> result = thread.get()
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param remote_credentials: (required)
        :type remote_credentials: models.ObjectStoreRemoteCredentialsPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            remote_credentials=remote_credentials,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('ObjectStoreRemoteCredentialsApi', 'api20_object_store_remote_credentials_post_with_http_info', kwargs)

    def delete_object_store_users(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-users  # noqa: E501
        
        Delete an object store user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_object_store_users_delete_with_http_info(ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('ObjectStoreUsersApi', 'api20_object_store_users_delete_with_http_info', kwargs)

    def get_object_store_users(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-users  # noqa: E501
        
        List object store users and their attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_object_store_users_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('ObjectStoreUsersApi', 'api20_object_store_users_get_with_http_info', kwargs)

    def delete_object_store_users_object_store_access_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-users/object-store-access-policies  # noqa: E501
        
        Revoke an object store user’s access policy.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_object_store_users_object_store_access_policies_delete_with_http_info(member_ids, member_names, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('ObjectStoreUsersApi', 'api20_object_store_users_object_store_access_policies_delete_with_http_info', kwargs)

    def get_object_store_users_object_store_access_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-users/object-store-access-policies  # noqa: E501
        
        List object store users and their access policies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_object_store_users_object_store_access_policies_get_with_http_info(continuation_token, filter, limit, member_ids, member_names, offset, policy_ids, policy_names, sort, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('ObjectStoreUsersApi', 'api20_object_store_users_object_store_access_policies_get_with_http_info', kwargs)

    def post_object_store_users_object_store_access_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-users/object-store-access-policies  # noqa: E501
        
        Grant access policies to an object store user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_object_store_users_object_store_access_policies_post_with_http_info(member_ids, member_names, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('ObjectStoreUsersApi', 'api20_object_store_users_object_store_access_policies_post_with_http_info', kwargs)

    def post_object_store_users(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        full_access: Annotated[Optional[StrictBool], Field(description="If set to `true`, creates an object store user with full permissions. If set to `false`, creates an object store user with no permission. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-users  # noqa: E501
        
        Create object store users to administer object storage for an object store account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_object_store_users_post_with_http_info(names, full_access, async_req=True)
        >>> result = thread.get()
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param full_access: If set to `true`, creates an object store user with full permissions. If set to
                            `false`, creates an object store user with no permission. If not specified,
                            defaults to `false`.
        :type full_access: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            full_access=full_access,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('ObjectStoreUsersApi', 'api20_object_store_users_post_with_http_info', kwargs)

    def delete_object_store_virtual_hosts(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-virtual-hosts  # noqa: E501
        
        Delete an object store virtual host.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_object_store_virtual_hosts_delete_with_http_info(ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('ObjectStoreVirtualHostsApi', 'api20_object_store_virtual_hosts_delete_with_http_info', kwargs)

    def get_object_store_virtual_hosts(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-virtual-hosts  # noqa: E501
        
        List object store virtual hosts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_object_store_virtual_hosts_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('ObjectStoreVirtualHostsApi', 'api20_object_store_virtual_hosts_get_with_http_info', kwargs)

    def post_object_store_virtual_hosts(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-virtual-hosts  # noqa: E501
        
        Create an object store virtual host. An example of a hostname is buckethost.example.com. A hostname cannot exceed 255 characters in length, it cannot be an IP address, only 10 hostnames are supported, supersets or subsets of existing hostnames with the same root are not allowed. The default hostname is s3.amazonaws.com and it cannot be deleted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_object_store_virtual_hosts_post_with_http_info(names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('ObjectStoreVirtualHostsApi', 'api20_object_store_virtual_hosts_post_with_http_info', kwargs)

    def delete_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE policies  # noqa: E501
        
        Delete one or more snapshot scheduling policies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_policies_delete_with_http_info(ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('PoliciesApi', 'api20_policies_delete_with_http_info', kwargs)

    def delete_policies_file_system_replica_links(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE policies/file-system-replica-links  # noqa: E501
        
        Remove a snapshot scheduling policy mapped to a file system replica link.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_policies_file_system_replica_links_delete_with_http_info(local_file_system_ids, local_file_system_names, member_ids, policy_ids, policy_names, remote_ids, remote_names, async_req=True)
        >>> result = thread.get()
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            member_ids=member_ids,
            policy_ids=policy_ids,
            policy_names=policy_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(members, ['member_ids'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['local_file_system_ids', 'local_file_system_names', 'member_ids', 'policy_ids', 'policy_names', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('PoliciesApi', 'api20_policies_file_system_replica_links_delete_with_http_info', kwargs)

    def get_policies_file_system_replica_links(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        remote_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system IDs. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_names` query parameter.")] = None,
        remote_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_ids` query parameter.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET policies/file-system-replica-links  # noqa: E501
        
        List snapshot scheduling policies for file system replica links.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_policies_file_system_replica_links_get_with_http_info(continuation_token, filter, limit, local_file_system_ids, local_file_system_names, member_ids, offset, policy_ids, policy_names, remote_file_system_ids, remote_file_system_names, remote_ids, remote_names, sort, async_req=True)
        >>> result = thread.get()
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param remote_file_systems: A list of remote_file_systems to query for. Overrides remote_file_system_ids and remote_file_system_names keyword arguments.
        :type remote_file_systems: ReferenceType or List[ReferenceType], optional
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_file_system_ids: A comma-separated list of remote file system IDs. If there is not at least one
                                    resource that matches each of the elements, then an error is returned.
                                    This cannot be provided together with the `remote_file_system_names`
                                    query parameter.
        :type remote_file_system_ids: List[str]
        :param remote_file_system_names: A comma-separated list of remote file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with the `remote_file_system_ids` query
                                        parameter.
        :type remote_file_system_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            member_ids=member_ids,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            remote_file_system_ids=remote_file_system_ids,
            remote_file_system_names=remote_file_system_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(members, ['member_ids'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _process_references(remote_file_systems, ['remote_file_system_ids', 'remote_file_system_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['local_file_system_ids', 'local_file_system_names', 'member_ids', 'policy_ids', 'policy_names', 'remote_file_system_ids', 'remote_file_system_names', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('PoliciesApi', 'api20_policies_file_system_replica_links_get_with_http_info', kwargs)

    def post_policies_file_system_replica_links(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST policies/file-system-replica-links  # noqa: E501
        
        Add a snapshot scheduling policy to a file system replica link.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_policies_file_system_replica_links_post_with_http_info(local_file_system_ids, local_file_system_names, member_ids, policy_ids, policy_names, remote_ids, remote_names, async_req=True)
        >>> result = thread.get()
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            member_ids=member_ids,
            policy_ids=policy_ids,
            policy_names=policy_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(members, ['member_ids'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['local_file_system_ids', 'local_file_system_names', 'member_ids', 'policy_ids', 'policy_names', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('PoliciesApi', 'api20_policies_file_system_replica_links_post_with_http_info', kwargs)

    def delete_policies_file_system_snapshots(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE policies/file-system-snapshots  # noqa: E501
        
        Remove the snapshot scheduling policy mapped to a file system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_policies_file_system_snapshots_delete_with_http_info(member_ids, member_names, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesApi', 'api20_policies_file_system_snapshots_delete_with_http_info', kwargs)

    def get_policies_file_system_snapshots(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET policies/file-system-snapshots  # noqa: E501
        
        List file system snapshots mapped to a snapshot scheduling policy.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_policies_file_system_snapshots_get_with_http_info(continuation_token, filter, limit, member_ids, member_names, offset, policy_ids, policy_names, sort, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesApi', 'api20_policies_file_system_snapshots_get_with_http_info', kwargs)

    def delete_policies_file_systems(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE policies/file-systems  # noqa: E501
        
        Remove the snapshot scheduling policy mapped to a file system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_policies_file_systems_delete_with_http_info(member_ids, member_names, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesApi', 'api20_policies_file_systems_delete_with_http_info', kwargs)

    def get_policies_file_systems(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET policies/file-systems  # noqa: E501
        
        List file systems mapped to a snapshot scheduling policy.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_policies_file_systems_get_with_http_info(continuation_token, filter, limit, member_ids, member_names, offset, policy_ids, policy_names, sort, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesApi', 'api20_policies_file_systems_get_with_http_info', kwargs)

    def post_policies_file_systems(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST policies/file-systems  # noqa: E501
        
        Map a file system to a snapshot scheduling policy.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_policies_file_systems_post_with_http_info(member_ids, member_names, policy_ids, policy_names, async_req=True)
        >>> result = thread.get()
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesApi', 'api20_policies_file_systems_post_with_http_info', kwargs)

    def get_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET policies  # noqa: E501
        
        Display snapshot scheduling policies and their attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_policies_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('PoliciesApi', 'api20_policies_get_with_http_info', kwargs)

    def get_policies_members(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        member_types: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member types.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        remote_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system IDs. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_names` query parameter.")] = None,
        remote_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_ids` query parameter.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET policies/members  # noqa: E501
        
        List snapshot scheduling policies mapped to file systems, snapshots, and file system replica links.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_policies_members_get_with_http_info(continuation_token, filter, limit, local_file_system_ids, local_file_system_names, member_ids, member_names, member_types, offset, policy_ids, policy_names, remote_file_system_ids, remote_file_system_names, remote_ids, remote_names, sort, async_req=True)
        >>> result = thread.get()
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param remote_file_systems: A list of remote_file_systems to query for. Overrides remote_file_system_ids and remote_file_system_names keyword arguments.
        :type remote_file_systems: ReferenceType or List[ReferenceType], optional
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param member_types: A comma-separated list of member types.
        :type member_types: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_file_system_ids: A comma-separated list of remote file system IDs. If there is not at least one
                                    resource that matches each of the elements, then an error is returned.
                                    This cannot be provided together with the `remote_file_system_names`
                                    query parameter.
        :type remote_file_system_ids: List[str]
        :param remote_file_system_names: A comma-separated list of remote file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with the `remote_file_system_ids` query
                                        parameter.
        :type remote_file_system_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            limit=limit,
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            member_ids=member_ids,
            member_names=member_names,
            member_types=member_types,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            remote_file_system_ids=remote_file_system_ids,
            remote_file_system_names=remote_file_system_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _process_references(remote_file_systems, ['remote_file_system_ids', 'remote_file_system_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['local_file_system_ids', 'local_file_system_names', 'member_ids', 'member_names', 'member_types', 'policy_ids', 'policy_names', 'remote_file_system_ids', 'remote_file_system_names', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('PoliciesApi', 'api20_policies_members_get_with_http_info', kwargs)

    def patch_policies(
        self,
        policy: 'models.PolicyPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        destroy_snapshots: Annotated[Optional[StrictBool], Field(description="This parameter must be set to `true` in order to modify a policy such that local or remote snapshots would be destroyed.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH policies  # noqa: E501
        
        Modify a snapshot scheduling policy’s attributes for when and how often snapshots are created and how long they are retained.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_policies_patch_with_http_info(policy, destroy_snapshots, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param policy: (required)
        :type policy: models.PolicyPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param destroy_snapshots: This parameter must be set to `true` in order to modify a policy such that local
                                or remote snapshots would be destroyed.
        :type destroy_snapshots: bool
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            policy=policy,
            destroy_snapshots=destroy_snapshots,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('PoliciesApi', 'api20_policies_patch_with_http_info', kwargs)

    def post_policies(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policy: Optional['models.Policy'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST policies  # noqa: E501
        
        Create a new snapshot scheduling policy with rule attributes to capture file system snapshots for a set period of time and frequency, as well as how long snapshots are retained before being destroyed and eradicated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_policies_post_with_http_info(names, policy, async_req=True)
        >>> result = thread.get()
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param policy:
        :type policy: Policy
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            policy=policy,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('PoliciesApi', 'api20_policies_post_with_http_info', kwargs)

    def delete_quotas_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        gids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of group IDs. If there is not at least one resource that matches each of the elements of `gids`, then an error is returned. This cannot be provided together with `group_names` query parameter.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group names. If there is not at least one resource that matches each of the elements of `group_names`, then an error is returned. This cannot be provided together with `gids` query parameter.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE quotas/groups  # noqa: E501
        
        Delete a hard limit quota for a group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_quotas_groups_delete_with_http_info(file_system_ids, file_system_names, gids, group_names, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param gids: A comma-separated list of group IDs. If there is not at least one resource that
                    matches each of the elements of `gids`, then an error is returned. This
                    cannot be provided together with `group_names` query parameter.
        :type gids: List[int]
        :param group_names: A comma-separated list of group names. If there is not at least one resource
                            that matches each of the elements of `group_names`, then an error is
                            returned. This cannot be provided together with `gids` query parameter.
        :type group_names: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            gids=gids,
            group_names=group_names,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(groups, ['group_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'gids', 'group_names', 'names'], kwargs)
        return self._call_api('QuotasApi', 'api20_quotas_groups_delete_with_http_info', kwargs)

    def get_quotas_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        gids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of group IDs. If there is not at least one resource that matches each of the elements of `gids`, then an error is returned. This cannot be provided together with `group_names` query parameter.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group names. If there is not at least one resource that matches each of the elements of `group_names`, then an error is returned. This cannot be provided together with `gids` query parameter.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET quotas/groups  # noqa: E501
        
        List groups with hard limit quotas.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_quotas_groups_get_with_http_info(continuation_token, file_system_ids, file_system_names, filter, gids, group_names, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param gids: A comma-separated list of group IDs. If there is not at least one resource that
                    matches each of the elements of `gids`, then an error is returned. This
                    cannot be provided together with `group_names` query parameter.
        :type gids: List[int]
        :param group_names: A comma-separated list of group names. If there is not at least one resource
                            that matches each of the elements of `group_names`, then an error is
                            returned. This cannot be provided together with `gids` query parameter.
        :type group_names: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            filter=filter,
            gids=gids,
            group_names=group_names,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(groups, ['group_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'gids', 'group_names', 'names', 'sort'], kwargs)
        return self._call_api('QuotasApi', 'api20_quotas_groups_get_with_http_info', kwargs)

    def patch_quotas_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        gids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of group IDs. If there is not at least one resource that matches each of the elements of `gids`, then an error is returned. This cannot be provided together with `group_names` query parameter.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group names. If there is not at least one resource that matches each of the elements of `group_names`, then an error is returned. This cannot be provided together with `gids` query parameter.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        quota: Optional['models.GroupQuotaPatch'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH quotas/groups  # noqa: E501
        
        Modify a quota for a group. Note that if you modify a group's quota to a lower value and that group's usage has already exceeded the new value, writes will automatically halt until usage decreases below the new quota setting.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_quotas_groups_patch_with_http_info(file_system_ids, file_system_names, gids, group_names, names, quota, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param gids: A comma-separated list of group IDs. If there is not at least one resource that
                    matches each of the elements of `gids`, then an error is returned. This
                    cannot be provided together with `group_names` query parameter.
        :type gids: List[int]
        :param group_names: A comma-separated list of group names. If there is not at least one resource
                            that matches each of the elements of `group_names`, then an error is
                            returned. This cannot be provided together with `gids` query parameter.
        :type group_names: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param quota:
        :type quota: GroupQuotaPatch
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            gids=gids,
            group_names=group_names,
            names=names,
            quota=quota,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(groups, ['group_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'gids', 'group_names', 'names'], kwargs)
        return self._call_api('QuotasApi', 'api20_quotas_groups_patch_with_http_info', kwargs)

    def post_quotas_groups(
        self,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        gids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of group IDs. If there is not at least one resource that matches each of the elements of `gids`, then an error is returned. This cannot be provided together with `group_names` query parameter.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group names. If there is not at least one resource that matches each of the elements of `group_names`, then an error is returned. This cannot be provided together with `gids` query parameter.")] = None,
        quota: Optional['models.GroupQuotaPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST quotas/groups  # noqa: E501
        
        Create a hard limit quota for a group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_quotas_groups_post_with_http_info(file_system_ids, file_system_names, gids, group_names, quota, async_req=True)
        >>> result = thread.get()
        
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param gids: A comma-separated list of group IDs. If there is not at least one resource that
                    matches each of the elements of `gids`, then an error is returned. This
                    cannot be provided together with `group_names` query parameter.
        :type gids: List[int]
        :param group_names: A comma-separated list of group names. If there is not at least one resource
                            that matches each of the elements of `group_names`, then an error is
                            returned. This cannot be provided together with `gids` query parameter.
        :type group_names: List[str]
        :param quota:
        :type quota: GroupQuotaPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            gids=gids,
            group_names=group_names,
            quota=quota,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(groups, ['group_names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'gids', 'group_names'], kwargs)
        return self._call_api('QuotasApi', 'api20_quotas_groups_post_with_http_info', kwargs)

    def get_quotas_settings(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET quotas-settings  # noqa: E501
        
        List notification attributes of a group or user quota.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_quotas_settings_get_with_http_info(ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('QuotasApi', 'api20_quotas_settings_get_with_http_info', kwargs)

    def patch_quotas_settings(
        self,
        quota_setting: 'models.QuotaSetting',
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH quotas-settings  # noqa: E501
        
        Modify the notification attributes of a group or user quota.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_quotas_settings_patch_with_http_info(quota_setting, async_req=True)
        >>> result = thread.get()
        
        :param quota_setting: (required)
        :type quota_setting: models.QuotaSetting
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            quota_setting=quota_setting,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('QuotasApi', 'api20_quotas_settings_patch_with_http_info', kwargs)

    def delete_quotas_users(
        self,
        users: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        uids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of user IDs. If there is not at least one resource that matches each of the elements of `uids`, then an error is returned. This cannot be provided together with `user_names` query parameter.")] = None,
        user_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of user names. If there is not at least one resource that matches each of the elements of `user_names`, then an error is returned. This cannot be provided together with `uids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE quotas/users  # noqa: E501
        
        Delete a hard limit file system quota for a user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_quotas_users_delete_with_http_info(file_system_ids, file_system_names, names, uids, user_names, async_req=True)
        >>> result = thread.get()
        
        :param users: A list of users to query for. Overrides user_names keyword argument.
        :type users: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param uids: A comma-separated list of user IDs. If there is not at least one resource that
                    matches each of the elements of `uids`, then an error is returned. This
                    cannot be provided together with `user_names` query parameter.
        :type uids: List[int]
        :param user_names: A comma-separated list of user names. If there is not at least one resource that
                        matches each of the elements of `user_names`, then an error is returned.
                        This cannot be provided together with `uids` query parameter.
        :type user_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            names=names,
            uids=uids,
            user_names=user_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _process_references(users, ['user_names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'names', 'uids', 'user_names'], kwargs)
        return self._call_api('QuotasApi', 'api20_quotas_users_delete_with_http_info', kwargs)

    def get_quotas_users(
        self,
        users: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        uids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of user IDs. If there is not at least one resource that matches each of the elements of `uids`, then an error is returned. This cannot be provided together with `user_names` query parameter.")] = None,
        user_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of user names. If there is not at least one resource that matches each of the elements of `user_names`, then an error is returned. This cannot be provided together with `uids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET quotas/users  # noqa: E501
        
        List users with hard limit file system quotas.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_quotas_users_get_with_http_info(continuation_token, file_system_ids, file_system_names, filter, limit, names, offset, sort, uids, user_names, async_req=True)
        >>> result = thread.get()
        
        :param users: A list of users to query for. Overrides user_names keyword argument.
        :type users: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param uids: A comma-separated list of user IDs. If there is not at least one resource that
                    matches each of the elements of `uids`, then an error is returned. This
                    cannot be provided together with `user_names` query parameter.
        :type uids: List[int]
        :param user_names: A comma-separated list of user names. If there is not at least one resource that
                        matches each of the elements of `user_names`, then an error is returned.
                        This cannot be provided together with `uids` query parameter.
        :type user_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            filter=filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            uids=uids,
            user_names=user_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _process_references(users, ['user_names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'names', 'sort', 'uids', 'user_names'], kwargs)
        return self._call_api('QuotasApi', 'api20_quotas_users_get_with_http_info', kwargs)

    def patch_quotas_users(
        self,
        users: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        uids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of user IDs. If there is not at least one resource that matches each of the elements of `uids`, then an error is returned. This cannot be provided together with `user_names` query parameter.")] = None,
        user_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of user names. If there is not at least one resource that matches each of the elements of `user_names`, then an error is returned. This cannot be provided together with `uids` query parameter.")] = None,
        quota: Optional['models.UserQuotaPatch'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH quotas/users  # noqa: E501
        
        Modify the attributes of a hard limit file system quota. Note that if you modify a user's quota to a lower value and that user’s usage has already exceeded the new value, writes will automatically halt until usage decreases below the new quota setting.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_quotas_users_patch_with_http_info(file_system_ids, file_system_names, names, uids, user_names, quota, async_req=True)
        >>> result = thread.get()
        
        :param users: A list of users to query for. Overrides user_names keyword argument.
        :type users: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param uids: A comma-separated list of user IDs. If there is not at least one resource that
                    matches each of the elements of `uids`, then an error is returned. This
                    cannot be provided together with `user_names` query parameter.
        :type uids: List[int]
        :param user_names: A comma-separated list of user names. If there is not at least one resource that
                        matches each of the elements of `user_names`, then an error is returned.
                        This cannot be provided together with `uids` query parameter.
        :type user_names: List[str]
        :param quota:
        :type quota: UserQuotaPatch
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            names=names,
            uids=uids,
            user_names=user_names,
            quota=quota,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _process_references(users, ['user_names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'names', 'uids', 'user_names'], kwargs)
        return self._call_api('QuotasApi', 'api20_quotas_users_patch_with_http_info', kwargs)

    def post_quotas_users(
        self,
        users: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        uids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of user IDs. If there is not at least one resource that matches each of the elements of `uids`, then an error is returned. This cannot be provided together with `user_names` query parameter.")] = None,
        user_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of user names. If there is not at least one resource that matches each of the elements of `user_names`, then an error is returned. This cannot be provided together with `uids` query parameter.")] = None,
        quota: Optional['models.UserQuotaPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST quotas/users  # noqa: E501
        
        Create a hard limit file system quota for a user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_quotas_users_post_with_http_info(file_system_ids, file_system_names, uids, user_names, quota, async_req=True)
        >>> result = thread.get()
        
        :param users: A list of users to query for. Overrides user_names keyword argument.
        :type users: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param uids: A comma-separated list of user IDs. If there is not at least one resource that
                    matches each of the elements of `uids`, then an error is returned. This
                    cannot be provided together with `user_names` query parameter.
        :type uids: List[int]
        :param user_names: A comma-separated list of user names. If there is not at least one resource that
                        matches each of the elements of `user_names`, then an error is returned.
                        This cannot be provided together with `uids` query parameter.
        :type user_names: List[str]
        :param quota:
        :type quota: UserQuotaPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            uids=uids,
            user_names=user_names,
            quota=quota,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(users, ['user_names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'uids', 'user_names'], kwargs)
        return self._call_api('QuotasApi', 'api20_quotas_users_post_with_http_info', kwargs)

    def get_roles(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET roles  # noqa: E501
        
        List roles and permission attributes for role-based access control (RBAC).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_roles_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('RolesApi', 'api20_roles_get_with_http_info', kwargs)

    def get_smtp_servers(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET smtp-servers  # noqa: E501
        
        List SMTP server attributes for the array network.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_smtp_servers_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SMTPApi', 'api20_smtp_servers_get_with_http_info', kwargs)

    def patch_smtp_servers(
        self,
        smtp: 'models.SmtpServer',
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH smtp-servers  # noqa: E501
        
        Modify SMTP server attributes such as the relay host and sender domain.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_smtp_servers_patch_with_http_info(smtp, async_req=True)
        >>> result = thread.get()
        
        :param smtp: (required)
        :type smtp: models.SmtpServer
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            smtp=smtp,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('SMTPApi', 'api20_smtp_servers_patch_with_http_info', kwargs)

    def get_snmp_agents(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET snmp-agents  # noqa: E501
        
        List SNMP agent attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_snmp_agents_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SNMPAgentsApi', 'api20_snmp_agents_get_with_http_info', kwargs)

    def get_snmp_agents_mib(
        self,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET snmp-agents-mib  # noqa: E501
        
        List the SNMP MIB text.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_snmp_agents_mib_get_with_http_info(async_req=True)
        >>> result = thread.get()
        
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('SNMPAgentsApi', 'api20_snmp_agents_mib_get_with_http_info', kwargs)

    def patch_snmp_agents(
        self,
        snmp_agent: 'models.SnmpAgent',
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH snmp-agents  # noqa: E501
        
        Modify SNMP agent attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_snmp_agents_patch_with_http_info(snmp_agent, async_req=True)
        >>> result = thread.get()
        
        :param snmp_agent: (required)
        :type snmp_agent: models.SnmpAgent
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            snmp_agent=snmp_agent,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('SNMPAgentsApi', 'api20_snmp_agents_patch_with_http_info', kwargs)

    def delete_snmp_managers(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE snmp-managers  # noqa: E501
        
        Remove an SNMP manager.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_snmp_managers_delete_with_http_info(ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SNMPManagersApi', 'api20_snmp_managers_delete_with_http_info', kwargs)

    def get_snmp_managers(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET snmp-managers  # noqa: E501
        
        List SNMP managers and their attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_snmp_managers_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SNMPManagersApi', 'api20_snmp_managers_get_with_http_info', kwargs)

    def patch_snmp_managers(
        self,
        snmp_manager: 'models.SnmpManager',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH snmp-managers  # noqa: E501
        
        Modify SNMP manager attributes such as versions.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_snmp_managers_patch_with_http_info(snmp_manager, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param snmp_manager: (required)
        :type snmp_manager: models.SnmpManager
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            snmp_manager=snmp_manager,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SNMPManagersApi', 'api20_snmp_managers_patch_with_http_info', kwargs)

    def post_snmp_managers(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        snmp_manager: 'models.SnmpManagerPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST snmp-managers  # noqa: E501
        
        Create an SNMP manager.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_snmp_managers_post_with_http_info(names, snmp_manager, async_req=True)
        >>> result = thread.get()
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param snmp_manager: (required)
        :type snmp_manager: models.SnmpManagerPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            snmp_manager=snmp_manager,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('SNMPManagersApi', 'api20_snmp_managers_post_with_http_info', kwargs)

    def get_snmp_managers_test(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET snmp-managers/test  # noqa: E501
        
        Test if the configuration of an SNMP manager is valid.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_snmp_managers_test_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SNMPManagersApi', 'api20_snmp_managers_test_get_with_http_info', kwargs)

    def delete_subnets(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE subnets  # noqa: E501
        
        Remove an array subnet.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_subnets_delete_with_http_info(ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SubnetsApi', 'api20_subnets_delete_with_http_info', kwargs)

    def get_subnets(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET subnets  # noqa: E501
        
        List the array’s subnets.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_subnets_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SubnetsApi', 'api20_subnets_get_with_http_info', kwargs)

    def patch_subnets(
        self,
        subnet: 'models.Subnet',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH subnets  # noqa: E501
        
        Modify array subnet attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_subnets_patch_with_http_info(subnet, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param subnet: (required)
        :type subnet: models.Subnet
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            subnet=subnet,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SubnetsApi', 'api20_subnets_patch_with_http_info', kwargs)

    def post_subnets(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        subnet: 'models.Subnet',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST subnets  # noqa: E501
        
        Create an array subnet.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_subnets_post_with_http_info(names, subnet, async_req=True)
        >>> result = thread.get()
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param subnet: (required)
        :type subnet: models.Subnet
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            subnet=subnet,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('SubnetsApi', 'api20_subnets_post_with_http_info', kwargs)

    def get_support(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET support  # noqa: E501
        
        List Phone Home and Remote Assistance settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_support_get_with_http_info(ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SupportApi', 'api20_support_get_with_http_info', kwargs)

    def patch_support(
        self,
        support: 'models.Support',
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH support  # noqa: E501
        
        Modify Phone Home and Remote Assistance settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_support_patch_with_http_info(support, async_req=True)
        >>> result = thread.get()
        
        :param support: (required)
        :type support: models.Support
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            support=support,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('SupportApi', 'api20_support_patch_with_http_info', kwargs)

    def get_support_test(
        self,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        test_type: Annotated[Optional[StrictStr], Field(description="Specify the type of test. Valid values are `all`, `phonehome` and `remote-assist`. If not specified, defaults to `all`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET support-test  # noqa: E501
        
        Test if the Phone Home and Remote Assistance settings are functioning properly.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_support_test_get_with_http_info(filter, sort, test_type, async_req=True)
        >>> result = thread.get()
        
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param test_type: Specify the type of test. Valid values are `all`, `phonehome` and `remote-
                        assist`. If not specified, defaults to `all`.
        :type test_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            filter=filter,
            sort=sort,
            test_type=test_type,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('SupportApi', 'api20_support_test_get_with_http_info', kwargs)

    def delete_syslog_servers(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE syslog-servers  # noqa: E501
        
        Delete a configured syslog server and stop forwarding syslog messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_syslog_servers_delete_with_http_info(ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SyslogApi', 'api20_syslog_servers_delete_with_http_info', kwargs)

    def get_syslog_servers(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET syslog-servers  # noqa: E501
        
        Return a list of configured syslog servers.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_syslog_servers_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SyslogApi', 'api20_syslog_servers_get_with_http_info', kwargs)

    def patch_syslog_servers(
        self,
        syslog_server: 'models.SyslogServerPostOrPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH syslog-servers  # noqa: E501
        
        Modify the URI of a configured syslog server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_syslog_servers_patch_with_http_info(syslog_server, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param syslog_server: (required)
        :type syslog_server: models.SyslogServerPostOrPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            syslog_server=syslog_server,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SyslogApi', 'api20_syslog_servers_patch_with_http_info', kwargs)

    def post_syslog_servers(
        self,
        syslog_server: 'models.SyslogServerPostOrPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST syslog-servers  # noqa: E501
        
        Configure a new syslog server. Transmission of syslog messages is enabled immediately.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_syslog_servers_post_with_http_info(syslog_server, names, async_req=True)
        >>> result = thread.get()
        
        :param syslog_server: (required)
        :type syslog_server: models.SyslogServerPostOrPatch
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            syslog_server=syslog_server,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('SyslogApi', 'api20_syslog_servers_post_with_http_info', kwargs)

    def get_syslog_servers_settings(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET syslog-servers/settings  # noqa: E501
        
        List the certificate or certificate group associated with the syslog servers.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_syslog_servers_settings_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SyslogApi', 'api20_syslog_servers_settings_get_with_http_info', kwargs)

    def patch_syslog_servers_settings(
        self,
        syslog_server_settings: 'models.SyslogServerSettings',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH syslog-servers/settings  # noqa: E501
        
        Modify the certificate or certificate group associated with the syslog servers.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_syslog_servers_settings_patch_with_http_info(syslog_server_settings, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param syslog_server_settings: (required)
        :type syslog_server_settings: models.SyslogServerSettings
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            syslog_server_settings=syslog_server_settings,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SyslogApi', 'api20_syslog_servers_settings_patch_with_http_info', kwargs)

    def get_syslog_servers_test(
        self,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET syslog-servers/test  # noqa: E501
        
        Send test messages to conifgured remote syslog servers.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_syslog_servers_test_get_with_http_info(continuation_token, async_req=True)
        >>> result = thread.get()
        
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _fixup_list_type_params([], kwargs)
        return self._call_api('SyslogApi', 'api20_syslog_servers_test_get_with_http_info', kwargs)

    def delete_targets(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE targets  # noqa: E501
        
        Delete the connection to the target for replication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_targets_delete_with_http_info(ids, names, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('TargetsApi', 'api20_targets_delete_with_http_info', kwargs)

    def get_targets(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET targets  # noqa: E501
        
        List targets used for replication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_targets_get_with_http_info(continuation_token, filter, ids, limit, names, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('TargetsApi', 'api20_targets_get_with_http_info', kwargs)

    def patch_targets(
        self,
        target: 'models.Target',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH targets  # noqa: E501
        
        Modify the target attributes for replication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_targets_patch_with_http_info(target, ids, names, async_req=True)
        >>> result = thread.get()
        
        :param target: (required)
        :type target: models.Target
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            target=target,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('TargetsApi', 'api20_targets_patch_with_http_info', kwargs)

    def get_targets_performance_replication(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET targets/performance/replication  # noqa: E501
        
        List replication performance metrics for targets.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_targets_performance_replication_get_with_http_info(continuation_token, end_time, filter, ids, limit, names, offset, resolution, sort, start_time, total_only, async_req=True)
        >>> result = thread.get()
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            end_time=end_time,
            filter=filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('TargetsApi', 'api20_targets_performance_replication_get_with_http_info', kwargs)

    def post_targets(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        target: 'models.TargetPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST targets  # noqa: E501
        
        Add a target for replication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_targets_post_with_http_info(names, target, async_req=True)
        >>> result = thread.get()
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param target: (required)
        :type target: models.TargetPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            target=target,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('TargetsApi', 'api20_targets_post_with_http_info', kwargs)

    def get_usage_groups(
        self,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        gids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of group IDs. If there is not at least one resource that matches each of the elements of `gids`, then an error is returned. This cannot be provided together with `group_names` query parameter.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group names. If there is not at least one resource that matches each of the elements of `group_names`, then an error is returned. This cannot be provided together with `gids` query parameter.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET usage/groups  # noqa: E501
        
        List groups with hard limit quotas and their file system usage.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_usage_groups_get_with_http_info(continuation_token, file_system_ids, file_system_names, filter, gids, group_names, limit, offset, sort, async_req=True)
        >>> result = thread.get()
        
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param gids: A comma-separated list of group IDs. If there is not at least one resource that
                    matches each of the elements of `gids`, then an error is returned. This
                    cannot be provided together with `group_names` query parameter.
        :type gids: List[int]
        :param group_names: A comma-separated list of group names. If there is not at least one resource
                            that matches each of the elements of `group_names`, then an error is
                            returned. This cannot be provided together with `gids` query parameter.
        :type group_names: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            filter=filter,
            gids=gids,
            group_names=group_names,
            limit=limit,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(groups, ['group_names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'gids', 'group_names', 'sort'], kwargs)
        return self._call_api('UsageApi', 'api20_usage_groups_get_with_http_info', kwargs)

    def get_usage_users(
        self,
        users: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        uids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of user IDs. If there is not at least one resource that matches each of the elements of `uids`, then an error is returned. This cannot be provided together with `user_names` query parameter.")] = None,
        user_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of user names. If there is not at least one resource that matches each of the elements of `user_names`, then an error is returned. This cannot be provided together with `uids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET usage/users  # noqa: E501
        
        List users with hard limit quotas and their file system usage.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        
        >>> thread = api.api20_usage_users_get_with_http_info(continuation_token, file_system_ids, file_system_names, filter, limit, offset, sort, uids, user_names, async_req=True)
        >>> result = thread.get()
        
        :param users: A list of users to query for. Overrides user_names keyword argument.
        :type users: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param uids: A comma-separated list of user IDs. If there is not at least one resource that
                    matches each of the elements of `uids`, then an error is returned. This
                    cannot be provided together with `user_names` query parameter.
        :type uids: List[int]
        :param user_names: A comma-separated list of user names. If there is not at least one resource that
                        matches each of the elements of `user_names`, then an error is returned.
                        This cannot be provided together with `uids` query parameter.
        :type user_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :returns ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        
        :raises PureError: If calling the API fails.
        :raises ValueError: If a parameter is of an invalid type.
        :raises TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            continuation_token=continuation_token,
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            filter=filter,
            limit=limit,
            offset=offset,
            sort=sort,
            uids=uids,
            user_names=user_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(users, ['user_names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'sort', 'uids', 'user_names'], kwargs)
        return self._call_api('UsageApi', 'api20_usage_users_get_with_http_info', kwargs)

    def get_versions(
        self,
        async_req=False,  # type: bool
        _return_http_data_only=False,  # type: bool
        _preload_content=True,  # type: bool
        _request_timeout=None,  # type: Optional[int]
    ):
        # type: (...) -> dict
        """
        Get available API versions. No authentication is required to access this
        endpoint.  The response will be a ValidResponse with version ids listed as items.

        Args:

            async_req (bool, optional):
                Request runs in separate thread and method returns
                multiprocessing.pool.ApplyResult.
            _return_http_data_only (bool, optional):
                Returns only data field.
            _preload_content (bool, optional):
                Response is converted into objects.
            _request_timeout (int, optional):
                Total request timeout in seconds.

        Returns:
            ValidResponse: If the call was successful.
            ErrorResponse: If the call was not successful.

        Raises:
            PureError: If calling the API fails.
            ValueError: If a parameter is of an invalid type.
            TypeError: If invalid or missing parameters are used.
        """
        kwargs = dict(
            async_req=async_req,
            _return_http_data_only=_return_http_data_only,
            _preload_content=_preload_content,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        return self._call_api('AuthorizationApi', 'api_api_version_get_with_http_info', kwargs, response_creator=self._create_api_versions_response)

    def logout(
        self,
        async_req=False,  # type: bool
        _return_http_data_only=False,  # type: bool
        _preload_content=True,  # type: bool
        _request_timeout=None,  # type: Optional[int]
    ):
        # type: (...) -> None
        """
        Invalidate a REST session token.

        Args:

            async_req (bool, optional):
                Request runs in separate thread and method returns
                multiprocessing.pool.ApplyResult.
            _return_http_data_only (bool, optional):
                Returns only data field.
            _preload_content (bool, optional):
                Response is converted into objects.
            _request_timeout (int, optional):
                Total request timeout in seconds.

        Returns:
            ValidResponse: If the call was successful.
            ErrorResponse: If the call was not successful.

        Raises:
            PureError: If calling the API fails.
            ValueError: If a parameter is of an invalid type.
            TypeError: If invalid or missing parameters are used.
        """
        kwargs = dict(
            async_req=async_req,
            _return_http_data_only=_return_http_data_only,
            _preload_content=_preload_content,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        res = self._call_api('AuthorizationApi', 'api_logout_post_with_http_info', kwargs, response_creator=self._create_logout_response)
        # Note: The normal behavior when a call returns a 401 or 403 authentication error status
        # is to reset the authentication token and retry. This effectively logs the client in again.
        # Setting _retries to 0 prevents this behavior for any future calls with this client.
        self._retries = 0
        return res


    def _get_base_url(self, target):
        return 'https://{}'.format(target)

    def _get_api_token_endpoint(self, target):
        return self._get_base_url(target) + '/api/login'

    def _get_api_token_dispose_endpoint(self, target):
        return self._get_base_url(target) + '/api/logout'

    def _set_agent_header(self):
        """
        Set the user-agent header of the internal client.
        """
        self._api_client.set_default_header(Headers.user_agent, self._api_client.user_agent)

    def _set_auth_header(self, refresh=False):
        """
        Set the authorization or x-auth-token header of the internal client with the access
        token.

        Args:
            refresh (bool, optional): Whether to retrieve a new access token.
                Defaults to False.

        Raises:
            PureError: If there was an error retrieving the access token.
        """
        if isinstance(self._token_man, TokenManager):
            self._api_client.set_default_header(Headers.authorization,
                                                self._token_man.get_header(refresh=refresh))
        else:
            self._api_client.set_default_header(Headers.x_auth_token,
                                                self._token_man.get_session_token(refresh=refresh))

    def _call_api(self, api_class_name, api_function_name, kwargs, response_creator=None):
        """
        Call the API function and process the response. May call the API
        repeatedly if the request failed for a reason that may not persist in
        the next call.

        Args:
            api_function (function): Swagger-generated function to call.
            kwargs (dict): kwargs to pass to the function.
            response_creator: optional method to generate a ValidResponse from a non-standard endpoint.
                              If None, use the standard _create_valid_response method.

        Returns:
            ValidResponse: If the call was successful.
            ErrorResponse: If the call was not successful.

        Raises:
            PureError: If calling the API fails.
            ValueError: If a parameter is of an invalid type.
            TypeError: If invalid or missing parameters are used.
        """
        kwargs['_request_timeout'] = self._timeout
        if kwargs.get('x_request_id') is None:
            kwargs['x_request_id'] = str(uuid.uuid4())

        if kwargs.get('authorization') is not None:
            warnings.warn("authorization parameter is deprecated, and will be removed soon.", DeprecationWarning)

        retries = self._retries
        api_function = getattr(self.__get_api_instance(api_class_name), api_function_name)
        while True:
            try:
                response = api_function(**kwargs)
                # Call was successful (200)
                if response_creator:
                    return response_creator(response, api_function, kwargs)
                else:
                    return self._create_valid_response(response, api_function, kwargs)
            except ApiException as error:
                # If no chance for retries, return the error
                if retries == 0:
                    return self._create_error_response(error)
                # If bad request or not found, return the error (it will never work)
                elif error.status in [400, 404]:
                    return self._create_error_response(error)
                # If authentication error, reset access token and retry
                elif error.status in [401, 403]:
                    self._set_auth_header(refresh=True)
                # If rate limit error, wait the proper time and try again
                elif error.status == 429:
                    # If the the minute limit hit, wait that long
                    if (int(error.headers.get(Headers.x_ratelimit_remaining_min))
                            == int(error.headers.get(Headers.x_ratelimit_min))):
                        time.sleep(60)
                    # Otherwise it was the second limit and only wait a second
                    time.sleep(1)
                # If some internal server error we know nothing about, return
                elif error.status == 500:
                    return self._create_error_response(error)
                # If internal server errors that has to do with timeouts, try again
                elif error.status > 500:
                    pass
                # If error with the swagger client, raise the error
                else:
                    raise PureError(error)
            retries = retries - 1

    def __get_api_instance(self, api_class):
        """
        Get the API instance for the given class.

        Args:
            api_class (class): Swagger-generated api class.

        Returns:
            class: API instance for the given class.
        """
        if api_class not in self.__apis_instances:
            self.__apis_instances[api_class] = getattr(api, api_class)(self._api_client)
        return self.__apis_instances[api_class]

    def _create_valid_response(self, response: ApiResponse, endpoint, kwargs):
        """
        Create a ValidResponse from a Swagger response.

        Args:
            response ApiResponse:
                Body, status, header tuple as returned from Swagger client.
            endpoint (function):
                The function of the Swagger client that was called.
            kwargs (dict):
                The processed kwargs that were passed to the endpoint function.

        Returns:
            ValidResponse
        """
        body = response.data
        headers = response.headers

        continuation_token = getattr(body, "continuation_token", None)
        total_item_count = getattr(body, "total_item_count", None)
        total = getattr(body, "total", None)
        more_items_remaining = getattr(body, "more_items_remaining", None)
        items = None

        if body is not None:
            # if body is a file then should be a singleton list
            body_items = [body] if type(body) == str else body.items
            items = iter(ItemIterator(self, endpoint, kwargs,
                                      continuation_token, total_item_count,
                                      body_items,
                                      headers.get(Headers.x_request_id, None),
                                      more_items_remaining or False))
        return ValidResponse(response.status_code, continuation_token, total_item_count,
                             items, headers, total, more_items_remaining)


    def _create_api_versions_response(self, response: ApiResponse, endpoint, kwargs):
        """
        Create a ValidResponse from an ApiVersion Swagger response.

        Args:
            response ApiResponse:
                Body, status, header tuple as returned from Swagger client.
            endpoint (function):
                The function of the Swagger client that was called.
            kwargs (dict):
                The processed kwargs that were passed to the endpoint function.

        Returns:
            ValidResponse
        """
        body = response.data
        headers = response.headers

        continuation_token = None
        total_item_count = None
        total = None
        more_items_remaining = None
        items = None

        if body is not None:
            # if body is a file then should be a singleton list
            body_items = [body] if type(body) == str else body.versions
            items = iter(ItemIterator(self, endpoint, kwargs,
                                      continuation_token, total_item_count,
                                      body_items,
                                      headers.get(Headers.x_request_id, None),
                                      more_items_remaining or False))
        response = ValidResponse(response.status_code, continuation_token, total_item_count,
                                 items, headers, total, more_items_remaining)
        return response


    def _create_logout_response(self, response: ApiResponse, endpoint, kwargs):
        """
           A logout response only contains the status field.
        """
        headers = response.headers

        continuation_token = None
        total_item_count = None
        total = None
        more_items_remaining = None
        items = None
        return ValidResponse(response.status_code, continuation_token, total_item_count,
                             items, headers, total, more_items_remaining)


    def _create_error_response(self, error):
        """
        Create an ErrorResponse from a Swagger error.

        Args:
            error (ApiException):
                Error returned by Swagger client.

        Returns:
            ErrorResponse
        """
        status = error.status
        try:
            body = json.loads(error.body)
        except Exception:
            body = {}
        if status in [403, 429]:
            # Parse differently if the error message came from kong
            errors = [ApiError(None, body.get(Responses.message, None))]
        else:
            errors = [ApiError(err.get(Responses.context, None),
                               err.get(Responses.message, None))
                      for err in body.get(Responses.errors, {})]
        return ErrorResponse(status, errors, headers=error.headers)


def _process_references(
    references: Optional[Union[ReferenceType, List[ReferenceType]]],
    params: List[str],
    kwargs: Dict[str, Any]
) -> None:

    """Process reference objects into a list of ids or names.
    Removes ids and names arguments.

    :param references: The references from which to extract ids or names.
    :type references: ReferenceType or List[ReferenceType], optional

    :param params: The parameters to be overridden.
    :type params: List[str]

    :param kwargs: The kwargs to process.
    :type kwargs: Dict[str, Any]

    :raise PureError: If a reference does not have an id or name.

    """
    if references is not None:
        if not isinstance(references, list):
            references = [references]
        for param in params:
            kwargs.pop(param, None)
        all_have_id = all(ref.id is not None for ref in references)
        all_have_name = all(ref.name is not None for ref in references)
        id_param = [param for param in params if param.endswith("ids")]
        name_param = [param for param in params if param.endswith("names")]
        if all_have_id and len(id_param) > 0:
            kwargs[id_param[0]] = [ref.id for ref in references]
        elif all_have_name and len(name_param) > 0:
            kwargs[name_param[0]] = [ref.name for ref in references]
        else:
            raise PureError('Invalid reference for {}'.format(", ".join(params)))


def _fixup_list_type_params(
    params: List[str],
    kwargs: Dict[str, Any]
) -> None:

    """Process object into a list if it expected to be list type.

    :param params: The parameters to be overridden.
    :type params: List[str]

    :param kwargs: The kwargs to process.
    :type kwargs: Dict[str, Any]

    """
    for _param in params:
        _value = kwargs.get(_param, None)
        if _value is not None and not isinstance(_value, list):
            _param_type = type(_value).__name__.replace("'", '')
            warnings.warn(f"'{_param}' parameter, invalid type: expected List[{_param_type}] but received {_param_type}, converting to list. Please revisit code.", SyntaxWarning)
            kwargs[_param] = [_value]

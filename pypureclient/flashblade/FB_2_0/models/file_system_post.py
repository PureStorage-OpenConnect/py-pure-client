# coding: utf-8

"""
    FlashBlade REST API Client

    A lightweight client for FlashBlade REST API 2.0, developed by Pure Storage, Inc. (http://www.purestorage.com/).

    The version of the OpenAPI document: 2.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from pypureclient.flashblade.FB_2_0.models.http import Http
from pypureclient.flashblade.FB_2_0.models.multi_protocol_post import MultiProtocolPost
from pypureclient.flashblade.FB_2_0.models.nfs import Nfs
from pypureclient.flashblade.FB_2_0.models.reference import Reference
from pypureclient.flashblade.FB_2_0.models.smb import Smb
from typing import Optional, Set
from typing_extensions import Self

class FileSystemPost(BaseModel):
    """
    FileSystemPost
    """ # noqa: E501
    default_group_quota: Optional[StrictInt] = Field(default=None, description="The default space quota for a group writing to this file system.")
    default_user_quota: Optional[StrictInt] = Field(default=None, description="The default space quota for a user writing to this file system.")
    fast_remove_directory_enabled: Optional[StrictBool] = Field(default=None, description="If set to `true`, the file system, when mounted, will contain a directory that can be used for fast removal of other directories. Directories can be moved into the fast remove directory in order to have them deleted, and their space freed, more quickly than a normal removal operation. If not specified, defaults to `false`.")
    hard_limit_enabled: Optional[StrictBool] = Field(default=None, description="If set to `true`, the file system's size, as defined by `provisioned`, is used as a hard limit quota. If not specified, defaults to `false`.")
    http: Optional[Http] = Field(default=None, description="HTTP configuration.")
    multi_protocol: Optional[MultiProtocolPost] = Field(default=None, description="Multi-protocol configuration.")
    nfs: Optional[Nfs] = Field(default=None, description="NFS configuration.")
    provisioned: Optional[StrictInt] = Field(default=None, description="The provisioned size of the file system, displayed in bytes. If set to an empty string (`\"\"`), the file system is unlimited in size. If not specified, defaults to unlimited.")
    requested_promotion_state: Optional[StrictStr] = Field(default=None, description="Possible values are `promoted` and `demoted`. The `demoted` state is used for replication targets and is only allowed to be set if the file system is in a replica-link relationship. The additional query param `discard-non-snapshotted-data` must be set to `true` when demoting a file system. The default for new file systems is `promoted`.")
    smb: Optional[Smb] = Field(default=None, description="SMB configuration.")
    snapshot_directory_enabled: Optional[StrictBool] = Field(default=None, description="If set to `true`, a hidden .snapshot directory will be present in each directory of the file system when it is mounted. The .snapshot directory allows clients read access to the contents of the snapshots that have been taken of a directory. If set to `false`, the .snapshot directory will not be present in any directories within a mounted file system. If not specified, defaults to `true`.")
    source: Optional[Reference] = Field(default=None, description="The source snapshot whose data is copied to the file system specified.")
    writable: Optional[StrictBool] = Field(default=None, description="Whether the file system is writable or not. If `false`, this overrides any protocol or file permission settings and prevents changes. If `true`, then the protocol and file permission settings are evaluated. If not specified, defaults to `true`. Modifiable.")
    __properties: ClassVar[List[str]] = ["default_group_quota", "default_user_quota", "fast_remove_directory_enabled", "hard_limit_enabled", "http", "multi_protocol", "nfs", "provisioned", "requested_promotion_state", "smb", "snapshot_directory_enabled", "source", "writable"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    def to_dict(self, include_readonly: bool = False) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.

        * OpenAPI `readOnly` fields are excluded, if `include_readonly` is `False`.
        """
        excluded_fields: Set[str] = set([
            "requested_promotion_state",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=set() if include_readonly else excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of http
        if self.http and (include_readonly or "http" not in excluded_fields):
            _dict['http'] = self.http.to_dict()
        # override the default output from pydantic by calling `to_dict()` of multi_protocol
        if self.multi_protocol and (include_readonly or "multi_protocol" not in excluded_fields):
            _dict['multi_protocol'] = self.multi_protocol.to_dict()
        # override the default output from pydantic by calling `to_dict()` of nfs
        if self.nfs and (include_readonly or "nfs" not in excluded_fields):
            _dict['nfs'] = self.nfs.to_dict()
        # override the default output from pydantic by calling `to_dict()` of smb
        if self.smb and (include_readonly or "smb" not in excluded_fields):
            _dict['smb'] = self.smb.to_dict()
        # override the default output from pydantic by calling `to_dict()` of source
        if self.source and (include_readonly or "source" not in excluded_fields):
            _dict['source'] = self.source.to_dict()
        return _dict

    def __getitem__(self, key):
        return getattr(self, key)

    def __setitem__(self, key, value):
        setattr(self, key, value)

    def __delitem__(self, key):
        setattr(self, key, None)

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of FileSystemPost from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of FileSystemPost from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_construct(_fields_set=None, **{
            "default_group_quota": obj.get("default_group_quota"),
            "default_user_quota": obj.get("default_user_quota"),
            "fast_remove_directory_enabled": obj.get("fast_remove_directory_enabled"),
            "hard_limit_enabled": obj.get("hard_limit_enabled"),
            "http": Http.from_dict(obj["http"]) if obj.get("http") is not None else None,
            "multi_protocol": MultiProtocolPost.from_dict(obj["multi_protocol"]) if obj.get("multi_protocol") is not None else None,
            "nfs": Nfs.from_dict(obj["nfs"]) if obj.get("nfs") is not None else None,
            "provisioned": obj.get("provisioned"),
            "requested_promotion_state": obj.get("requested_promotion_state"),
            "smb": Smb.from_dict(obj["smb"]) if obj.get("smb") is not None else None,
            "snapshot_directory_enabled": obj.get("snapshot_directory_enabled"),
            "source": Reference.from_dict(obj["source"]) if obj.get("source") is not None else None,
            "writable": obj.get("writable")
        })
        return _obj



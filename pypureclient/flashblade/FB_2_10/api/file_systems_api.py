# coding: utf-8

"""
    FlashBlade REST API

    A lightweight client for FlashBlade REST API 2.10, developed by Pure Storage, Inc. (http://www.purestorage.com/).

    The version of the OpenAPI document: 2.10
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Union
from typing_extensions import Annotated
from pypureclient.flashblade.FB_2_10.models.file_lock_get_response import FileLockGetResponse
from pypureclient.flashblade.FB_2_10.models.file_lock_nlm_reclamation_response import FileLockNlmReclamationResponse
from pypureclient.flashblade.FB_2_10.models.file_session_get_response import FileSessionGetResponse
from pypureclient.flashblade.FB_2_10.models.file_system_clients_get_response import FileSystemClientsGetResponse
from pypureclient.flashblade.FB_2_10.models.file_system_get_response import FileSystemGetResponse
from pypureclient.flashblade.FB_2_10.models.file_system_groups_performance_get_response import FileSystemGroupsPerformanceGetResponse
from pypureclient.flashblade.FB_2_10.models.file_system_patch import FileSystemPatch
from pypureclient.flashblade.FB_2_10.models.file_system_performance_get_response import FileSystemPerformanceGetResponse
from pypureclient.flashblade.FB_2_10.models.file_system_post import FileSystemPost
from pypureclient.flashblade.FB_2_10.models.file_system_response import FileSystemResponse
from pypureclient.flashblade.FB_2_10.models.file_system_users_performance_get_response import FileSystemUsersPerformanceGetResponse
from pypureclient.flashblade.FB_2_10.models.policy_member_get_response import PolicyMemberGetResponse
from pypureclient.flashblade.FB_2_10.models.policy_member_response import PolicyMemberResponse
from pypureclient.flashblade.FB_2_10.api_client import ApiClient as _TransportApiClient, RequestSerialized
from pypureclient.flashblade.FB_2_10.api_response import ApiResponse
from pypureclient.flashblade.FB_2_10.rest import RESTResponseType


class FileSystemsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client: Optional[_TransportApiClient] = None) -> None:
        self.api_client = api_client if api_client else _TransportApiClient.get_default()


    @validate_call
    def api210_file_systems_delete_with_http_info(
        self,
        ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[None]:
        """DELETE file-systems

        Deletes a file system. Deleting a file system is equivalent to eradication. A file system's `destroyed` parameter must be set to `true` before a file system can be deleted.

        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api210_file_systems_delete_serialize(
            ids = ids,
            names = names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api210_file_systems_delete_serialize(
        self,
        ids,
        names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
            'names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if names is not None:
            
            _query_params.append(('names', names))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/2.10/file-systems',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api210_file_systems_get_with_http_info(
        self,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. If not set, lists both objects that are destroyed and those that are not destroyed. If object name(s) are specified in the `names` parameter, then each object referenced must exist. If `destroyed` is set to `true`, then each object referenced must also be destroyed. If `destroyed` is set to `false`, then each object referenced must also not be destroyed. An error is returned if any of these conditions are not met.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[FileSystemGetResponse]:
        """GET file-systems

        List one or more file systems on the array.

        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. If not set, lists both objects that are destroyed and those that are not destroyed. If object name(s) are specified in the `names` parameter, then each object referenced must exist. If `destroyed` is set to `true`, then each object referenced must also be destroyed. If `destroyed` is set to `false`, then each object referenced must also not be destroyed. An error is returned if any of these conditions are not met.
        :type destroyed: bool
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api210_file_systems_get_serialize(
            continuation_token = continuation_token,
            destroyed = destroyed,
            filter = filter,
            ids = ids,
            limit = limit,
            names = names,
            offset = offset,
            sort = sort,
            total_only = total_only,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileSystemGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api210_file_systems_get_serialize(
        self,
        continuation_token,
        destroyed,
        filter,
        ids,
        limit,
        names,
        offset,
        sort,
        total_only,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
            'names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if destroyed is not None:
            
            _query_params.append(('destroyed', destroyed))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if names is not None:
            
            _query_params.append(('names', names))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if total_only is not None:
            
            _query_params.append(('total_only', total_only))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.10/file-systems',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api210_file_systems_groups_performance_get_with_http_info(
        self,
        file_system_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        gids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of group IDs. This cannot be provided together with `group_names` query parameter.")] = None,
        group_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of group names. This cannot be provided together with `gids` query parameter.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[FileSystemGroupsPerformanceGetResponse]:
        """GET file-systems/groups/performance

        List a group’s I/O performance metrics on a file system.

        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.
        :type file_system_names: List[str]
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param gids: A comma-separated list of group IDs. This cannot be provided together with `group_names` query parameter.
        :type gids: List[str]
        :param group_names: A comma-separated list of group names. This cannot be provided together with `gids` query parameter.
        :type group_names: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api210_file_systems_groups_performance_get_serialize(
            file_system_ids = file_system_ids,
            file_system_names = file_system_names,
            filter = filter,
            gids = gids,
            group_names = group_names,
            limit = limit,
            names = names,
            sort = sort,
            total_only = total_only,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileSystemGroupsPerformanceGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api210_file_systems_groups_performance_get_serialize(
        self,
        file_system_ids,
        file_system_names,
        filter,
        gids,
        group_names,
        limit,
        names,
        sort,
        total_only,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'file_system_ids': 'csv',
            'file_system_names': 'csv',
            'gids': 'csv',
            'group_names': 'csv',
            'names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if file_system_ids is not None:
            
            _query_params.append(('file_system_ids', file_system_ids))
            
        if file_system_names is not None:
            
            _query_params.append(('file_system_names', file_system_names))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if gids is not None:
            
            _query_params.append(('gids', gids))
            
        if group_names is not None:
            
            _query_params.append(('group_names', group_names))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if names is not None:
            
            _query_params.append(('names', names))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if total_only is not None:
            
            _query_params.append(('total_only', total_only))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.10/file-systems/groups/performance',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api210_file_systems_locks_clients_get_with_http_info(
        self,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[FileSystemClientsGetResponse]:
        """Get a list of clients that hold active file locks

        Lists all clients that hold active file locks.

        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api210_file_systems_locks_clients_get_serialize(
            continuation_token = continuation_token,
            filter = filter,
            limit = limit,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileSystemClientsGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api210_file_systems_locks_clients_get_serialize(
        self,
        continuation_token,
        filter,
        limit,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.10/file-systems/locks/clients',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api210_file_systems_locks_delete_with_http_info(
        self,
        client_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of ip addresses of clients. For IPv6 both the extended format (x:x:x:x:x:x:x:x) and the shortened format are supported.")] = None,
        file_system_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        inodes: Annotated[Optional[List[Union[StrictFloat, StrictInt]]], Field(description="A comma-separated list of inodes used for filtering file locks query by inodes. This may only be specified if `file_system_ids` or `file_system_names` is also specified. This cannot be provided together with the `paths` query parameter.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        paths: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of paths used for filtering file locks query by paths. This may only be specified if `file_system_ids` or `file_system_names` is also specified. This cannot be provided together with the `inodes` query parameter.")] = None,
        recursive: Annotated[Optional[StrictBool], Field(description="Flag used to indicate that the action should be done recursively. If set to `true` and used e.g. with `path` pointing to a directory, the operation will delete all locks in given directory and subdirectories recursively. For more fine grained control over deleted locks, use delete by name. If not specified, defaults to `false`.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[None]:
        """Invalidate file locks

        Invalidates file locks. It can be used to either delete an individual lock by name or multiple locks filtered by parameters. E.g. to delete locks held by a client on specific file, parameters `client_names`, `file_system_ids` or `file_system_names` and `path` must be specified. When `names` is specified, no other query parameter can be specified.

        :param client_names: A comma-separated list of ip addresses of clients. For IPv6 both the extended format (x:x:x:x:x:x:x:x) and the shortened format are supported.
        :type client_names: List[str]
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.
        :type file_system_names: List[str]
        :param inodes: A comma-separated list of inodes used for filtering file locks query by inodes. This may only be specified if `file_system_ids` or `file_system_names` is also specified. This cannot be provided together with the `paths` query parameter.
        :type inodes: List[float]
        :param names: A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param paths: A comma-separated list of paths used for filtering file locks query by paths. This may only be specified if `file_system_ids` or `file_system_names` is also specified. This cannot be provided together with the `inodes` query parameter.
        :type paths: List[str]
        :param recursive: Flag used to indicate that the action should be done recursively. If set to `true` and used e.g. with `path` pointing to a directory, the operation will delete all locks in given directory and subdirectories recursively. For more fine grained control over deleted locks, use delete by name. If not specified, defaults to `false`.
        :type recursive: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api210_file_systems_locks_delete_serialize(
            client_names = client_names,
            file_system_ids = file_system_ids,
            file_system_names = file_system_names,
            inodes = inodes,
            names = names,
            paths = paths,
            recursive = recursive,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api210_file_systems_locks_delete_serialize(
        self,
        client_names,
        file_system_ids,
        file_system_names,
        inodes,
        names,
        paths,
        recursive,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'client_names': 'csv',
            'file_system_ids': 'csv',
            'file_system_names': 'csv',
            'inodes': 'csv',
            'names': 'csv',
            'paths': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if client_names is not None:
            
            _query_params.append(('client_names', client_names))
            
        if file_system_ids is not None:
            
            _query_params.append(('file_system_ids', file_system_ids))
            
        if file_system_names is not None:
            
            _query_params.append(('file_system_names', file_system_names))
            
        if inodes is not None:
            
            _query_params.append(('inodes', inodes))
            
        if names is not None:
            
            _query_params.append(('names', names))
            
        if paths is not None:
            
            _query_params.append(('paths', paths))
            
        if recursive is not None:
            
            _query_params.append(('recursive', recursive))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/2.10/file-systems/locks',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api210_file_systems_locks_get_with_http_info(
        self,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        client_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of ip addresses of clients. For IPv6 both the extended format (x:x:x:x:x:x:x:x) and the shortened format are supported.")] = None,
        file_system_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        inodes: Annotated[Optional[List[Union[StrictFloat, StrictInt]]], Field(description="A comma-separated list of inodes used for filtering file locks query by inodes. This may only be specified if `file_system_ids` or `file_system_names` is also specified. This cannot be provided together with the `paths` query parameter.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        paths: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of paths used for filtering file locks query by paths. This may only be specified if `file_system_ids` or `file_system_names` is also specified. This cannot be provided together with the `inodes` query parameter.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[FileLockGetResponse]:
        """Get a list of active file locks

        Lists all active file locks that satisfy the conditions specified by the parameters.

        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param client_names: A comma-separated list of ip addresses of clients. For IPv6 both the extended format (x:x:x:x:x:x:x:x) and the shortened format are supported.
        :type client_names: List[str]
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.
        :type file_system_names: List[str]
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param inodes: A comma-separated list of inodes used for filtering file locks query by inodes. This may only be specified if `file_system_ids` or `file_system_names` is also specified. This cannot be provided together with the `paths` query parameter.
        :type inodes: List[float]
        :param limit: Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param paths: A comma-separated list of paths used for filtering file locks query by paths. This may only be specified if `file_system_ids` or `file_system_names` is also specified. This cannot be provided together with the `inodes` query parameter.
        :type paths: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api210_file_systems_locks_get_serialize(
            continuation_token = continuation_token,
            client_names = client_names,
            file_system_ids = file_system_ids,
            file_system_names = file_system_names,
            filter = filter,
            inodes = inodes,
            limit = limit,
            names = names,
            paths = paths,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileLockGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api210_file_systems_locks_get_serialize(
        self,
        continuation_token,
        client_names,
        file_system_ids,
        file_system_names,
        filter,
        inodes,
        limit,
        names,
        paths,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'client_names': 'csv',
            'file_system_ids': 'csv',
            'file_system_names': 'csv',
            'inodes': 'csv',
            'names': 'csv',
            'paths': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if client_names is not None:
            
            _query_params.append(('client_names', client_names))
            
        if file_system_ids is not None:
            
            _query_params.append(('file_system_ids', file_system_ids))
            
        if file_system_names is not None:
            
            _query_params.append(('file_system_names', file_system_names))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if inodes is not None:
            
            _query_params.append(('inodes', inodes))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if names is not None:
            
            _query_params.append(('names', names))
            
        if paths is not None:
            
            _query_params.append(('paths', paths))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.10/file-systems/locks',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api210_file_systems_locks_nlm_reclamations_post_with_http_info(
        self,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[FileLockNlmReclamationResponse]:
        """Initiate NLM reclamation.

        NLM reclamation is a system-wide operation, affecting all clients, and so only one may be in progress at a time. Attempting to initiate reclamation while one is in progress will result in an error. When NLM reclamation is initiated, all NLM locks are deleted and client applications are notified that they can reacquire their locks within a grace period.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api210_file_systems_locks_nlm_reclamations_post_serialize(
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileLockNlmReclamationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api210_file_systems_locks_nlm_reclamations_post_serialize(
        self,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/2.10/file-systems/locks/nlm-reclamations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api210_file_systems_patch_with_http_info(
        self,
        file_system: FileSystemPatch,
        delete_link_on_eradication: Annotated[Optional[StrictBool], Field(description="If set to `true`, the file system can be destroyed, even if it has a replica link. If set to `false`, the file system cannot be destroyed if it has a replica link. Defaults to `false`.")] = None,
        discard_detailed_permissions: Annotated[Optional[StrictBool], Field(description="This parameter must be set to `true` in order to change a file system's `access_control_style` from a style that supports more detailed access control lists to a style that only supports less detailed mode bits as a form of permission control. This parameter may not be set to `true` any other time. Setting this parameter to `true` is acknowledgement that any more detailed access control lists currently set within the file system will be lost, and NFS permission controls will only be enforced at the granularity level of NFS mode bits.")] = None,
        discard_non_snapshotted_data: Annotated[Optional[StrictBool], Field(description="This parameter must be set to `true` in order to restore a file system from a snapshot or to demote a file system (which restores the file system from the common baseline snapshot). Setting this parameter to `true` is acknowledgement that any non-snapshotted data currently in the file system will be irretrievably lost.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        ignore_usage: Annotated[Optional[StrictBool], Field(description="Allow update operations that lead to a `hard_limit_enabled` object store account, bucket, or file system with usage over its limiting value. For object store accounts and buckets, the limiting value is that of `quota_limit`, and for file systems it is that of `provisioned`. The operation can be either setting `hard_limit_enabled` when usage is higher than the limiting value, or modifying the limiting value to a value under usage when `hard_limit_enabled` is `true`.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[FileSystemResponse]:
        """PATCH file-systems

        Modify a file system’s attributes including its export protocols and limits.

        :param file_system: (required)
        :type file_system: FileSystemPatch
        :param delete_link_on_eradication: If set to `true`, the file system can be destroyed, even if it has a replica link. If set to `false`, the file system cannot be destroyed if it has a replica link. Defaults to `false`.
        :type delete_link_on_eradication: bool
        :param discard_detailed_permissions: This parameter must be set to `true` in order to change a file system's `access_control_style` from a style that supports more detailed access control lists to a style that only supports less detailed mode bits as a form of permission control. This parameter may not be set to `true` any other time. Setting this parameter to `true` is acknowledgement that any more detailed access control lists currently set within the file system will be lost, and NFS permission controls will only be enforced at the granularity level of NFS mode bits.
        :type discard_detailed_permissions: bool
        :param discard_non_snapshotted_data: This parameter must be set to `true` in order to restore a file system from a snapshot or to demote a file system (which restores the file system from the common baseline snapshot). Setting this parameter to `true` is acknowledgement that any non-snapshotted data currently in the file system will be irretrievably lost.
        :type discard_non_snapshotted_data: bool
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.
        :type ids: List[str]
        :param ignore_usage: Allow update operations that lead to a `hard_limit_enabled` object store account, bucket, or file system with usage over its limiting value. For object store accounts and buckets, the limiting value is that of `quota_limit`, and for file systems it is that of `provisioned`. The operation can be either setting `hard_limit_enabled` when usage is higher than the limiting value, or modifying the limiting value to a value under usage when `hard_limit_enabled` is `true`.
        :type ignore_usage: bool
        :param names: A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api210_file_systems_patch_serialize(
            file_system = file_system,
            delete_link_on_eradication = delete_link_on_eradication,
            discard_detailed_permissions = discard_detailed_permissions,
            discard_non_snapshotted_data = discard_non_snapshotted_data,
            ids = ids,
            ignore_usage = ignore_usage,
            names = names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileSystemResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api210_file_systems_patch_serialize(
        self,
        file_system,
        delete_link_on_eradication,
        discard_detailed_permissions,
        discard_non_snapshotted_data,
        ids,
        ignore_usage,
        names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
            'names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if delete_link_on_eradication is not None:
            
            _query_params.append(('delete_link_on_eradication', delete_link_on_eradication))
            
        if discard_detailed_permissions is not None:
            
            _query_params.append(('discard_detailed_permissions', discard_detailed_permissions))
            
        if discard_non_snapshotted_data is not None:
            
            _query_params.append(('discard_non_snapshotted_data', discard_non_snapshotted_data))
            
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if ignore_usage is not None:
            
            _query_params.append(('ignore_usage', ignore_usage))
            
        if names is not None:
            
            _query_params.append(('names', names))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if file_system is not None:
            _body_params = file_system


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/2.10/file-systems',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api210_file_systems_performance_get_with_http_info(
        self,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        end_time: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The offset of the first resource to return from a collection.")] = None,
        protocol: Annotated[Optional[StrictStr], Field(description="Display the performance of a specified protocol. Valid values are `all`, `HTTP`, `SMB`, `NFS`, and `S3`. If not specified, defaults to `all`, which will provide the combined performance of all available protocols.")] = None,
        resolution: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        start_time: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[FileSystemPerformanceGetResponse]:
        """GET file-systems/performance

        Displays the performance metrics for a file system.

        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param protocol: Display the performance of a specified protocol. Valid values are `all`, `HTTP`, `SMB`, `NFS`, and `S3`. If not specified, defaults to `all`, which will provide the combined performance of all available protocols.
        :type protocol: str
        :param resolution: The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param total_only: Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api210_file_systems_performance_get_serialize(
            continuation_token = continuation_token,
            end_time = end_time,
            filter = filter,
            ids = ids,
            limit = limit,
            names = names,
            offset = offset,
            protocol = protocol,
            resolution = resolution,
            sort = sort,
            start_time = start_time,
            total_only = total_only,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileSystemPerformanceGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api210_file_systems_performance_get_serialize(
        self,
        continuation_token,
        end_time,
        filter,
        ids,
        limit,
        names,
        offset,
        protocol,
        resolution,
        sort,
        start_time,
        total_only,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
            'names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if end_time is not None:
            
            _query_params.append(('end_time', end_time))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if names is not None:
            
            _query_params.append(('names', names))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if protocol is not None:
            
            _query_params.append(('protocol', protocol))
            
        if resolution is not None:
            
            _query_params.append(('resolution', resolution))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if start_time is not None:
            
            _query_params.append(('start_time', start_time))
            
        if total_only is not None:
            
            _query_params.append(('total_only', total_only))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.10/file-systems/performance',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api210_file_systems_policies_all_get_with_http_info(
        self,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[PolicyMemberGetResponse]:
        """GET file-systems/policies-all

        List file system policies.

        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api210_file_systems_policies_all_get_serialize(
            continuation_token = continuation_token,
            filter = filter,
            limit = limit,
            member_ids = member_ids,
            member_names = member_names,
            offset = offset,
            policy_ids = policy_ids,
            policy_names = policy_names,
            sort = sort,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PolicyMemberGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api210_file_systems_policies_all_get_serialize(
        self,
        continuation_token,
        filter,
        limit,
        member_ids,
        member_names,
        offset,
        policy_ids,
        policy_names,
        sort,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_ids': 'csv',
            'member_names': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.10/file-systems/policies-all',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api210_file_systems_policies_delete_with_http_info(
        self,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy names.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[None]:
        """DELETE file-systems/policies

        Remove a snapshot scheduling policy from a file system.

        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api210_file_systems_policies_delete_serialize(
            member_ids = member_ids,
            member_names = member_names,
            policy_ids = policy_ids,
            policy_names = policy_names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api210_file_systems_policies_delete_serialize(
        self,
        member_ids,
        member_names,
        policy_ids,
        policy_names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_ids': 'csv',
            'member_names': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/2.10/file-systems/policies',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api210_file_systems_policies_get_with_http_info(
        self,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[PolicyMemberGetResponse]:
        """GET file-systems/policies

        List file system snapshot scheduling policies.

        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api210_file_systems_policies_get_serialize(
            continuation_token = continuation_token,
            filter = filter,
            limit = limit,
            member_ids = member_ids,
            member_names = member_names,
            offset = offset,
            policy_ids = policy_ids,
            policy_names = policy_names,
            sort = sort,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PolicyMemberGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api210_file_systems_policies_get_serialize(
        self,
        continuation_token,
        filter,
        limit,
        member_ids,
        member_names,
        offset,
        policy_ids,
        policy_names,
        sort,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_ids': 'csv',
            'member_names': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.10/file-systems/policies',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api210_file_systems_policies_post_with_http_info(
        self,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy names.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[PolicyMemberResponse]:
        """POST file-systems/policies

        Apply a snapshot scheduling policy to a file system. Only one file system can be mapped to a policy at a time.

        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api210_file_systems_policies_post_serialize(
            member_ids = member_ids,
            member_names = member_names,
            policy_ids = policy_ids,
            policy_names = policy_names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PolicyMemberResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api210_file_systems_policies_post_serialize(
        self,
        member_ids,
        member_names,
        policy_ids,
        policy_names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_ids': 'csv',
            'member_names': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/2.10/file-systems/policies',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api210_file_systems_post_with_http_info(
        self,
        names: Annotated[List[StrictStr], Field(description="A comma-separated list of resource names.")],
        file_system: FileSystemPost,
        discard_non_snapshotted_data: Annotated[Optional[StrictBool], Field(description="This parameter must be set to `true` in order to restore a file system from a snapshot or to demote a file system (which restores the file system from the common baseline snapshot). Setting this parameter to `true` is acknowledgement that any non-snapshotted data currently in the file system will be irretrievably lost.")] = None,
        overwrite: Annotated[Optional[StrictBool], Field(description="When used for snapshot restore, overwrites (`true`) an existing file system.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[FileSystemResponse]:
        """POST file-systems

        Create a file system on the current array.

        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param file_system: (required)
        :type file_system: FileSystemPost
        :param discard_non_snapshotted_data: This parameter must be set to `true` in order to restore a file system from a snapshot or to demote a file system (which restores the file system from the common baseline snapshot). Setting this parameter to `true` is acknowledgement that any non-snapshotted data currently in the file system will be irretrievably lost.
        :type discard_non_snapshotted_data: bool
        :param overwrite: When used for snapshot restore, overwrites (`true`) an existing file system.
        :type overwrite: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api210_file_systems_post_serialize(
            names = names,
            file_system = file_system,
            discard_non_snapshotted_data = discard_non_snapshotted_data,
            overwrite = overwrite,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileSystemResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api210_file_systems_post_serialize(
        self,
        names,
        file_system,
        discard_non_snapshotted_data,
        overwrite,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if discard_non_snapshotted_data is not None:
            
            _query_params.append(('discard_non_snapshotted_data', discard_non_snapshotted_data))
            
        if names is not None:
            
            _query_params.append(('names', names))
            
        if overwrite is not None:
            
            _query_params.append(('overwrite', overwrite))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if file_system is not None:
            _body_params = file_system


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/2.10/file-systems',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api210_file_systems_sessions_delete_with_http_info(
        self,
        client_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of ip addresses of clients. For IPv6 both the extended format (x:x:x:x:x:x:x:x) and the shortened format are supported.")] = None,
        disruptive: Annotated[Optional[StrictBool], Field(description="If set to `true`, a wide scope of sessions may be deleted in a single action using a single query parameter from `user_names`, `client_names`, or `protocols`. Otherwise, multiple query parameters must be specified to narrow the impact of deletion and avoid potential for accidental disruption of clients.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        protocols: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of file protocols. Valid values include `nfs` and `smb`.")] = None,
        user_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of user names.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[None]:
        """Delete sessions

        Delete sessions. It can be used to either delete an individual session by name or multiple sessions filtered by parameters. E.g. to delete SMBv3 sessions held by specific client, `protocols` and `client_names` must be specified. To prevent accidental deletes, setting flag `disruptive` to `true` is required when only a single query parameter is part of the query. E.g. to delete all SMBv3 sessions, query parameters `protocols` and `disruptive` must be set. When `names` is specified, no other query parameter can be specified.

        :param client_names: A comma-separated list of ip addresses of clients. For IPv6 both the extended format (x:x:x:x:x:x:x:x) and the shortened format are supported.
        :type client_names: List[str]
        :param disruptive: If set to `true`, a wide scope of sessions may be deleted in a single action using a single query parameter from `user_names`, `client_names`, or `protocols`. Otherwise, multiple query parameters must be specified to narrow the impact of deletion and avoid potential for accidental disruption of clients.
        :type disruptive: bool
        :param names: A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param protocols: A comma-separated list of file protocols. Valid values include `nfs` and `smb`.
        :type protocols: List[str]
        :param user_names: A comma-separated list of user names.
        :type user_names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api210_file_systems_sessions_delete_serialize(
            client_names = client_names,
            disruptive = disruptive,
            names = names,
            protocols = protocols,
            user_names = user_names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api210_file_systems_sessions_delete_serialize(
        self,
        client_names,
        disruptive,
        names,
        protocols,
        user_names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'client_names': 'csv',
            'names': 'csv',
            'protocols': 'csv',
            'user_names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if client_names is not None:
            
            _query_params.append(('client_names', client_names))
            
        if disruptive is not None:
            
            _query_params.append(('disruptive', disruptive))
            
        if names is not None:
            
            _query_params.append(('names', names))
            
        if protocols is not None:
            
            _query_params.append(('protocols', protocols))
            
        if user_names is not None:
            
            _query_params.append(('user_names', user_names))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/2.10/file-systems/sessions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api210_file_systems_sessions_get_with_http_info(
        self,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        client_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of ip addresses of clients. For IPv6 both the extended format (x:x:x:x:x:x:x:x) and the shortened format are supported.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        protocols: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of file protocols. Valid values include `nfs` and `smb`.")] = None,
        user_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of user names.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[FileSessionGetResponse]:
        """Get a list of active sessions

        Lists all active sessions that satisfy the conditions specified by the parameters.

        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param client_names: A comma-separated list of ip addresses of clients. For IPv6 both the extended format (x:x:x:x:x:x:x:x) and the shortened format are supported.
        :type client_names: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param protocols: A comma-separated list of file protocols. Valid values include `nfs` and `smb`.
        :type protocols: List[str]
        :param user_names: A comma-separated list of user names.
        :type user_names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api210_file_systems_sessions_get_serialize(
            continuation_token = continuation_token,
            client_names = client_names,
            limit = limit,
            names = names,
            protocols = protocols,
            user_names = user_names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileSessionGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api210_file_systems_sessions_get_serialize(
        self,
        continuation_token,
        client_names,
        limit,
        names,
        protocols,
        user_names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'client_names': 'csv',
            'names': 'csv',
            'protocols': 'csv',
            'user_names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if client_names is not None:
            
            _query_params.append(('client_names', client_names))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if names is not None:
            
            _query_params.append(('names', names))
            
        if protocols is not None:
            
            _query_params.append(('protocols', protocols))
            
        if user_names is not None:
            
            _query_params.append(('user_names', user_names))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.10/file-systems/sessions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api210_file_systems_users_performance_get_with_http_info(
        self,
        file_system_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        uids: Annotated[Optional[List[StrictInt]], Field(description="A comma-separated list of user IDs. This cannot be provided together with `user_names` query parameter.")] = None,
        user_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of user names. This cannot be provided together with `uids` query parameter.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[FileSystemUsersPerformanceGetResponse]:
        """GET file-systems/users/performance

        List a user’s I/O performance metrics on a file system.

        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.
        :type file_system_names: List[str]
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param uids: A comma-separated list of user IDs. This cannot be provided together with `user_names` query parameter.
        :type uids: List[int]
        :param user_names: A comma-separated list of user names. This cannot be provided together with `uids` query parameter.
        :type user_names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api210_file_systems_users_performance_get_serialize(
            file_system_ids = file_system_ids,
            file_system_names = file_system_names,
            filter = filter,
            limit = limit,
            names = names,
            sort = sort,
            total_only = total_only,
            uids = uids,
            user_names = user_names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileSystemUsersPerformanceGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api210_file_systems_users_performance_get_serialize(
        self,
        file_system_ids,
        file_system_names,
        filter,
        limit,
        names,
        sort,
        total_only,
        uids,
        user_names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'file_system_ids': 'csv',
            'file_system_names': 'csv',
            'names': 'csv',
            'sort': 'csv',
            'uids': 'csv',
            'user_names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if file_system_ids is not None:
            
            _query_params.append(('file_system_ids', file_system_ids))
            
        if file_system_names is not None:
            
            _query_params.append(('file_system_names', file_system_names))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if names is not None:
            
            _query_params.append(('names', names))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        if total_only is not None:
            
            _query_params.append(('total_only', total_only))
            
        if uids is not None:
            
            _query_params.append(('uids', uids))
            
        if user_names is not None:
            
            _query_params.append(('user_names', user_names))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.10/file-systems/users/performance',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )

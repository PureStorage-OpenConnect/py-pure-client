# coding: utf-8

"""
    FlashBlade REST API

    A lightweight client for FlashBlade REST API 2.14, developed by Pure Storage, Inc. (http://www.purestorage.com/).

    The version of the OpenAPI document: 2.14
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from pypureclient.flashblade.FB_2_14.models.network_interface import NetworkInterface
from pypureclient.flashblade.FB_2_14.models.network_interface_get_response import NetworkInterfaceGetResponse
from pypureclient.flashblade.FB_2_14.models.network_interface_patch import NetworkInterfacePatch
from pypureclient.flashblade.FB_2_14.models.network_interface_ping_get_response import NetworkInterfacePingGetResponse
from pypureclient.flashblade.FB_2_14.models.network_interface_response import NetworkInterfaceResponse
from pypureclient.flashblade.FB_2_14.models.network_interface_trace_get_response import NetworkInterfaceTraceGetResponse
from pypureclient.flashblade.FB_2_14.api_client import ApiClient as _TransportApiClient, RequestSerialized
from pypureclient.flashblade.FB_2_14.api_response import ApiResponse
from pypureclient.flashblade.FB_2_14.rest import RESTResponseType


class NetworkInterfacesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client: Optional[_TransportApiClient] = None) -> None:
        self.api_client = api_client if api_client else _TransportApiClient.get_default()


    @validate_call
    def api214_network_interfaces_delete_with_http_info(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[None]:
        """DELETE network-interfaces

        Remove a data VIP. Once removed, any clients connected through the data VIP will lose their connection to the file system.

        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api214_network_interfaces_delete_serialize(
            x_request_id = x_request_id,
            ids = ids,
            names = names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api214_network_interfaces_delete_serialize(
        self,
        x_request_id,
        ids,
        names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
            'names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if names is not None:
            
            _query_params.append(('names', names))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/2.14/network-interfaces',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api214_network_interfaces_get_with_http_info(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[NetworkInterfaceGetResponse]:
        """GET network-interfaces

        List network interfaces and their attributes.

        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api214_network_interfaces_get_serialize(
            x_request_id = x_request_id,
            continuation_token = continuation_token,
            filter = filter,
            ids = ids,
            limit = limit,
            names = names,
            offset = offset,
            sort = sort,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NetworkInterfaceGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api214_network_interfaces_get_serialize(
        self,
        x_request_id,
        continuation_token,
        filter,
        ids,
        limit,
        names,
        offset,
        sort,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
            'names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if names is not None:
            
            _query_params.append(('names', names))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.14/network-interfaces',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api214_network_interfaces_patch_with_http_info(
        self,
        network_interface: NetworkInterfacePatch,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[NetworkInterfaceResponse]:
        """PATCH network-interfaces

        Modify the attributes of a data VIP.

        :param network_interface: (required)
        :type network_interface: NetworkInterfacePatch
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api214_network_interfaces_patch_serialize(
            network_interface = network_interface,
            x_request_id = x_request_id,
            ids = ids,
            names = names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NetworkInterfaceResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api214_network_interfaces_patch_serialize(
        self,
        network_interface,
        x_request_id,
        ids,
        names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
            'names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if names is not None:
            
            _query_params.append(('names', names))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if network_interface is not None:
            _body_params = network_interface


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/2.14/network-interfaces',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api214_network_interfaces_ping_get_with_http_info(
        self,
        destination: Annotated[StrictStr, Field(description="A destination specified by user to run the network diagnosis against. Can be a hostname or an IP.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        packet_size: Annotated[Optional[StrictInt], Field(description="Used by ping to specify the number of data bytes to be sent per packet. If not specified, defaults to 56.")] = None,
        count: Annotated[Optional[StrictInt], Field(description="Used by ping to specify the number of packets to send. If not specified, defaults to 1.")] = None,
        component_name: Annotated[Optional[StrictStr], Field(description="Used by ping and trace to specify where to run the operation. Valid values are controllers and blades from hardware list. If not specified, defaults to all available controllers and selected blades.")] = None,
        source: Annotated[Optional[StrictStr], Field(description="Used by ping and trace to specify the property where to start to run the specified operation. The property can be subnet or IP.")] = None,
        print_latency: Annotated[Optional[StrictBool], Field(description="Used by ping to specify whether or not to print the full user-to-user latency. If not specified, defaults to false.")] = None,
        resolve_hostname: Annotated[Optional[StrictBool], Field(description="Used by ping and trace to specify whether or not to map IP addresses to host names. If not specified, defaults to true.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[NetworkInterfacePingGetResponse]:
        """GET network-interfaces/ping

        Display network interface ping result.

        :param destination: A destination specified by user to run the network diagnosis against. Can be a hostname or an IP. (required)
        :type destination: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param packet_size: Used by ping to specify the number of data bytes to be sent per packet. If not specified, defaults to 56.
        :type packet_size: int
        :param count: Used by ping to specify the number of packets to send. If not specified, defaults to 1.
        :type count: int
        :param component_name: Used by ping and trace to specify where to run the operation. Valid values are controllers and blades from hardware list. If not specified, defaults to all available controllers and selected blades.
        :type component_name: str
        :param source: Used by ping and trace to specify the property where to start to run the specified operation. The property can be subnet or IP.
        :type source: str
        :param print_latency: Used by ping to specify whether or not to print the full user-to-user latency. If not specified, defaults to false.
        :type print_latency: bool
        :param resolve_hostname: Used by ping and trace to specify whether or not to map IP addresses to host names. If not specified, defaults to true.
        :type resolve_hostname: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api214_network_interfaces_ping_get_serialize(
            destination = destination,
            x_request_id = x_request_id,
            packet_size = packet_size,
            count = count,
            component_name = component_name,
            source = source,
            print_latency = print_latency,
            resolve_hostname = resolve_hostname,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NetworkInterfacePingGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api214_network_interfaces_ping_get_serialize(
        self,
        destination,
        x_request_id,
        packet_size,
        count,
        component_name,
        source,
        print_latency,
        resolve_hostname,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if packet_size is not None:
            
            _query_params.append(('packet_size', packet_size))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if component_name is not None:
            
            _query_params.append(('component_name', component_name))
            
        if destination is not None:
            
            _query_params.append(('destination', destination))
            
        if source is not None:
            
            _query_params.append(('source', source))
            
        if print_latency is not None:
            
            _query_params.append(('print_latency', print_latency))
            
        if resolve_hostname is not None:
            
            _query_params.append(('resolve_hostname', resolve_hostname))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.14/network-interfaces/ping',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api214_network_interfaces_post_with_http_info(
        self,
        names: Annotated[List[StrictStr], Field(description="A comma-separated list of resource names.")],
        network_interface: NetworkInterface,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[NetworkInterfaceResponse]:
        """POST network-interfaces

        Create a data VIP to export a file system.

        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param network_interface: (required)
        :type network_interface: NetworkInterface
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api214_network_interfaces_post_serialize(
            names = names,
            network_interface = network_interface,
            x_request_id = x_request_id,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NetworkInterfaceResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api214_network_interfaces_post_serialize(
        self,
        names,
        network_interface,
        x_request_id,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if names is not None:
            
            _query_params.append(('names', names))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if network_interface is not None:
            _body_params = network_interface


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/2.14/network-interfaces',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api214_network_interfaces_trace_get_with_http_info(
        self,
        destination: Annotated[StrictStr, Field(description="A destination specified by user to run the network diagnosis against. Can be a hostname or an IP.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        fragment_packet: Annotated[Optional[StrictBool], Field(description="Used by trace to specify whether or not to fragment packets. If not specified, defaults to true.")] = None,
        method: Annotated[Optional[StrictStr], Field(description="Used by trace to specify which method to use for trace operations. Valid values are `icmp`, `tcp`, and `udp`. If not specified, defaults to 'udp'.")] = None,
        discover_mtu: Annotated[Optional[StrictBool], Field(description="Used by trace to specify whether or not to discover the MTU along the path being traced. If not specified, defaults to false.")] = None,
        component_name: Annotated[Optional[StrictStr], Field(description="Used by ping and trace to specify where to run the operation. Valid values are controllers and blades from hardware list. If not specified, defaults to all available controllers and selected blades.")] = None,
        source: Annotated[Optional[StrictStr], Field(description="Used by ping and trace to specify the property where to start to run the specified operation. The property can be subnet or IP.")] = None,
        port: Annotated[Optional[StrictStr], Field(description="Used by trace to specify a destination port.")] = None,
        resolve_hostname: Annotated[Optional[StrictBool], Field(description="Used by ping and trace to specify whether or not to map IP addresses to host names. If not specified, defaults to true.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[NetworkInterfaceTraceGetResponse]:
        """GET network-interfaces/trace

        Display network interface trace result.

        :param destination: A destination specified by user to run the network diagnosis against. Can be a hostname or an IP. (required)
        :type destination: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param fragment_packet: Used by trace to specify whether or not to fragment packets. If not specified, defaults to true.
        :type fragment_packet: bool
        :param method: Used by trace to specify which method to use for trace operations. Valid values are `icmp`, `tcp`, and `udp`. If not specified, defaults to 'udp'.
        :type method: str
        :param discover_mtu: Used by trace to specify whether or not to discover the MTU along the path being traced. If not specified, defaults to false.
        :type discover_mtu: bool
        :param component_name: Used by ping and trace to specify where to run the operation. Valid values are controllers and blades from hardware list. If not specified, defaults to all available controllers and selected blades.
        :type component_name: str
        :param source: Used by ping and trace to specify the property where to start to run the specified operation. The property can be subnet or IP.
        :type source: str
        :param port: Used by trace to specify a destination port.
        :type port: str
        :param resolve_hostname: Used by ping and trace to specify whether or not to map IP addresses to host names. If not specified, defaults to true.
        :type resolve_hostname: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api214_network_interfaces_trace_get_serialize(
            destination = destination,
            x_request_id = x_request_id,
            fragment_packet = fragment_packet,
            method = method,
            discover_mtu = discover_mtu,
            component_name = component_name,
            source = source,
            port = port,
            resolve_hostname = resolve_hostname,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NetworkInterfaceTraceGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api214_network_interfaces_trace_get_serialize(
        self,
        destination,
        x_request_id,
        fragment_packet,
        method,
        discover_mtu,
        component_name,
        source,
        port,
        resolve_hostname,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if fragment_packet is not None:
            
            _query_params.append(('fragment_packet', fragment_packet))
            
        if method is not None:
            
            _query_params.append(('method', method))
            
        if discover_mtu is not None:
            
            _query_params.append(('discover_mtu', discover_mtu))
            
        if component_name is not None:
            
            _query_params.append(('component_name', component_name))
            
        if destination is not None:
            
            _query_params.append(('destination', destination))
            
        if source is not None:
            
            _query_params.append(('source', source))
            
        if port is not None:
            
            _query_params.append(('port', port))
            
        if resolve_hostname is not None:
            
            _query_params.append(('resolve_hostname', resolve_hostname))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.14/network-interfaces/trace',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )

# coding: utf-8

"""
    FlashBlade REST API

    A lightweight client for FlashBlade REST API 2.1, developed by Pure Storage, Inc. (http://www.purestorage.com/).

    The version of the OpenAPI document: 2.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from pypureclient.flashblade.FB_2_1.models.bucket_replica_link import BucketReplicaLink
from pypureclient.flashblade.FB_2_1.models.bucket_replica_link_get_response import BucketReplicaLinkGetResponse
from pypureclient.flashblade.FB_2_1.models.bucket_replica_link_post import BucketReplicaLinkPost
from pypureclient.flashblade.FB_2_1.models.bucket_replica_link_response import BucketReplicaLinkResponse
from pypureclient.flashblade.FB_2_1.api_client import ApiClient as _TransportApiClient, RequestSerialized
from pypureclient.flashblade.FB_2_1.api_response import ApiResponse
from pypureclient.flashblade.FB_2_1.rest import RESTResponseType


class BucketReplicaLinksApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client: Optional[_TransportApiClient] = None) -> None:
        self.api_client = api_client if api_client else _TransportApiClient.get_default()


    @validate_call
    def api21_bucket_replica_links_delete_with_http_info(
        self,
        ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        local_bucket_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of local bucket IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_bucket_names` query parameter.")] = None,
        local_bucket_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of local bucket names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_bucket_ids` query parameter.")] = None,
        remote_bucket_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote bucket names. If there is not at least one resource that matches each of the elements, then an error is returned.")] = None,
        remote_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[None]:
        """DELETE bucket-replica-links

        Delete a bucket replica link.

        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.
        :type ids: List[str]
        :param local_bucket_ids: A comma-separated list of local bucket IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_bucket_names` query parameter.
        :type local_bucket_ids: List[str]
        :param local_bucket_names: A comma-separated list of local bucket names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_bucket_ids` query parameter.
        :type local_bucket_names: List[str]
        :param remote_bucket_names: A comma-separated list of remote bucket names. If there is not at least one resource that matches each of the elements, then an error is returned.
        :type remote_bucket_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api21_bucket_replica_links_delete_serialize(
            ids = ids,
            local_bucket_ids = local_bucket_ids,
            local_bucket_names = local_bucket_names,
            remote_bucket_names = remote_bucket_names,
            remote_ids = remote_ids,
            remote_names = remote_names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api21_bucket_replica_links_delete_serialize(
        self,
        ids,
        local_bucket_ids,
        local_bucket_names,
        remote_bucket_names,
        remote_ids,
        remote_names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
            'local_bucket_ids': 'csv',
            'local_bucket_names': 'csv',
            'remote_bucket_names': 'csv',
            'remote_ids': 'csv',
            'remote_names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if local_bucket_ids is not None:
            
            _query_params.append(('local_bucket_ids', local_bucket_ids))
            
        if local_bucket_names is not None:
            
            _query_params.append(('local_bucket_names', local_bucket_names))
            
        if remote_bucket_names is not None:
            
            _query_params.append(('remote_bucket_names', remote_bucket_names))
            
        if remote_ids is not None:
            
            _query_params.append(('remote_ids', remote_ids))
            
        if remote_names is not None:
            
            _query_params.append(('remote_names', remote_names))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/2.1/bucket-replica-links',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api21_bucket_replica_links_get_with_http_info(
        self,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        local_bucket_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of local bucket IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_bucket_names` query parameter.")] = None,
        local_bucket_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of local bucket names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_bucket_ids` query parameter.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The offset of the first resource to return from a collection.")] = None,
        remote_bucket_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote bucket names. If there is not at least one resource that matches each of the elements, then an error is returned.")] = None,
        remote_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[BucketReplicaLinkGetResponse]:
        """GET bucket-replica-links

        List bucket replica links for object replication.

        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.
        :type limit: int
        :param local_bucket_ids: A comma-separated list of local bucket IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_bucket_names` query parameter.
        :type local_bucket_ids: List[str]
        :param local_bucket_names: A comma-separated list of local bucket names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_bucket_ids` query parameter.
        :type local_bucket_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param remote_bucket_names: A comma-separated list of remote bucket names. If there is not at least one resource that matches each of the elements, then an error is returned.
        :type remote_bucket_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api21_bucket_replica_links_get_serialize(
            continuation_token = continuation_token,
            filter = filter,
            ids = ids,
            limit = limit,
            local_bucket_ids = local_bucket_ids,
            local_bucket_names = local_bucket_names,
            offset = offset,
            remote_bucket_names = remote_bucket_names,
            remote_ids = remote_ids,
            remote_names = remote_names,
            sort = sort,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BucketReplicaLinkGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api21_bucket_replica_links_get_serialize(
        self,
        continuation_token,
        filter,
        ids,
        limit,
        local_bucket_ids,
        local_bucket_names,
        offset,
        remote_bucket_names,
        remote_ids,
        remote_names,
        sort,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
            'local_bucket_ids': 'csv',
            'local_bucket_names': 'csv',
            'remote_bucket_names': 'csv',
            'remote_ids': 'csv',
            'remote_names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if local_bucket_ids is not None:
            
            _query_params.append(('local_bucket_ids', local_bucket_ids))
            
        if local_bucket_names is not None:
            
            _query_params.append(('local_bucket_names', local_bucket_names))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if remote_bucket_names is not None:
            
            _query_params.append(('remote_bucket_names', remote_bucket_names))
            
        if remote_ids is not None:
            
            _query_params.append(('remote_ids', remote_ids))
            
        if remote_names is not None:
            
            _query_params.append(('remote_names', remote_names))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.1/bucket-replica-links',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api21_bucket_replica_links_patch_with_http_info(
        self,
        bucket_replica_link: BucketReplicaLink,
        ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        local_bucket_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of local bucket IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_bucket_names` query parameter.")] = None,
        local_bucket_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of local bucket names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_bucket_ids` query parameter.")] = None,
        remote_bucket_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote bucket names. If there is not at least one resource that matches each of the elements, then an error is returned.")] = None,
        remote_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[BucketReplicaLinkResponse]:
        """PATCH bucket-replica-links

        Modify the configuration of a bucket replica link including whether the link is paused and the object store remote credentials used.

        :param bucket_replica_link: (required)
        :type bucket_replica_link: BucketReplicaLink
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.
        :type ids: List[str]
        :param local_bucket_ids: A comma-separated list of local bucket IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_bucket_names` query parameter.
        :type local_bucket_ids: List[str]
        :param local_bucket_names: A comma-separated list of local bucket names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_bucket_ids` query parameter.
        :type local_bucket_names: List[str]
        :param remote_bucket_names: A comma-separated list of remote bucket names. If there is not at least one resource that matches each of the elements, then an error is returned.
        :type remote_bucket_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api21_bucket_replica_links_patch_serialize(
            bucket_replica_link = bucket_replica_link,
            ids = ids,
            local_bucket_ids = local_bucket_ids,
            local_bucket_names = local_bucket_names,
            remote_bucket_names = remote_bucket_names,
            remote_ids = remote_ids,
            remote_names = remote_names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BucketReplicaLinkResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api21_bucket_replica_links_patch_serialize(
        self,
        bucket_replica_link,
        ids,
        local_bucket_ids,
        local_bucket_names,
        remote_bucket_names,
        remote_ids,
        remote_names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
            'local_bucket_ids': 'csv',
            'local_bucket_names': 'csv',
            'remote_bucket_names': 'csv',
            'remote_ids': 'csv',
            'remote_names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if local_bucket_ids is not None:
            
            _query_params.append(('local_bucket_ids', local_bucket_ids))
            
        if local_bucket_names is not None:
            
            _query_params.append(('local_bucket_names', local_bucket_names))
            
        if remote_bucket_names is not None:
            
            _query_params.append(('remote_bucket_names', remote_bucket_names))
            
        if remote_ids is not None:
            
            _query_params.append(('remote_ids', remote_ids))
            
        if remote_names is not None:
            
            _query_params.append(('remote_names', remote_names))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if bucket_replica_link is not None:
            _body_params = bucket_replica_link


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/2.1/bucket-replica-links',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api21_bucket_replica_links_post_with_http_info(
        self,
        bucket_replica_link: BucketReplicaLinkPost,
        local_bucket_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of local bucket names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_bucket_ids` query parameter.")] = None,
        local_bucket_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of local bucket IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_bucket_names` query parameter.")] = None,
        remote_bucket_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote bucket names. If there is not at least one resource that matches each of the elements, then an error is returned.")] = None,
        remote_credentials_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote credentials names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_credentials_ids` query parameter.")] = None,
        remote_credentials_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote credentials IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_credentials_names` query parameter.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[BucketReplicaLinkResponse]:
        """POST bucket-replica-links

        Create a bucket replica link for object replication.

        :param bucket_replica_link: (required)
        :type bucket_replica_link: BucketReplicaLinkPost
        :param local_bucket_names: A comma-separated list of local bucket names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_bucket_ids` query parameter.
        :type local_bucket_names: List[str]
        :param local_bucket_ids: A comma-separated list of local bucket IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_bucket_names` query parameter.
        :type local_bucket_ids: List[str]
        :param remote_bucket_names: A comma-separated list of remote bucket names. If there is not at least one resource that matches each of the elements, then an error is returned.
        :type remote_bucket_names: List[str]
        :param remote_credentials_names: A comma-separated list of remote credentials names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_credentials_ids` query parameter.
        :type remote_credentials_names: List[str]
        :param remote_credentials_ids: A comma-separated list of remote credentials IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_credentials_names` query parameter.
        :type remote_credentials_ids: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api21_bucket_replica_links_post_serialize(
            bucket_replica_link = bucket_replica_link,
            local_bucket_names = local_bucket_names,
            local_bucket_ids = local_bucket_ids,
            remote_bucket_names = remote_bucket_names,
            remote_credentials_names = remote_credentials_names,
            remote_credentials_ids = remote_credentials_ids,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BucketReplicaLinkResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api21_bucket_replica_links_post_serialize(
        self,
        bucket_replica_link,
        local_bucket_names,
        local_bucket_ids,
        remote_bucket_names,
        remote_credentials_names,
        remote_credentials_ids,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'local_bucket_names': 'csv',
            'local_bucket_ids': 'csv',
            'remote_bucket_names': 'csv',
            'remote_credentials_names': 'csv',
            'remote_credentials_ids': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if local_bucket_names is not None:
            
            _query_params.append(('local_bucket_names', local_bucket_names))
            
        if local_bucket_ids is not None:
            
            _query_params.append(('local_bucket_ids', local_bucket_ids))
            
        if remote_bucket_names is not None:
            
            _query_params.append(('remote_bucket_names', remote_bucket_names))
            
        if remote_credentials_names is not None:
            
            _query_params.append(('remote_credentials_names', remote_credentials_names))
            
        if remote_credentials_ids is not None:
            
            _query_params.append(('remote_credentials_ids', remote_credentials_ids))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if bucket_replica_link is not None:
            _body_params = bucket_replica_link


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/2.1/bucket-replica-links',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )

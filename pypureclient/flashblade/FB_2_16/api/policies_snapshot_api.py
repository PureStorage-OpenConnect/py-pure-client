# coding: utf-8

"""
    FlashBlade REST API

    A lightweight client for FlashBlade REST API 2.16, developed by Pure Storage, Inc. (http://www.purestorage.com/).

    The version of the OpenAPI document: 2.16
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from pypureclient.flashblade.FB_2_16.models.policy import Policy
from pypureclient.flashblade.FB_2_16.models.policy_file_system_snapshot_get_response import PolicyFileSystemSnapshotGetResponse
from pypureclient.flashblade.FB_2_16.models.policy_get_response import PolicyGetResponse
from pypureclient.flashblade.FB_2_16.models.policy_member_get_response import PolicyMemberGetResponse
from pypureclient.flashblade.FB_2_16.models.policy_member_response import PolicyMemberResponse
from pypureclient.flashblade.FB_2_16.models.policy_member_with_remote_get_response import PolicyMemberWithRemoteGetResponse
from pypureclient.flashblade.FB_2_16.models.policy_member_with_remote_response import PolicyMemberWithRemoteResponse
from pypureclient.flashblade.FB_2_16.models.policy_patch import PolicyPatch
from pypureclient.flashblade.FB_2_16.models.policy_response import PolicyResponse
from pypureclient.flashblade.FB_2_16.api_client import ApiClient as _TransportApiClient, RequestSerialized
from pypureclient.flashblade.FB_2_16.api_response import ApiResponse
from pypureclient.flashblade.FB_2_16.rest import RESTResponseType


class PoliciesSnapshotApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client: Optional[_TransportApiClient] = None) -> None:
        self.api_client = api_client if api_client else _TransportApiClient.get_default()


    @validate_call
    def api216_policies_delete_with_http_info(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[None]:
        """DELETE policies

        Delete one or more snapshot scheduling policies.

        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api216_policies_delete_serialize(
            x_request_id = x_request_id,
            ids = ids,
            names = names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api216_policies_delete_serialize(
        self,
        x_request_id,
        ids,
        names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
            'names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if names is not None:
            
            _query_params.append(('names', names))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/2.16/policies',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api216_policies_file_system_replica_links_delete_with_http_info(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        local_file_system_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy names.")] = None,
        remote_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[None]:
        """DELETE policies/file-system-replica-links

        Remove a snapshot scheduling policy mapped to a file system replica link.

        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.
        :type member_ids: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api216_policies_file_system_replica_links_delete_serialize(
            x_request_id = x_request_id,
            local_file_system_ids = local_file_system_ids,
            local_file_system_names = local_file_system_names,
            member_ids = member_ids,
            policy_ids = policy_ids,
            policy_names = policy_names,
            remote_ids = remote_ids,
            remote_names = remote_names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api216_policies_file_system_replica_links_delete_serialize(
        self,
        x_request_id,
        local_file_system_ids,
        local_file_system_names,
        member_ids,
        policy_ids,
        policy_names,
        remote_ids,
        remote_names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'local_file_system_ids': 'csv',
            'local_file_system_names': 'csv',
            'member_ids': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
            'remote_ids': 'csv',
            'remote_names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if local_file_system_ids is not None:
            
            _query_params.append(('local_file_system_ids', local_file_system_ids))
            
        if local_file_system_names is not None:
            
            _query_params.append(('local_file_system_names', local_file_system_names))
            
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        if remote_ids is not None:
            
            _query_params.append(('remote_ids', remote_ids))
            
        if remote_names is not None:
            
            _query_params.append(('remote_names', remote_names))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/2.16/policies/file-system-replica-links',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api216_policies_file_system_replica_links_get_with_http_info(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        local_file_system_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy names.")] = None,
        remote_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_file_system_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote file system IDs. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_names` query parameter.")] = None,
        remote_file_system_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_ids` query parameter.")] = None,
        remote_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[PolicyMemberWithRemoteGetResponse]:
        """GET policies/file-system-replica-links

        List snapshot scheduling policies for file system replica links.

        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.
        :type limit: int
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.
        :type member_ids: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.
        :type remote_ids: List[str]
        :param remote_file_system_ids: A comma-separated list of remote file system IDs. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_names` query parameter.
        :type remote_file_system_ids: List[str]
        :param remote_file_system_names: A comma-separated list of remote file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_ids` query parameter.
        :type remote_file_system_names: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api216_policies_file_system_replica_links_get_serialize(
            x_request_id = x_request_id,
            continuation_token = continuation_token,
            filter = filter,
            limit = limit,
            local_file_system_ids = local_file_system_ids,
            local_file_system_names = local_file_system_names,
            member_ids = member_ids,
            offset = offset,
            policy_ids = policy_ids,
            policy_names = policy_names,
            remote_ids = remote_ids,
            remote_file_system_ids = remote_file_system_ids,
            remote_file_system_names = remote_file_system_names,
            remote_names = remote_names,
            sort = sort,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PolicyMemberWithRemoteGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api216_policies_file_system_replica_links_get_serialize(
        self,
        x_request_id,
        continuation_token,
        filter,
        limit,
        local_file_system_ids,
        local_file_system_names,
        member_ids,
        offset,
        policy_ids,
        policy_names,
        remote_ids,
        remote_file_system_ids,
        remote_file_system_names,
        remote_names,
        sort,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'local_file_system_ids': 'csv',
            'local_file_system_names': 'csv',
            'member_ids': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
            'remote_ids': 'csv',
            'remote_file_system_ids': 'csv',
            'remote_file_system_names': 'csv',
            'remote_names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if local_file_system_ids is not None:
            
            _query_params.append(('local_file_system_ids', local_file_system_ids))
            
        if local_file_system_names is not None:
            
            _query_params.append(('local_file_system_names', local_file_system_names))
            
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        if remote_ids is not None:
            
            _query_params.append(('remote_ids', remote_ids))
            
        if remote_file_system_ids is not None:
            
            _query_params.append(('remote_file_system_ids', remote_file_system_ids))
            
        if remote_file_system_names is not None:
            
            _query_params.append(('remote_file_system_names', remote_file_system_names))
            
        if remote_names is not None:
            
            _query_params.append(('remote_names', remote_names))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.16/policies/file-system-replica-links',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api216_policies_file_system_replica_links_post_with_http_info(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        local_file_system_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy names.")] = None,
        remote_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[PolicyMemberWithRemoteResponse]:
        """POST policies/file-system-replica-links

        Add a snapshot scheduling policy to a file system replica link.

        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.
        :type member_ids: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api216_policies_file_system_replica_links_post_serialize(
            x_request_id = x_request_id,
            local_file_system_ids = local_file_system_ids,
            local_file_system_names = local_file_system_names,
            member_ids = member_ids,
            policy_ids = policy_ids,
            policy_names = policy_names,
            remote_ids = remote_ids,
            remote_names = remote_names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PolicyMemberWithRemoteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api216_policies_file_system_replica_links_post_serialize(
        self,
        x_request_id,
        local_file_system_ids,
        local_file_system_names,
        member_ids,
        policy_ids,
        policy_names,
        remote_ids,
        remote_names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'local_file_system_ids': 'csv',
            'local_file_system_names': 'csv',
            'member_ids': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
            'remote_ids': 'csv',
            'remote_names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if local_file_system_ids is not None:
            
            _query_params.append(('local_file_system_ids', local_file_system_ids))
            
        if local_file_system_names is not None:
            
            _query_params.append(('local_file_system_names', local_file_system_names))
            
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        if remote_ids is not None:
            
            _query_params.append(('remote_ids', remote_ids))
            
        if remote_names is not None:
            
            _query_params.append(('remote_names', remote_names))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/2.16/policies/file-system-replica-links',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api216_policies_file_system_snapshots_delete_with_http_info(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy names.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[None]:
        """DELETE policies/file-system-snapshots

        Remove the snapshot scheduling policy mapped to a file system.

        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api216_policies_file_system_snapshots_delete_serialize(
            x_request_id = x_request_id,
            member_ids = member_ids,
            member_names = member_names,
            policy_ids = policy_ids,
            policy_names = policy_names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api216_policies_file_system_snapshots_delete_serialize(
        self,
        x_request_id,
        member_ids,
        member_names,
        policy_ids,
        policy_names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_ids': 'csv',
            'member_names': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/2.16/policies/file-system-snapshots',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api216_policies_file_system_snapshots_get_with_http_info(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[PolicyFileSystemSnapshotGetResponse]:
        """GET policies/file-system-snapshots

        List file system snapshots mapped to a snapshot scheduling policy.

        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api216_policies_file_system_snapshots_get_serialize(
            x_request_id = x_request_id,
            continuation_token = continuation_token,
            filter = filter,
            limit = limit,
            member_ids = member_ids,
            member_names = member_names,
            offset = offset,
            policy_ids = policy_ids,
            policy_names = policy_names,
            sort = sort,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PolicyFileSystemSnapshotGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api216_policies_file_system_snapshots_get_serialize(
        self,
        x_request_id,
        continuation_token,
        filter,
        limit,
        member_ids,
        member_names,
        offset,
        policy_ids,
        policy_names,
        sort,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_ids': 'csv',
            'member_names': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.16/policies/file-system-snapshots',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api216_policies_file_systems_delete_with_http_info(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy names.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[None]:
        """DELETE policies/file-systems

        Remove the snapshot scheduling policy mapped to a file system.

        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api216_policies_file_systems_delete_serialize(
            x_request_id = x_request_id,
            member_ids = member_ids,
            member_names = member_names,
            policy_ids = policy_ids,
            policy_names = policy_names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api216_policies_file_systems_delete_serialize(
        self,
        x_request_id,
        member_ids,
        member_names,
        policy_ids,
        policy_names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_ids': 'csv',
            'member_names': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/2.16/policies/file-systems',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api216_policies_file_systems_get_with_http_info(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[PolicyMemberGetResponse]:
        """GET policies/file-systems

        List file systems mapped to a snapshot scheduling policy.

        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api216_policies_file_systems_get_serialize(
            x_request_id = x_request_id,
            continuation_token = continuation_token,
            filter = filter,
            limit = limit,
            member_ids = member_ids,
            member_names = member_names,
            offset = offset,
            policy_ids = policy_ids,
            policy_names = policy_names,
            sort = sort,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PolicyMemberGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api216_policies_file_systems_get_serialize(
        self,
        x_request_id,
        continuation_token,
        filter,
        limit,
        member_ids,
        member_names,
        offset,
        policy_ids,
        policy_names,
        sort,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_ids': 'csv',
            'member_names': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.16/policies/file-systems',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api216_policies_file_systems_post_with_http_info(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy names.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[PolicyMemberResponse]:
        """POST policies/file-systems

        Map a file system to a snapshot scheduling policy.

        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api216_policies_file_systems_post_serialize(
            x_request_id = x_request_id,
            member_ids = member_ids,
            member_names = member_names,
            policy_ids = policy_ids,
            policy_names = policy_names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PolicyMemberResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api216_policies_file_systems_post_serialize(
        self,
        x_request_id,
        member_ids,
        member_names,
        policy_ids,
        policy_names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'member_ids': 'csv',
            'member_names': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/2.16/policies/file-systems',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api216_policies_get_with_http_info(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[PolicyGetResponse]:
        """GET policies

        Display snapshot scheduling policies and their attributes.

        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api216_policies_get_serialize(
            x_request_id = x_request_id,
            continuation_token = continuation_token,
            filter = filter,
            ids = ids,
            limit = limit,
            names = names,
            offset = offset,
            sort = sort,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PolicyGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api216_policies_get_serialize(
        self,
        x_request_id,
        continuation_token,
        filter,
        ids,
        limit,
        names,
        offset,
        sort,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
            'names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if names is not None:
            
            _query_params.append(('names', names))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.16/policies',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api216_policies_members_get_with_http_info(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        local_file_system_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of member names.")] = None,
        member_types: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of member types. Valid values are `file-systems`, `file-system-snapshots`, `file-system-replica-links`, and `object-store-users`. Different endpoints may accept different subsets of these values.")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of policy names.")] = None,
        remote_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_file_system_ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote file system IDs. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_names` query parameter.")] = None,
        remote_file_system_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_ids` query parameter.")] = None,
        remote_names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[PolicyMemberWithRemoteGetResponse]:
        """GET policies/members

        List snapshot scheduling policies mapped to file systems, snapshots, and file system replica links.

        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.
        :type limit: int
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param member_types: A comma-separated list of member types. Valid values are `file-systems`, `file-system-snapshots`, `file-system-replica-links`, and `object-store-users`. Different endpoints may accept different subsets of these values.
        :type member_types: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.
        :type remote_ids: List[str]
        :param remote_file_system_ids: A comma-separated list of remote file system IDs. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_names` query parameter.
        :type remote_file_system_ids: List[str]
        :param remote_file_system_names: A comma-separated list of remote file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_ids` query parameter.
        :type remote_file_system_names: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api216_policies_members_get_serialize(
            x_request_id = x_request_id,
            continuation_token = continuation_token,
            filter = filter,
            limit = limit,
            local_file_system_ids = local_file_system_ids,
            local_file_system_names = local_file_system_names,
            member_ids = member_ids,
            member_names = member_names,
            member_types = member_types,
            offset = offset,
            policy_ids = policy_ids,
            policy_names = policy_names,
            remote_ids = remote_ids,
            remote_file_system_ids = remote_file_system_ids,
            remote_file_system_names = remote_file_system_names,
            remote_names = remote_names,
            sort = sort,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PolicyMemberWithRemoteGetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api216_policies_members_get_serialize(
        self,
        x_request_id,
        continuation_token,
        filter,
        limit,
        local_file_system_ids,
        local_file_system_names,
        member_ids,
        member_names,
        member_types,
        offset,
        policy_ids,
        policy_names,
        remote_ids,
        remote_file_system_ids,
        remote_file_system_names,
        remote_names,
        sort,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'local_file_system_ids': 'csv',
            'local_file_system_names': 'csv',
            'member_ids': 'csv',
            'member_names': 'csv',
            'member_types': 'csv',
            'policy_ids': 'csv',
            'policy_names': 'csv',
            'remote_ids': 'csv',
            'remote_file_system_ids': 'csv',
            'remote_file_system_names': 'csv',
            'remote_names': 'csv',
            'sort': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if continuation_token is not None:
            
            _query_params.append(('continuation_token', continuation_token))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if local_file_system_ids is not None:
            
            _query_params.append(('local_file_system_ids', local_file_system_ids))
            
        if local_file_system_names is not None:
            
            _query_params.append(('local_file_system_names', local_file_system_names))
            
        if member_ids is not None:
            
            _query_params.append(('member_ids', member_ids))
            
        if member_names is not None:
            
            _query_params.append(('member_names', member_names))
            
        if member_types is not None:
            
            _query_params.append(('member_types', member_types))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if policy_ids is not None:
            
            _query_params.append(('policy_ids', policy_ids))
            
        if policy_names is not None:
            
            _query_params.append(('policy_names', policy_names))
            
        if remote_ids is not None:
            
            _query_params.append(('remote_ids', remote_ids))
            
        if remote_file_system_ids is not None:
            
            _query_params.append(('remote_file_system_ids', remote_file_system_ids))
            
        if remote_file_system_names is not None:
            
            _query_params.append(('remote_file_system_names', remote_file_system_names))
            
        if remote_names is not None:
            
            _query_params.append(('remote_names', remote_names))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/2.16/policies/members',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api216_policies_patch_with_http_info(
        self,
        policy: PolicyPatch,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        destroy_snapshots: Annotated[Optional[StrictBool], Field(description="This parameter must be set to `true` in order to modify a policy such that local or remote snapshots would be destroyed.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[PolicyResponse]:
        """PATCH policies

        Modify a snapshot scheduling policys attributes for when and how often snapshots are created and how long they are retained.

        :param policy: (required)
        :type policy: PolicyPatch
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.
        :type ids: List[str]
        :param destroy_snapshots: This parameter must be set to `true` in order to modify a policy such that local or remote snapshots would be destroyed.
        :type destroy_snapshots: bool
        :param names: A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api216_policies_patch_serialize(
            policy = policy,
            x_request_id = x_request_id,
            ids = ids,
            destroy_snapshots = destroy_snapshots,
            names = names,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PolicyResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api216_policies_patch_serialize(
        self,
        policy,
        x_request_id,
        ids,
        destroy_snapshots,
        names,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
            'names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if destroy_snapshots is not None:
            
            _query_params.append(('destroy_snapshots', destroy_snapshots))
            
        if names is not None:
            
            _query_params.append(('names', names))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if policy is not None:
            _body_params = policy


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/2.16/policies',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )


    @validate_call
    def api216_policies_post_with_http_info(
        self,
        names: Annotated[List[StrictStr], Field(description="A comma-separated list of resource names.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        policy: Optional[Policy] = None,
        _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]] = None
    ) -> ApiResponse[PolicyResponse]:
        """POST policies

        Create a new snapshot scheduling policy with rule attributes to capture file system snapshots for a set period of time and frequency, as well as how long snapshots are retained before being destroyed and eradicated.

        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param policy:
        :type policy: Policy
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501


        _param = self._api216_policies_post_serialize(
            names = names,
            x_request_id = x_request_id,
            policy = policy,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PolicyResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    def _api216_policies_post_serialize(
        self,
        names,
        x_request_id,
        policy,
    ) -> RequestSerialized:

        _collection_formats: Dict[str, str] = {
            'names': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if names is not None:
            
            _query_params.append(('names', names))
            
        # process the header parameters
        if x_request_id is not None:
            _header_params['X-Request-ID'] = x_request_id
        # process the form parameters
        # process the body parameter
        if policy is not None:
            _body_params = policy


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        _default_content_type = (
            self.api_client.select_header_content_type(
                [
                    'application/json'
                ]
            )
        )
        if _default_content_type is not None:
            _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'AuthorizationHeader'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/2.16/policies',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats
        )

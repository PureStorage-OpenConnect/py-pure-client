# coding: utf-8

"""
    FlashBlade REST API

    A lightweight client for FlashBlade REST API 2.18, developed by Pure Storage, Inc. (http://www.purestorage.com/).

    The version of the OpenAPI document: 2.18
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json
from typing import Set, Dict, Any

from typing import Optional

try:
    from pydantic.v1 import BaseModel, Field, StrictBool, StrictInt, StrictStr
except ModuleNotFoundError:
    from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
from pypureclient.flashblade.FB_2_18.models.bucket_eradication_config import BucketEradicationConfig
from pypureclient.flashblade.FB_2_18.models.fixed_reference import FixedReference
from pypureclient.flashblade.FB_2_18.models.object_lock_config_response import ObjectLockConfigResponse
from pypureclient.flashblade.FB_2_18.models.public_access_config import PublicAccessConfig
from pypureclient.flashblade.FB_2_18.models.reference import Reference
from pypureclient.flashblade.FB_2_18.models.space import Space


class Bucket(BaseModel):
    """
    Bucket
    """
    id: Optional[StrictStr] = Field(default=None, description="A non-modifiable, globally unique ID chosen by the system.")
    name: Optional[StrictStr] = Field(default=None, description="Name of the object (e.g., a file system or snapshot).")
    context: Optional[Reference] = Field(default=None, description="The context in which the operation was performed. Valid values include a reference to any array which is a member of the same fleet. If the array is not a member of a fleet, `context` will always implicitly be set to the array that received the request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")
    account: Optional[FixedReference] = None
    bucket_type: Optional[StrictStr] = Field(default=None, description="The bucket type for the bucket.")
    created: Optional[StrictInt] = Field(default=None, description="Creation timestamp of the object.")
    destroyed: Optional[StrictBool] = Field(default=None, description="Is the bucket destroyed?")
    eradication_config: Optional[BucketEradicationConfig] = None
    hard_limit_enabled: Optional[StrictBool] = Field(default=None, description="If set to `true`, the bucket's size, as defined by `quota_limit`, is used as a hard limit quota. If set to `false`, a hard limit quota will not be applied to the bucket, but soft quota alerts will still be sent if the bucket has a value set for `quota_limit`.")
    object_count: Optional[StrictInt] = Field(default=None, description="The count of objects within the bucket.")
    object_lock_config: Optional[ObjectLockConfigResponse] = None
    public_access_config: Optional[PublicAccessConfig] = None
    public_status: Optional[StrictStr] = Field(default=None, description="Bucket's public status. Valid values include `bucket-and-objects-not-public`, `only-authorized-users-of-this-account` and `public`.")
    quota_limit: Optional[StrictInt] = Field(default=None, description="The effective quota limit applied against the size of the bucket, displayed in bytes. If unset, the bucket is unlimited in size.")
    retention_lock: Optional[StrictStr] = Field(default=None, description="If set to `ratcheted`, then `object_lock_config.default_retention_mode` cannot be changed if set to `compliance`. In this case, the value of `object_lock_config.default_retention` can only be increased and `object_lock_config.default_retention_mode` cannot be changed once set to `compliance`. Valid values are `unlocked` and `ratcheted`. Contact Pure Technical Services to change `ratcheted` to `unlocked`.")
    space: Optional[Space] = Field(default=None, description="The space specification of the bucket.")
    time_remaining: Optional[StrictInt] = Field(default=None, description="Time in milliseconds before the bucket is eradicated. `null` if not destroyed or legal hold was found or the remaining time until eradication is not known yet.")
    time_remaining_status: Optional[StrictStr] = Field(default=None, description="Status of the `time_remaining` field. `calculating` means the bucket is `retention-based`, has been destroyed and the `time_remaining` is being calculated by a background process `legal-hold` means the bucket is `retention-based`, has been destroyed and will never be eradicated, because an object with legal hold status was found inside. null otherwise, i.e. when either the bucket is not destroyed or it's destroyed and the `time_remaining` has been determined.")
    versioning: Optional[StrictStr] = Field(default=None, description="The versioning state for objects within the bucket. Valid values are `none`, `enabled`, and `suspended`.")
    __properties = ["id", "name", "context", "account", "bucket_type", "created", "destroyed", "eradication_config", "hard_limit_enabled", "object_count", "object_lock_config", "public_access_config", "public_status", "quota_limit", "retention_lock", "space", "time_remaining", "time_remaining_status", "versioning"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.to_dict(include_readonly=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.as_request_dict())

    def as_request_dict(self) -> Dict[str, Any]:
        return self.to_dict(include_readonly=False)

    def to_dict(self, include_readonly: bool=True) -> Dict[str, Any]:

        """Returns the dictionary representation of the model using alias"""
        excluded_fields: Set[str] = set()
        if not include_readonly:
            excluded_fields.update([
                "id",
                "name",
                "context",
                "bucket_type",
                "created",
                "object_count",
                "public_status",
                "time_remaining",
                "time_remaining_status",
            ])
        none_fields: Set[str] = set()
        for _field in self.__fields__.keys():
            if super().__getattribute__(_field) is None:
                none_fields.add(_field)

        _dict = self.dict(by_alias=True, exclude=excluded_fields, exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of context
        if _include_in_dict('context', include_readonly, excluded_fields, none_fields):
            _dict['context'] = self.context.to_dict(include_readonly=include_readonly)
        # override the default output from pydantic by calling `to_dict()` of account
        if _include_in_dict('account', include_readonly, excluded_fields, none_fields):
            _dict['account'] = self.account.to_dict(include_readonly=include_readonly)
        # override the default output from pydantic by calling `to_dict()` of eradication_config
        if _include_in_dict('eradication_config', include_readonly, excluded_fields, none_fields):
            _dict['eradication_config'] = self.eradication_config.to_dict(include_readonly=include_readonly)
        # override the default output from pydantic by calling `to_dict()` of object_lock_config
        if _include_in_dict('object_lock_config', include_readonly, excluded_fields, none_fields):
            _dict['object_lock_config'] = self.object_lock_config.to_dict(include_readonly=include_readonly)
        # override the default output from pydantic by calling `to_dict()` of public_access_config
        if _include_in_dict('public_access_config', include_readonly, excluded_fields, none_fields):
            _dict['public_access_config'] = self.public_access_config.to_dict(include_readonly=include_readonly)
        # override the default output from pydantic by calling `to_dict()` of space
        if _include_in_dict('space', include_readonly, excluded_fields, none_fields):
            _dict['space'] = self.space.to_dict(include_readonly=include_readonly)
        return _dict

    def __getitem__(self, key):
        return super().__getattribute__(key)

    def __setitem__(self, key, value):
        setattr(self, key, value)

    def __delitem__(self, key):
        setattr(self, key, None)

    def __getattribute__(self, name: str) -> Any:
        _value = super().__getattribute__(name)
        if _value is None and name in self.__fields__.keys() and _should_raise_on_none():
            raise AttributeError
        return _value

    def __str__(self) -> str:
        return self.to_str()

    def __repr__(self) -> str:
        return self.to_str()

    @classmethod
    def from_json(cls, json_str: str) -> Bucket:
        """Create an instance of Bucket from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    @classmethod
    def from_dict(cls, obj: dict) -> Bucket:
        """Create an instance of Bucket from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return Bucket.parse_obj(obj)

        _obj = Bucket.construct(_fields_set=None, **{
            "id": obj.get("id"),
            "name": obj.get("name"),
            "context": Reference.from_dict(obj.get("context")) if obj.get("context") is not None else None,
            "account": FixedReference.from_dict(obj.get("account")) if obj.get("account") is not None else None,
            "bucket_type": obj.get("bucket_type"),
            "created": obj.get("created"),
            "destroyed": obj.get("destroyed"),
            "eradication_config": BucketEradicationConfig.from_dict(obj.get("eradication_config")) if obj.get("eradication_config") is not None else None,
            "hard_limit_enabled": obj.get("hard_limit_enabled"),
            "object_count": obj.get("object_count"),
            "object_lock_config": ObjectLockConfigResponse.from_dict(obj.get("object_lock_config")) if obj.get("object_lock_config") is not None else None,
            "public_access_config": PublicAccessConfig.from_dict(obj.get("public_access_config")) if obj.get("public_access_config") is not None else None,
            "public_status": obj.get("public_status"),
            "quota_limit": obj.get("quota_limit"),
            "retention_lock": obj.get("retention_lock"),
            "space": Space.from_dict(obj.get("space")) if obj.get("space") is not None else None,
            "time_remaining": obj.get("time_remaining"),
            "time_remaining_status": obj.get("time_remaining_status"),
            "versioning": obj.get("versioning")
        })
        return _obj

def _should_raise_on_none() -> bool:
    import importlib
    _package = importlib.import_module(__package__)
    return _package._attribute_error_on_none

def _include_in_dict(name: str, include_readonly: bool, excluded_fields: Set[str], none_fields: Set[str]) -> bool:
    if name in none_fields:
        return False
    return (include_readonly or name not in excluded_fields)


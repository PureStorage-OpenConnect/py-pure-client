
# coding: utf-8

"""
    FlashBlade REST API

    A lightweight client for FlashBlade REST API 2.17, developed by Pure Storage, Inc. (http://www.purestorage.com/).

    The version of the OpenAPI document: 2.17
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings


from typing_extensions import Annotated
from pydantic import Field, StrictBool, StrictInt, StrictStr, conint, conlist, constr, validator

from typing import Optional

from pypureclient.flashblade.FB_2_17.models.group_quota_get_response import GroupQuotaGetResponse
from pypureclient.flashblade.FB_2_17.models.group_quota_patch import GroupQuotaPatch
from pypureclient.flashblade.FB_2_17.models.group_quota_post import GroupQuotaPost
from pypureclient.flashblade.FB_2_17.models.group_quota_response import GroupQuotaResponse
from pypureclient.flashblade.FB_2_17.models.quota_setting import QuotaSetting
from pypureclient.flashblade.FB_2_17.models.quota_setting_get_response import QuotaSettingGetResponse
from pypureclient.flashblade.FB_2_17.models.quota_setting_response import QuotaSettingResponse
from pypureclient.flashblade.FB_2_17.models.user_quota_get_response import UserQuotaGetResponse
from pypureclient.flashblade.FB_2_17.models.user_quota_patch import UserQuotaPatch
from pypureclient.flashblade.FB_2_17.models.user_quota_post import UserQuotaPost
from pypureclient.flashblade.FB_2_17.models.user_quota_response import UserQuotaResponse
from typing import Optional
from pypureclient.flashblade.FB_2_17.api_client import ApiClient as _TransportApiClient
from pypureclient.flashblade.FB_2_17.api_response import ApiResponse
from pypureclient.flashblade.FB_2_17.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)
from pypureclient.reference_type import quoteStrings as quote_strings

class QuotasApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client: Optional[_TransportApiClient] = None) -> None:
        self.api_client = api_client if api_client else _TransportApiClient.get_default()

    def api217_quotas_groups_delete_with_http_info(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        gids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of group IDs. If there is not at least one resource that matches each of the elements of `gids`, then an error is returned. This cannot be provided together with `group_names` query parameter.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group names. If there is not at least one resource that matches each of the elements of `group_names`, then an error is returned. This cannot be provided together with `gids` query parameter.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        **kwargs
    ) -> ApiResponse:  # noqa: E501
        """DELETE quotas/groups

        Delete a hard limit quota for a group.

        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.
        :type context_names: List[str]
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.
        :type file_system_names: List[str]
        :param gids: A comma-separated list of group IDs. If there is not at least one resource that matches each of the elements of `gids`, then an error is returned. This cannot be provided together with `group_names` query parameter.
        :type gids: List[int]
        :param group_names: A comma-separated list of group names. If there is not at least one resource that matches each of the elements of `group_names`, then an error is returned. This cannot be provided together with `gids` query parameter.
        :type group_names: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'x_request_id',
            'context_names',
            'file_system_ids',
            'file_system_names',
            'gids',
            'group_names',
            'names'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api217_quotas_groups_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('context_names') is not None:  # noqa: E501
            _query_params.append(('context_names', _params['context_names']))
            _collection_formats['context_names'] = 'csv'

        if _params.get('file_system_ids') is not None:  # noqa: E501
            _query_params.append(('file_system_ids', _params['file_system_ids']))
            _collection_formats['file_system_ids'] = 'csv'

        if _params.get('file_system_names') is not None:  # noqa: E501
            _query_params.append(('file_system_names', _params['file_system_names']))
            _collection_formats['file_system_names'] = 'csv'

        if _params.get('gids') is not None:  # noqa: E501
            _query_params.append(('gids', _params['gids']))
            _collection_formats['gids'] = 'csv'

        if _params.get('group_names') is not None:  # noqa: E501
            _query_params.append(('group_names', _params['group_names']))
            _collection_formats['group_names'] = 'csv'

        if _params.get('names') is not None:  # noqa: E501
            _query_params.append(('names', _params['names']))
            _collection_formats['names'] = 'csv'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_request_id'] is not None:
            _header_params['X-Request-ID'] = _params['x_request_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['AuthorizationHeader']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/api/2.17/quotas/groups', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    def api217_quotas_groups_get_with_http_info(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        gids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of group IDs. If there is not at least one resource that matches each of the elements of `gids`, then an error is returned. This cannot be provided together with `group_names` query parameter.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group names. If there is not at least one resource that matches each of the elements of `group_names`, then an error is returned. This cannot be provided together with `gids` query parameter.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        **kwargs
    ) -> ApiResponse:  # noqa: E501
        """GET quotas/groups

        List groups with hard limit quotas.

        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.
        :type file_system_names: List[str]
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param gids: A comma-separated list of group IDs. If there is not at least one resource that matches each of the elements of `gids`, then an error is returned. This cannot be provided together with `group_names` query parameter.
        :type gids: List[int]
        :param group_names: A comma-separated list of group names. If there is not at least one resource that matches each of the elements of `group_names`, then an error is returned. This cannot be provided together with `gids` query parameter.
        :type group_names: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GroupQuotaGetResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'x_request_id',
            'allow_errors',
            'context_names',
            'continuation_token',
            'file_system_ids',
            'file_system_names',
            'filter',
            'gids',
            'group_names',
            'limit',
            'names',
            'offset',
            'sort'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api217_quotas_groups_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('allow_errors') is not None:  # noqa: E501
            _query_params.append(('allow_errors', _params['allow_errors']))

        if _params.get('context_names') is not None:  # noqa: E501
            _query_params.append(('context_names', _params['context_names']))
            _collection_formats['context_names'] = 'csv'

        if _params.get('continuation_token') is not None:  # noqa: E501
            _query_params.append(('continuation_token', _params['continuation_token']))

        if _params.get('file_system_ids') is not None:  # noqa: E501
            _query_params.append(('file_system_ids', _params['file_system_ids']))
            _collection_formats['file_system_ids'] = 'csv'

        if _params.get('file_system_names') is not None:  # noqa: E501
            _query_params.append(('file_system_names', _params['file_system_names']))
            _collection_formats['file_system_names'] = 'csv'

        if _params.get('filter') is not None:  # noqa: E501
            _query_params.append(('filter', _params['filter']))

        if _params.get('gids') is not None:  # noqa: E501
            _query_params.append(('gids', _params['gids']))
            _collection_formats['gids'] = 'csv'

        if _params.get('group_names') is not None:  # noqa: E501
            _query_params.append(('group_names', _params['group_names']))
            _collection_formats['group_names'] = 'csv'

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('names') is not None:  # noqa: E501
            _query_params.append(('names', _params['names']))
            _collection_formats['names'] = 'csv'

        if _params.get('offset') is not None:  # noqa: E501
            _query_params.append(('offset', _params['offset']))

        if _params.get('sort') is not None:  # noqa: E501
            _query_params.append(('sort', _params['sort']))
            _collection_formats['sort'] = 'csv'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_request_id'] is not None:
            _header_params['X-Request-ID'] = _params['x_request_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['AuthorizationHeader']  # noqa: E501

        _response_types_map = {
            '200': "GroupQuotaGetResponse",
        }

        return self.api_client.call_api(
            '/api/2.17/quotas/groups', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    def api217_quotas_groups_patch_with_http_info(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        gids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of group IDs. If there is not at least one resource that matches each of the elements of `gids`, then an error is returned. This cannot be provided together with `group_names` query parameter.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group names. If there is not at least one resource that matches each of the elements of `group_names`, then an error is returned. This cannot be provided together with `gids` query parameter.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        quota: Optional[GroupQuotaPatch] = None,
        **kwargs
    ) -> ApiResponse:  # noqa: E501
        """PATCH quotas/groups

        Modify a quota for a group. Note that if you modify a group's quota to a lower value and that group's usage has already exceeded the new value, writes will automatically halt until usage decreases below the new quota setting.

        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.
        :type context_names: List[str]
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.
        :type file_system_names: List[str]
        :param gids: A comma-separated list of group IDs. If there is not at least one resource that matches each of the elements of `gids`, then an error is returned. This cannot be provided together with `group_names` query parameter.
        :type gids: List[int]
        :param group_names: A comma-separated list of group names. If there is not at least one resource that matches each of the elements of `group_names`, then an error is returned. This cannot be provided together with `gids` query parameter.
        :type group_names: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param quota:
        :type quota: GroupQuotaPatch
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GroupQuotaResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'x_request_id',
            'context_names',
            'file_system_ids',
            'file_system_names',
            'gids',
            'group_names',
            'names',
            'quota'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api217_quotas_groups_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('context_names') is not None:  # noqa: E501
            _query_params.append(('context_names', _params['context_names']))
            _collection_formats['context_names'] = 'csv'

        if _params.get('file_system_ids') is not None:  # noqa: E501
            _query_params.append(('file_system_ids', _params['file_system_ids']))
            _collection_formats['file_system_ids'] = 'csv'

        if _params.get('file_system_names') is not None:  # noqa: E501
            _query_params.append(('file_system_names', _params['file_system_names']))
            _collection_formats['file_system_names'] = 'csv'

        if _params.get('gids') is not None:  # noqa: E501
            _query_params.append(('gids', _params['gids']))
            _collection_formats['gids'] = 'csv'

        if _params.get('group_names') is not None:  # noqa: E501
            _query_params.append(('group_names', _params['group_names']))
            _collection_formats['group_names'] = 'csv'

        if _params.get('names') is not None:  # noqa: E501
            _query_params.append(('names', _params['names']))
            _collection_formats['names'] = 'csv'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_request_id'] is not None:
            _header_params['X-Request-ID'] = _params['x_request_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['quota'] is not None:
            _body_params = _params['quota']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['AuthorizationHeader']  # noqa: E501

        _response_types_map = {
            '200': "GroupQuotaResponse",
        }

        return self.api_client.call_api(
            '/api/2.17/quotas/groups', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    def api217_quotas_groups_post_with_http_info(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        gids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of group IDs. If there is not at least one resource that matches each of the elements of `gids`, then an error is returned. This cannot be provided together with `group_names` query parameter.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group names. If there is not at least one resource that matches each of the elements of `group_names`, then an error is returned. This cannot be provided together with `gids` query parameter.")] = None,
        quota: Optional[GroupQuotaPost] = None,
        **kwargs
    ) -> ApiResponse:  # noqa: E501
        """POST quotas/groups

        Create a hard limit quota for a group.

        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.
        :type context_names: List[str]
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.
        :type file_system_names: List[str]
        :param gids: A comma-separated list of group IDs. If there is not at least one resource that matches each of the elements of `gids`, then an error is returned. This cannot be provided together with `group_names` query parameter.
        :type gids: List[int]
        :param group_names: A comma-separated list of group names. If there is not at least one resource that matches each of the elements of `group_names`, then an error is returned. This cannot be provided together with `gids` query parameter.
        :type group_names: List[str]
        :param quota:
        :type quota: GroupQuotaPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GroupQuotaResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'x_request_id',
            'context_names',
            'file_system_ids',
            'file_system_names',
            'gids',
            'group_names',
            'quota'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api217_quotas_groups_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('context_names') is not None:  # noqa: E501
            _query_params.append(('context_names', _params['context_names']))
            _collection_formats['context_names'] = 'csv'

        if _params.get('file_system_ids') is not None:  # noqa: E501
            _query_params.append(('file_system_ids', _params['file_system_ids']))
            _collection_formats['file_system_ids'] = 'csv'

        if _params.get('file_system_names') is not None:  # noqa: E501
            _query_params.append(('file_system_names', _params['file_system_names']))
            _collection_formats['file_system_names'] = 'csv'

        if _params.get('gids') is not None:  # noqa: E501
            _query_params.append(('gids', _params['gids']))
            _collection_formats['gids'] = 'csv'

        if _params.get('group_names') is not None:  # noqa: E501
            _query_params.append(('group_names', _params['group_names']))
            _collection_formats['group_names'] = 'csv'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_request_id'] is not None:
            _header_params['X-Request-ID'] = _params['x_request_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['quota'] is not None:
            _body_params = _params['quota']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['AuthorizationHeader']  # noqa: E501

        _response_types_map = {
            '200': "GroupQuotaResponse",
        }

        return self.api_client.call_api(
            '/api/2.17/quotas/groups', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    def api217_quotas_settings_get_with_http_info(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        **kwargs
    ) -> ApiResponse:  # noqa: E501
        """GET quotas-settings

        List notification attributes of a group or user quota.

        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(QuotaSettingGetResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'x_request_id',
            'ids',
            'names'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api217_quotas_settings_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('ids') is not None:  # noqa: E501
            _query_params.append(('ids', _params['ids']))
            _collection_formats['ids'] = 'csv'

        if _params.get('names') is not None:  # noqa: E501
            _query_params.append(('names', _params['names']))
            _collection_formats['names'] = 'csv'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_request_id'] is not None:
            _header_params['X-Request-ID'] = _params['x_request_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['AuthorizationHeader']  # noqa: E501

        _response_types_map = {
            '200': "QuotaSettingGetResponse",
        }

        return self.api_client.call_api(
            '/api/2.17/quotas/settings', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    def api217_quotas_settings_patch_with_http_info(
        self,
        quota_setting: QuotaSetting,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        **kwargs
    ) -> ApiResponse:  # noqa: E501
        """PATCH quotas-settings

        Modify the notification attributes of a group or user quota.

        :param quota_setting: (required)
        :type quota_setting: QuotaSetting
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(QuotaSettingResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'quota_setting',
            'x_request_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api217_quotas_settings_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_request_id'] is not None:
            _header_params['X-Request-ID'] = _params['x_request_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['quota_setting'] is not None:
            _body_params = _params['quota_setting']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['AuthorizationHeader']  # noqa: E501

        _response_types_map = {
            '200': "QuotaSettingResponse",
        }

        return self.api_client.call_api(
            '/api/2.17/quotas/settings', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    def api217_quotas_users_delete_with_http_info(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        uids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of user IDs. If there is not at least one resource that matches each of the elements of `uids`, then an error is returned. This cannot be provided together with `user_names` query parameter.")] = None,
        user_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of user names. If there is not at least one resource that matches each of the elements of `user_names`, then an error is returned. This cannot be provided together with `uids` query parameter.")] = None,
        **kwargs
    ) -> ApiResponse:  # noqa: E501
        """DELETE quotas/users

        Delete a hard limit file system quota for a user.

        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.
        :type context_names: List[str]
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.
        :type file_system_names: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param uids: A comma-separated list of user IDs. If there is not at least one resource that matches each of the elements of `uids`, then an error is returned. This cannot be provided together with `user_names` query parameter.
        :type uids: List[int]
        :param user_names: A comma-separated list of user names. If there is not at least one resource that matches each of the elements of `user_names`, then an error is returned. This cannot be provided together with `uids` query parameter.
        :type user_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'x_request_id',
            'context_names',
            'file_system_ids',
            'file_system_names',
            'names',
            'uids',
            'user_names'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api217_quotas_users_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('context_names') is not None:  # noqa: E501
            _query_params.append(('context_names', _params['context_names']))
            _collection_formats['context_names'] = 'csv'

        if _params.get('file_system_ids') is not None:  # noqa: E501
            _query_params.append(('file_system_ids', _params['file_system_ids']))
            _collection_formats['file_system_ids'] = 'csv'

        if _params.get('file_system_names') is not None:  # noqa: E501
            _query_params.append(('file_system_names', _params['file_system_names']))
            _collection_formats['file_system_names'] = 'csv'

        if _params.get('names') is not None:  # noqa: E501
            _query_params.append(('names', _params['names']))
            _collection_formats['names'] = 'csv'

        if _params.get('uids') is not None:  # noqa: E501
            _query_params.append(('uids', _params['uids']))
            _collection_formats['uids'] = 'csv'

        if _params.get('user_names') is not None:  # noqa: E501
            _query_params.append(('user_names', _params['user_names']))
            _collection_formats['user_names'] = 'csv'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_request_id'] is not None:
            _header_params['X-Request-ID'] = _params['x_request_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = ['AuthorizationHeader']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/api/2.17/quotas/users', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    def api217_quotas_users_get_with_http_info(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        uids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of user IDs. If there is not at least one resource that matches each of the elements of `uids`, then an error is returned. This cannot be provided together with `user_names` query parameter.")] = None,
        user_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of user names. If there is not at least one resource that matches each of the elements of `user_names`, then an error is returned. This cannot be provided together with `uids` query parameter.")] = None,
        **kwargs
    ) -> ApiResponse:  # noqa: E501
        """GET quotas/users

        List users with hard limit file system quotas.

        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.
        :type file_system_names: List[str]
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param uids: A comma-separated list of user IDs. If there is not at least one resource that matches each of the elements of `uids`, then an error is returned. This cannot be provided together with `user_names` query parameter.
        :type uids: List[int]
        :param user_names: A comma-separated list of user names. If there is not at least one resource that matches each of the elements of `user_names`, then an error is returned. This cannot be provided together with `uids` query parameter.
        :type user_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserQuotaGetResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'x_request_id',
            'allow_errors',
            'context_names',
            'continuation_token',
            'file_system_ids',
            'file_system_names',
            'filter',
            'limit',
            'names',
            'offset',
            'sort',
            'uids',
            'user_names'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api217_quotas_users_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('allow_errors') is not None:  # noqa: E501
            _query_params.append(('allow_errors', _params['allow_errors']))

        if _params.get('context_names') is not None:  # noqa: E501
            _query_params.append(('context_names', _params['context_names']))
            _collection_formats['context_names'] = 'csv'

        if _params.get('continuation_token') is not None:  # noqa: E501
            _query_params.append(('continuation_token', _params['continuation_token']))

        if _params.get('file_system_ids') is not None:  # noqa: E501
            _query_params.append(('file_system_ids', _params['file_system_ids']))
            _collection_formats['file_system_ids'] = 'csv'

        if _params.get('file_system_names') is not None:  # noqa: E501
            _query_params.append(('file_system_names', _params['file_system_names']))
            _collection_formats['file_system_names'] = 'csv'

        if _params.get('filter') is not None:  # noqa: E501
            _query_params.append(('filter', _params['filter']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('names') is not None:  # noqa: E501
            _query_params.append(('names', _params['names']))
            _collection_formats['names'] = 'csv'

        if _params.get('offset') is not None:  # noqa: E501
            _query_params.append(('offset', _params['offset']))

        if _params.get('sort') is not None:  # noqa: E501
            _query_params.append(('sort', _params['sort']))
            _collection_formats['sort'] = 'csv'

        if _params.get('uids') is not None:  # noqa: E501
            _query_params.append(('uids', _params['uids']))
            _collection_formats['uids'] = 'csv'

        if _params.get('user_names') is not None:  # noqa: E501
            _query_params.append(('user_names', _params['user_names']))
            _collection_formats['user_names'] = 'csv'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_request_id'] is not None:
            _header_params['X-Request-ID'] = _params['x_request_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['AuthorizationHeader']  # noqa: E501

        _response_types_map = {
            '200': "UserQuotaGetResponse",
        }

        return self.api_client.call_api(
            '/api/2.17/quotas/users', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    def api217_quotas_users_patch_with_http_info(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        uids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of user IDs. If there is not at least one resource that matches each of the elements of `uids`, then an error is returned. This cannot be provided together with `user_names` query parameter.")] = None,
        user_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of user names. If there is not at least one resource that matches each of the elements of `user_names`, then an error is returned. This cannot be provided together with `uids` query parameter.")] = None,
        quota: Optional[UserQuotaPatch] = None,
        **kwargs
    ) -> ApiResponse:  # noqa: E501
        """PATCH quotas/users

        Modify the attributes of a hard limit file system quota. Note that if you modify a user's quota to a lower value and that user’s usage has already exceeded the new value, writes will automatically halt until usage decreases below the new quota setting.

        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.
        :type context_names: List[str]
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.
        :type file_system_names: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param uids: A comma-separated list of user IDs. If there is not at least one resource that matches each of the elements of `uids`, then an error is returned. This cannot be provided together with `user_names` query parameter.
        :type uids: List[int]
        :param user_names: A comma-separated list of user names. If there is not at least one resource that matches each of the elements of `user_names`, then an error is returned. This cannot be provided together with `uids` query parameter.
        :type user_names: List[str]
        :param quota:
        :type quota: UserQuotaPatch
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserQuotaResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'x_request_id',
            'context_names',
            'file_system_ids',
            'file_system_names',
            'names',
            'uids',
            'user_names',
            'quota'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api217_quotas_users_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('context_names') is not None:  # noqa: E501
            _query_params.append(('context_names', _params['context_names']))
            _collection_formats['context_names'] = 'csv'

        if _params.get('file_system_ids') is not None:  # noqa: E501
            _query_params.append(('file_system_ids', _params['file_system_ids']))
            _collection_formats['file_system_ids'] = 'csv'

        if _params.get('file_system_names') is not None:  # noqa: E501
            _query_params.append(('file_system_names', _params['file_system_names']))
            _collection_formats['file_system_names'] = 'csv'

        if _params.get('names') is not None:  # noqa: E501
            _query_params.append(('names', _params['names']))
            _collection_formats['names'] = 'csv'

        if _params.get('uids') is not None:  # noqa: E501
            _query_params.append(('uids', _params['uids']))
            _collection_formats['uids'] = 'csv'

        if _params.get('user_names') is not None:  # noqa: E501
            _query_params.append(('user_names', _params['user_names']))
            _collection_formats['user_names'] = 'csv'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_request_id'] is not None:
            _header_params['X-Request-ID'] = _params['x_request_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['quota'] is not None:
            _body_params = _params['quota']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['AuthorizationHeader']  # noqa: E501

        _response_types_map = {
            '200': "UserQuotaResponse",
        }

        return self.api_client.call_api(
            '/api/2.17/quotas/users', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    def api217_quotas_users_post_with_http_info(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        uids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of user IDs. If there is not at least one resource that matches each of the elements of `uids`, then an error is returned. This cannot be provided together with `user_names` query parameter.")] = None,
        user_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of user names. If there is not at least one resource that matches each of the elements of `user_names`, then an error is returned. This cannot be provided together with `uids` query parameter.")] = None,
        quota: Optional[UserQuotaPost] = None,
        **kwargs
    ) -> ApiResponse:  # noqa: E501
        """POST quotas/users

        Create a hard limit file system quota for a user.

        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.
        :type context_names: List[str]
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.
        :type file_system_names: List[str]
        :param uids: A comma-separated list of user IDs. If there is not at least one resource that matches each of the elements of `uids`, then an error is returned. This cannot be provided together with `user_names` query parameter.
        :type uids: List[int]
        :param user_names: A comma-separated list of user names. If there is not at least one resource that matches each of the elements of `user_names`, then an error is returned. This cannot be provided together with `uids` query parameter.
        :type user_names: List[str]
        :param quota:
        :type quota: UserQuotaPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UserQuotaResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'x_request_id',
            'context_names',
            'file_system_ids',
            'file_system_names',
            'uids',
            'user_names',
            'quota'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api217_quotas_users_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('context_names') is not None:  # noqa: E501
            _query_params.append(('context_names', _params['context_names']))
            _collection_formats['context_names'] = 'csv'

        if _params.get('file_system_ids') is not None:  # noqa: E501
            _query_params.append(('file_system_ids', _params['file_system_ids']))
            _collection_formats['file_system_ids'] = 'csv'

        if _params.get('file_system_names') is not None:  # noqa: E501
            _query_params.append(('file_system_names', _params['file_system_names']))
            _collection_formats['file_system_names'] = 'csv'

        if _params.get('uids') is not None:  # noqa: E501
            _query_params.append(('uids', _params['uids']))
            _collection_formats['uids'] = 'csv'

        if _params.get('user_names') is not None:  # noqa: E501
            _query_params.append(('user_names', _params['user_names']))
            _collection_formats['user_names'] = 'csv'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_request_id'] is not None:
            _header_params['X-Request-ID'] = _params['x_request_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['quota'] is not None:
            _body_params = _params['quota']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['AuthorizationHeader']  # noqa: E501

        _response_types_map = {
            '200': "UserQuotaResponse",
        }

        return self.api_client.call_api(
            '/api/2.17/quotas/users', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

import json
import ssl
import time
import urllib3
import uuid
import warnings
import os
import re
import tempfile

from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

try:
    from pydantic.v1 import Field, StrictBool, StrictFloat, StrictInt, StrictStr, conint, conlist, constr, validator
except ModuleNotFoundError:
    from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, conint, conlist, constr, validator


from pypureclient.reference_type import ReferenceType
from pypureclient.api_token_manager import APITokenManager
from pypureclient.exceptions import PureError
from pypureclient.keywords import Headers, Responses
from pypureclient.properties import Property, Filter
from pypureclient.responses import ValidResponse, ErrorResponse, ApiError, ItemIterator, ResponseHeaders
from pypureclient.token_manager import TokenManager

from pypureclient._helpers import create_api_client

from pypureclient._transport.api_client import ApiClient
from pypureclient._transport.api_response import ApiResponse
from pypureclient._transport.rest import ApiException
from pypureclient._transport.configuration import Configuration

from . import api
from . import models


class Client(object):

    def __init__(self,
                 configuration: Configuration,
                 id_token: str = None,
                 private_key_file: str = None,
                 private_key_password: str = None,
                 username: str = None,
                 client_id: str = None,
                 key_id: str = None,
                 issuer: str = None,
                 api_token: str = None,
                 retries: int = None,
                 timeout: Union[int, Tuple[float, float]] = None,
                 user_agent = None):
        """
        Initialize a FlashBlade Client. id_token is generated based on app ID and private
        key info. Either id_token or api_token could be used for authentication. Only one
        authentication option is allowed.

        :param configuration: configuration object
        :type configuration: Configuration

        :param id_token: The security token that represents the identity of the party on
            behalf of whom the request is being made, issued by an enabled
            API client on the array. Overrides given private key.
        :type id_token: str, optional

        :param private_key_file: The path of the private key to use. Defaults to None.
        :type private_key_file: str, optional

        :param private_key_password: The password of the private key. Defaults to None.
        :type private_key_password: str, optional

        :param username: Username of the user the token should be issued for. This must
            be a valid user in the system.
        :type username: str, optional

        :param client_id: ID of API client that issued the identity token.
        :type client_id: str, optional

        :param key_id: Key ID of API client that issued the identity token.
        :type key_id: str, optional

        :param issuer: API client's trusted identity issuer on the array.
        :type issuer: str, optional

        :param api_token: API token for the user.
        :type api_token: str, optional

        :param retries: The number of times to retry an API call if it fails for a
            non-blocking reason
        :type retries: int, optional

        :param timeout: The timeout duration in seconds, either in total time or
            (connect and read) times. Defaults to None.
        :type timeout: int or (float, float), optional

        :param user_agent: User-Agent request header to use.
        :type user_agent: str, optional

        :raises PureError: If it could not create an ID or access token
        """

        if id_token and api_token:
            raise PureError("Only one authentication option is allowed. Please use either id_token or api_token and try again!")
        elif private_key_file and private_key_password and username and \
                key_id and client_id and issuer and api_token:
            raise PureError("id_token is generated based on app ID and private key info. Please use either id_token or api_token and try again!")
        elif api_token:
            self._token_man = APITokenManager(
                api_token=api_token,
                user_agent=user_agent,
                timeout=timeout,
                configuration=configuration
            )
        else:
            headers = {
                'kid': key_id
            }
            payload = {
                'iss': issuer,
                'aud': client_id,
                'sub': username,
            }
            self._token_man = TokenManager(configuration=configuration,
                                           id_token=id_token,
                                           private_key_file=private_key_file,
                                           private_key_password=private_key_password,
                                           payload=payload,
                                           headers=headers,
                                           timeout=timeout,
                                           user_agent=user_agent)

        self._api_client = create_api_client(configuration=configuration, user_agent=user_agent, _models_package=models)
        self._set_auth_header()

        # Read timeout and retries
        self._retries = retries
        self._timeout = timeout
        self.__apis_instances = {
            'AuthorizationApi': api.AuthorizationApi(self._api_client)
        }

    def __del__(self):
        # Cleanup this REST API client resources
        _api_client_attr = getattr(self, '_api_client', None) # using getattr to avoid raising exception, if we failed too early
        if _api_client_attr:
            _api_client_attr.close()

    def get_access_token(self, refresh=False):
        """
        Get the last used access token.

        Args:
            refresh (bool, optional):
                Whether to retrieve a new access token. Defaults to False.

        Returns:
            str

        Raises:
            PureError: If there was an error retrieving an access token.
        """
        return self._token_man.get_access_token(refresh)

    def disable_verify_ssl(self):
        """ Change our certificate requirements so that a certificate is not validated. """
        self._api_client.rest_client.pool_manager.connection_pool_kw['cert_reqs'] = ssl.CERT_NONE

    def enable_verify_ssl(self, ca_certs_file_path=None):
        """ Change our certificate requirements so that a certificate is required and validated.
        Optionally, if a CA certificate(s) file path is provided, configure the client to use
        that CA certificate file.
        """
        if ca_certs_file_path:
            self.configure_ca_certificate_file(ca_certs_file_path)
        self._api_client.rest_client.pool_manager.connection_pool_kw['cert_reqs'] = ssl.CERT_REQUIRED

    def configure_ca_certificate_file(self, ca_certs_file_path):
        """"
        :param ca_certs_file_path: The path to the CA certificate(s) file to use.
        :return:
        """
        self._api_client.rest_client.pool_manager.connection_pool_kw['ca_certs'] = ca_certs_file_path

    def delete_api_clients(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE api-clients
        
        Delete the API client.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('APIClientsApi', 'api217_api_clients_delete_with_http_info', kwargs)

    def get_api_clients(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET api-clients
        
        List an API client and its configuration attributes.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('APIClientsApi', 'api217_api_clients_get_with_http_info', kwargs)

    def patch_api_clients(
        self,
        api_clients: 'models.ApiClient',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH api-clients
        
        Modify an API client. Newly created API clients can be enabled by setting the `enabled` parameter to `true`.
        
        :param api_clients: (required)
        :type api_clients: ApiClient
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            api_clients=api_clients,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('APIClientsApi', 'api217_api_clients_patch_with_http_info', kwargs)

    def post_api_clients(
        self,
        api_client: 'models.ApiClientsPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST api-clients
        
        Create an API client to authorize Access Token or Bearer Tokens for use on the array. Required fields include `issuer`, `public_key`, and `access_token_ttl_in_ms`. After creating an API client, it can only be enabled by an authorized user.
        
        :param api_client: (required)
        :type api_client: ApiClientsPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            api_client=api_client,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('APIClientsApi', 'api217_api_clients_post_with_http_info', kwargs)

    def delete_active_directory(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        local_only: Annotated[Optional[StrictBool], Field(description="If specified as `true`, only delete the Active Directory configuration on the local array, without deleting the computer account created in the Active Directory domain. If not specified, defaults to `false`.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE active-directory
        
        Delete an Active Directory account.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param local_only: If specified as `true`, only delete the Active Directory configuration on the
                        local array, without deleting the computer account created in the Active
                        Directory domain. If not specified, defaults to `false`.
        :type local_only: bool
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            local_only=local_only,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('ActiveDirectoryApi', 'api217_active_directory_delete_with_http_info', kwargs)

    def get_active_directory(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET active-directory
        
        List Active Directory accounts and their configuration.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('ActiveDirectoryApi', 'api217_active_directory_get_with_http_info', kwargs)

    def patch_active_directory(
        self,
        active_directory: 'models.ActiveDirectoryPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH active-directory
        
        Modify the configuration of an Active Directory account.
        
        :param active_directory: (required)
        :type active_directory: ActiveDirectoryPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            active_directory=active_directory,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('ActiveDirectoryApi', 'api217_active_directory_patch_with_http_info', kwargs)

    def post_active_directory(
        self,
        active_directory: 'models.ActiveDirectoryPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        join_existing_account: Annotated[Optional[StrictBool], Field(description="If specified as `true`, the domain is searched for a pre-existing computer account to join to, and no new account will be created within the domain. The `user` specified when joining to a pre-existing account must have permissions to 'read attributes from' and 'reset the password of' the pre-existing account. `service_principal_names`, `encryption_types`, and `join_ou` will be read from the pre-existing account and cannot be specified when joining to an existing account. If not specified, defaults to `false`.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST active-directory
        
        Join an Active Directory domain and generate keytabs for the registered SPNs and supported encryption types.
        
        :param active_directory: (required)
        :type active_directory: ActiveDirectoryPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param join_existing_account: If specified as `true`, the domain is searched for a pre-existing computer
                                    account to join to, and no new account will be created within the domain.
                                    The `user` specified when joining to a pre-existing account must have
                                    permissions to 'read attributes from' and 'reset the password of' the
                                    pre-existing account. `service_principal_names`, `encryption_types`, and
                                    `join_ou` will be read from the pre-existing account and cannot be
                                    specified when joining to an existing account. If not specified, defaults
                                    to `false`.
        :type join_existing_account: bool
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            active_directory=active_directory,
            x_request_id=x_request_id,
            join_existing_account=join_existing_account,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('ActiveDirectoryApi', 'api217_active_directory_post_with_http_info', kwargs)

    def get_active_directory_test(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET active-directory/test
        
        Testing if the configuration of an Active Directory account is valid.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('ActiveDirectoryApi', 'api217_active_directory_test_get_with_http_info', kwargs)

    def delete_admins_api_tokens(
        self,
        admins: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        admin_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of admin IDs. If after filtering, there is not at least one admin resource that matches each of the elements, then an error is returned. This cannot be provided together with the `admin_names` query parameter.")] = None,
        admin_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of admin names. If there is not at least one admin resource that matches each of the elements, then an error is returned. This cannot be provided together with `admin_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE admins/api-tokens
        
        Deletes the API tokens of the specified administrators.
        
        :param admins: A list of admins to query for. Overrides admin_ids and admin_names keyword arguments.
        :type admins: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param admin_ids: A comma-separated list of admin IDs. If after filtering, there is not at least
                        one admin resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `admin_names` query
                        parameter.
        :type admin_ids: List[str]
        :param admin_names: A comma-separated list of admin names. If there is not at least one admin
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `admin_ids` query parameter.
        :type admin_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            admin_ids=admin_ids,
            admin_names=admin_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(admins, ['admin_ids', 'admin_names'], kwargs)
        _fixup_list_type_params(['admin_ids', 'admin_names'], kwargs)
        return self._call_api('AdministratorsApi', 'api217_admins_api_tokens_delete_with_http_info', kwargs)

    def get_admins_api_tokens(
        self,
        admins: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        admin_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of admin IDs. If after filtering, there is not at least one admin resource that matches each of the elements, then an error is returned. This cannot be provided together with the `admin_names` query parameter.")] = None,
        admin_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of admin names. If there is not at least one admin resource that matches each of the elements, then an error is returned. This cannot be provided together with `admin_ids` query parameter.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        expose_api_token: Annotated[Optional[StrictBool], Field(description="If `true`, exposes the API token of the current user.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET admins/api-tokens
        
        Displays API tokens for the specified administrators.
        
        :param admins: A list of admins to query for. Overrides admin_ids and admin_names keyword arguments.
        :type admins: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param admin_ids: A comma-separated list of admin IDs. If after filtering, there is not at least
                        one admin resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `admin_names` query
                        parameter.
        :type admin_ids: List[str]
        :param admin_names: A comma-separated list of admin names. If there is not at least one admin
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `admin_ids` query parameter.
        :type admin_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param expose_api_token: If `true`, exposes the API token of the current user.
        :type expose_api_token: bool
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            admin_ids=admin_ids,
            admin_names=admin_names,
            continuation_token=continuation_token,
            expose_api_token=expose_api_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(admins, ['admin_ids', 'admin_names'], kwargs)
        _fixup_list_type_params(['admin_ids', 'admin_names', 'sort'], kwargs)
        return self._call_api('AdministratorsApi', 'api217_admins_api_tokens_get_with_http_info', kwargs)

    def post_admins_api_tokens(
        self,
        admins: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        admin_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of admin IDs. If after filtering, there is not at least one admin resource that matches each of the elements, then an error is returned. This cannot be provided together with the `admin_names` query parameter.")] = None,
        admin_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of admin names. If there is not at least one admin resource that matches each of the elements, then an error is returned. This cannot be provided together with `admin_ids` query parameter.")] = None,
        timeout: Annotated[Optional[StrictInt], Field(description="The duration of API token validity, in milliseconds.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST admins/api-tokens
        
        Creates API tokens for the specified administrators.
        
        :param admins: A list of admins to query for. Overrides admin_ids and admin_names keyword arguments.
        :type admins: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param admin_ids: A comma-separated list of admin IDs. If after filtering, there is not at least
                        one admin resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `admin_names` query
                        parameter.
        :type admin_ids: List[str]
        :param admin_names: A comma-separated list of admin names. If there is not at least one admin
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `admin_ids` query parameter.
        :type admin_names: List[str]
        :param timeout: The duration of API token validity, in milliseconds.
        :type timeout: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            admin_ids=admin_ids,
            admin_names=admin_names,
            timeout=timeout,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(admins, ['admin_ids', 'admin_names'], kwargs)
        _fixup_list_type_params(['admin_ids', 'admin_names'], kwargs)
        return self._call_api('AdministratorsApi', 'api217_admins_api_tokens_post_with_http_info', kwargs)

    def delete_admins_cache(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE admins/cache
        
        Delete cached administrator role information by name or ID.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('AdministratorsApi', 'api217_admins_cache_delete_with_http_info', kwargs)

    def get_admins_cache(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        refresh: Annotated[Optional[StrictBool], Field(description="Whether to refresh the user info from directory service. If not specified, defaults to `false`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET admins/cache
        
        List cached administrator information used to determine role based access control privileges.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param refresh: Whether to refresh the user info from directory service. If not specified,
                        defaults to `false`.
        :type refresh: bool
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            refresh=refresh,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('AdministratorsApi', 'api217_admins_cache_get_with_http_info', kwargs)

    def delete_admins(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE admins
        
        Delete a local administrator..
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('AdministratorsApi', 'api217_admins_delete_with_http_info', kwargs)

    def get_admins(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        expose_api_token: Annotated[Optional[StrictBool], Field(description="If `true`, exposes the API token of the current user.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET admins
        
        List the administrator's attributes, including the API token and public key.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param expose_api_token: If `true`, exposes the API token of the current user.
        :type expose_api_token: bool
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            expose_api_token=expose_api_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('AdministratorsApi', 'api217_admins_get_with_http_info', kwargs)

    def patch_admins(
        self,
        admin: 'models.AdminPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH admins
        
        Modify the attributes of an administrator.
        
        :param admin: (required)
        :type admin: AdminPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            admin=admin,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('AdministratorsApi', 'api217_admins_patch_with_http_info', kwargs)

    def post_admins(
        self,
        admin: 'models.AdminPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST admins
        
        Create a new local administrator.
        
        :param admin: (required)
        :type admin: AdminPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            admin=admin,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('AdministratorsApi', 'api217_admins_post_with_http_info', kwargs)

    def get_admins_settings(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List global admin settings
        
        Return global admin settings.
        
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('AdministratorsApi', 'api217_admins_settings_get_with_http_info', kwargs)

    def patch_admins_settings(
        self,
        admin_setting: 'models.AdminSetting',
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Update global admin settings
        
        Update properties for global admin settings.
        
        :param admin_setting: (required)
        :type admin_setting: AdminSetting
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            admin_setting=admin_setting,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('AdministratorsApi', 'api217_admins_settings_patch_with_http_info', kwargs)

    def delete_alert_watchers(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE alert-watchers
        
        Delete an alert watcher.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('AlertWatchersApi', 'api217_alert_watchers_delete_with_http_info', kwargs)

    def get_alert_watchers(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET alert-watchers
        
        List alert watchers that are configured to receive alert messages.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('AlertWatchersApi', 'api217_alert_watchers_get_with_http_info', kwargs)

    def patch_alert_watchers(
        self,
        alert_watcher: 'models.AlertWatcher',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH alert-watchers
        
        Modify an alert watchers configuration. Enable or disable an alert watcher privilege and select the level of alert notification of an alert watcher. Alert notification levels are `info`, `warning`, or `critical`.
        
        :param alert_watcher: (required)
        :type alert_watcher: AlertWatcher
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            alert_watcher=alert_watcher,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('AlertWatchersApi', 'api217_alert_watchers_patch_with_http_info', kwargs)

    def post_alert_watchers(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        alert_watcher: Optional['models.AlertWatcherPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST alert-watchers
        
        Create an alert watcher to receive array alert messages.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param alert_watcher:
        :type alert_watcher: AlertWatcherPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            x_request_id=x_request_id,
            alert_watcher=alert_watcher,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('AlertWatchersApi', 'api217_alert_watchers_post_with_http_info', kwargs)

    def get_alert_watchers_test(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET alert-watchers/test
        
        Test an alert watcher's contact information to verify alerts can be sent and received.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            names=names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('AlertWatchersApi', 'api217_alert_watchers_test_get_with_http_info', kwargs)

    def get_alerts(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET alerts
        
        Returns a list of alerts which have been generated by the array.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('AlertsApi', 'api217_alerts_get_with_http_info', kwargs)

    def patch_alerts(
        self,
        alerts_settings: 'models.Alert',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH alerts
        
        Make changes to an alert. This is currently limited to the alert's `flagged` property.
        
        :param alerts_settings: (required)
        :type alerts_settings: Alert
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            alerts_settings=alerts_settings,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('AlertsApi', 'api217_alerts_patch_with_http_info', kwargs)

    def get_array_connections_connection_key(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET array-connections/connection-key
        
        List connection keys used to authenticate the connection from one array to another.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api217_array_connections_connection_key_get_with_http_info', kwargs)

    def post_array_connections_connection_key(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST array-connections/connection-key
        
        Create an array connection key allowing one array to connect to another for replication.
        
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api217_array_connections_connection_key_post_with_http_info', kwargs)

    def delete_array_connections(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. Deprecated, best practice is to reference connections with `ids`. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. Deprecated, best practice is to reference connections with `ids`. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE array-connections
        
        Delete a connection to an array.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. Deprecated, best practice is to
                        reference connections with `ids`. If after filtering, there is not at least
                        one resource that matches each of the elements, then an error is returned.
                        This cannot be provided together with the `remote_names` query parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. Deprecated, best practice is to
                            reference connections with `ids`. If there is not at least one resource
                            that matches each of the elements, then an error is returned. This cannot
                            be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api217_array_connections_delete_with_http_info', kwargs)

    def get_array_connections(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET array-connections
        
        List connected arrays for replication.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            offset=offset,
            remote_ids=remote_ids,
            remote_names=remote_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api217_array_connections_get_with_http_info', kwargs)

    def patch_array_connections(
        self,
        array_connection: 'models.ArrayConnection',
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. Deprecated, best practice is to reference connections with `ids`. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. Deprecated, best practice is to reference connections with `ids`. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH array-connections
        
        Modify the configuration of a connected array.
        
        :param array_connection: (required)
        :type array_connection: ArrayConnection
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. Deprecated, best practice is to
                        reference connections with `ids`. If after filtering, there is not at least
                        one resource that matches each of the elements, then an error is returned.
                        This cannot be provided together with the `remote_names` query parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. Deprecated, best practice is to
                            reference connections with `ids`. If there is not at least one resource
                            that matches each of the elements, then an error is returned. This cannot
                            be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            array_connection=array_connection,
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api217_array_connections_patch_with_http_info', kwargs)

    def get_array_connections_path(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET array-connections/path
        
        List network path details of connected arrays.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            offset=offset,
            remote_ids=remote_ids,
            remote_names=remote_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api217_array_connections_path_get_with_http_info', kwargs)

    def get_array_connections_performance_replication(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Display the metric of a specified object type. Valid values are `all`, `file-system`, and `object-store`. If not specified, defaults to `all`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET array-connections/performance/replication
        
        List performance metrics of file systems or objects being replicated from one array to another.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param type: Display the metric of a specified object type. Valid values are `all`, `file-
                    system`, and `object-store`. If not specified, defaults to `all`.
        :type type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            end_time=end_time,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            offset=offset,
            remote_ids=remote_ids,
            remote_names=remote_names,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_only=total_only,
            type=type,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['ids', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api217_array_connections_performance_replication_get_with_http_info', kwargs)

    def post_array_connections(
        self,
        array_connection: 'models.ArrayConnectionPost',
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST array-connections
        
        Create a connection to an array for replication and configure network settings.
        
        :param array_connection: (required)
        :type array_connection: ArrayConnectionPost
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            array_connection=array_connection,
            x_request_id=x_request_id,
            context_names=context_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _fixup_list_type_params(['context_names'], kwargs)
        return self._call_api('ArrayConnectionsApi', 'api217_array_connections_post_with_http_info', kwargs)

    def get_arrays_eula(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET arrays/eula
        
        List the End User Agreement and signature.
        
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('ArraysApi', 'api217_arrays_eula_get_with_http_info', kwargs)

    def patch_arrays_eula(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        eula: Optional['models.Eula'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH arrays/eula
        
        Modifies the signature on the End User Agreement.
        
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param eula:
        :type eula: Eula
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            eula=eula,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api217_arrays_eula_patch_with_http_info', kwargs)

    def delete_arrays_factory_reset_token(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a factory reset token
        
        Deletes any existing token that could be used to perform a factory reset on the array.
        
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api217_arrays_factory_reset_token_delete_with_http_info', kwargs)

    def get_arrays_factory_reset_token(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List factory reset tokens
        
        Displays a list of tokens used to perform a factory reset on the array.
        
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('ArraysApi', 'api217_arrays_factory_reset_token_get_with_http_info', kwargs)

    def post_arrays_factory_reset_token(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a factory reset token
        
        Creates a token that can be used to perform a factory reset on the array. Factory reset tokens can only be created after the array has been prepared for reset (e.g., all file systems, buckets, and snapshots must first be eradicated). After a token has been created, operations that would take the array out of the prepared state (e.g., creating file systems) are disabled until all tokens have been deleted.
        
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api217_arrays_factory_reset_token_post_with_http_info', kwargs)

    def get_arrays(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET arrays
        
        List array attributes such as the array name, ID, version, and NTP servers.
        
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('ArraysApi', 'api217_arrays_get_with_http_info', kwargs)

    def get_arrays_http_specific_performance(
        self,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET arrays/http-specific-performance
        
        List the HTTP performance metrics of the array.
        
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            end_time=end_time,
            resolution=resolution,
            start_time=start_time,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _fixup_list_type_params(['context_names'], kwargs)
        return self._call_api('ArraysApi', 'api217_arrays_http_specific_performance_get_with_http_info', kwargs)

    def get_arrays_nfs_specific_performance(
        self,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET arrays/nfs-specific-performance
        
        List the NFS performance metrics of the array.
        
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            end_time=end_time,
            resolution=resolution,
            start_time=start_time,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _fixup_list_type_params(['context_names'], kwargs)
        return self._call_api('ArraysApi', 'api217_arrays_nfs_specific_performance_get_with_http_info', kwargs)

    def patch_arrays(
        self,
        array: 'models.Array',
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH arrays
        
        Modify the general configuration of the array including banner text, array name, NTP servers, and time zone.
        
        :param array: (required)
        :type array: Array
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            array=array,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('ArraysApi', 'api217_arrays_patch_with_http_info', kwargs)

    def get_arrays_performance(
        self,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        protocol: Annotated[Optional[StrictStr], Field(description="Display the performance of a specified protocol. Valid values are `all`, `HTTP`, `SMB`, `NFS`, and `S3`. If not specified, defaults to `all`, which will provide the combined performance of all available protocols.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET arrays/performance
        
        Lists the overall performance metrics of the array.
        
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param protocol: Display the performance of a specified protocol. Valid values are `all`, `HTTP`,
                        `SMB`, `NFS`, and `S3`. If not specified, defaults to `all`, which will
                        provide the combined performance of all available protocols.
        :type protocol: str
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            end_time=end_time,
            protocol=protocol,
            resolution=resolution,
            start_time=start_time,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _fixup_list_type_params(['context_names'], kwargs)
        return self._call_api('ArraysApi', 'api217_arrays_performance_get_with_http_info', kwargs)

    def get_arrays_performance_replication(
        self,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Display the metric of a specified object type. Valid values are `all`, `file-system`, and `object-store`. If not specified, defaults to `all`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET arrays/performance/replication
        
        List replication performance metrics.
        
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param type: Display the metric of a specified object type. Valid values are `all`, `file-
                    system`, and `object-store`. If not specified, defaults to `all`.
        :type type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            end_time=end_time,
            resolution=resolution,
            start_time=start_time,
            type=type,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _fixup_list_type_params(['context_names'], kwargs)
        return self._call_api('ArraysApi', 'api217_arrays_performance_replication_get_with_http_info', kwargs)

    def get_arrays_s3_specific_performance(
        self,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET arrays/s3-specific-performance
        
        List the S3 performance metrics of the array.
        
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            end_time=end_time,
            resolution=resolution,
            start_time=start_time,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _fixup_list_type_params(['context_names'], kwargs)
        return self._call_api('ArraysApi', 'api217_arrays_s3_specific_performance_get_with_http_info', kwargs)

    def get_arrays_space(
        self,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        type: Annotated[Optional[StrictStr], Field(description="Display the metric of a specified object type. Valid values are `array`, `file-system`, and `object-store`. If not specified, defaults to `array`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET arrays/space
        
        List available and used storage space on the array.
        
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param type: Display the metric of a specified object type. Valid values are `array`, `file-
                    system`, and `object-store`. If not specified, defaults to `array`.
        :type type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            end_time=end_time,
            resolution=resolution,
            start_time=start_time,
            type=type,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _fixup_list_type_params(['context_names'], kwargs)
        return self._call_api('ArraysApi', 'api217_arrays_space_get_with_http_info', kwargs)

    def get_arrays_space_storage_classes(
        self,
        storage_classes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        storage_class_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of storage class names. Valid values include `S500X-S` and `S500X-A`.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET arrays/space/storage-classes
        
        List available and used storage space for storage classes on the array.
        
        :param storage_classes: A list of storage_classes to query for. Overrides storage_class_names keyword argument.
        :type storage_classes: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param storage_class_names: A comma-separated list of storage class names. Valid values include `S500X-S`
                                    and `S500X-A`.
        :type storage_class_names: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            end_time=end_time,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            storage_class_names=storage_class_names,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(storage_classes, ['storage_class_names'], kwargs)
        _fixup_list_type_params(['sort', 'storage_class_names'], kwargs)
        return self._call_api('ArraysApi', 'api217_arrays_space_storage_classes_get_with_http_info', kwargs)

    def get_arrays_supported_time_zones(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET arrays/supported-time-zones
        
        List supported time zones for the array.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('ArraysApi', 'api217_arrays_supported_time_zones_get_with_http_info', kwargs)

    def get_audits(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET audits
        
        List the array audit trail to view activities that were performed on the array.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('AuditsApi', 'api217_audits_get_with_http_info', kwargs)

    def get_blades(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET blades
        
        List array blade information.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('BladesApi', 'api217_blades_get_with_http_info', kwargs)

    def delete_bucket_replica_links(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        local_bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local bucket IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_bucket_names` query parameter.")] = None,
        local_bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local bucket names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_bucket_ids` query parameter.")] = None,
        remote_bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote bucket names. If there is not at least one resource that matches each of the elements, then an error is returned.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE bucket-replica-links
        
        Delete a bucket replica link.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param remote_buckets: A list of remote_buckets to query for. Overrides remote_bucket_names keyword argument.
        :type remote_buckets: ReferenceType or List[ReferenceType], optional
        :param local_buckets: A list of local_buckets to query for. Overrides local_bucket_ids and local_bucket_names keyword arguments.
        :type local_buckets: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param local_bucket_ids: A comma-separated list of local bucket IDs. If after filtering, there is not at
                                least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `local_bucket_names`
                                query parameter.
        :type local_bucket_ids: List[str]
        :param local_bucket_names: A comma-separated list of local bucket names. If there is not at least one
                                resource that matches each of the elements, then an error is returned.
                                This cannot be provided together with `local_bucket_ids` query parameter.
        :type local_bucket_names: List[str]
        :param remote_bucket_names: A comma-separated list of remote bucket names. If there is not at least one
                                    resource that matches each of the elements, then an error is returned.
        :type remote_bucket_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            local_bucket_ids=local_bucket_ids,
            local_bucket_names=local_bucket_names,
            remote_bucket_names=remote_bucket_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids'], kwargs)
        _process_references(local_buckets, ['local_bucket_ids', 'local_bucket_names'], kwargs)
        _process_references(remote_buckets, ['remote_bucket_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'local_bucket_ids', 'local_bucket_names', 'remote_bucket_names', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('BucketReplicaLinksApi', 'api217_bucket_replica_links_delete_with_http_info', kwargs)

    def get_bucket_replica_links(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        local_bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local bucket IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_bucket_names` query parameter.")] = None,
        local_bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local bucket names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_bucket_ids` query parameter.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        remote_bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote bucket names. If there is not at least one resource that matches each of the elements, then an error is returned.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET bucket-replica-links
        
        List bucket replica links for object replication.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param remote_buckets: A list of remote_buckets to query for. Overrides remote_bucket_names keyword argument.
        :type remote_buckets: ReferenceType or List[ReferenceType], optional
        :param local_buckets: A list of local_buckets to query for. Overrides local_bucket_ids and local_bucket_names keyword arguments.
        :type local_buckets: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param local_bucket_ids: A comma-separated list of local bucket IDs. If after filtering, there is not at
                                least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `local_bucket_names`
                                query parameter.
        :type local_bucket_ids: List[str]
        :param local_bucket_names: A comma-separated list of local bucket names. If there is not at least one
                                resource that matches each of the elements, then an error is returned.
                                This cannot be provided together with `local_bucket_ids` query parameter.
        :type local_bucket_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param remote_bucket_names: A comma-separated list of remote bucket names. If there is not at least one
                                    resource that matches each of the elements, then an error is returned.
        :type remote_bucket_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            local_bucket_ids=local_bucket_ids,
            local_bucket_names=local_bucket_names,
            offset=offset,
            remote_bucket_names=remote_bucket_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids'], kwargs)
        _process_references(local_buckets, ['local_bucket_ids', 'local_bucket_names'], kwargs)
        _process_references(remote_buckets, ['remote_bucket_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'local_bucket_ids', 'local_bucket_names', 'remote_bucket_names', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('BucketReplicaLinksApi', 'api217_bucket_replica_links_get_with_http_info', kwargs)

    def patch_bucket_replica_links(
        self,
        bucket_replica_link: 'models.BucketReplicaLink',
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        local_bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local bucket IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_bucket_names` query parameter.")] = None,
        local_bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local bucket names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_bucket_ids` query parameter.")] = None,
        remote_bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote bucket names. If there is not at least one resource that matches each of the elements, then an error is returned.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH bucket-replica-links
        
        Modify the configuration of a bucket replica link including whether the link is paused and the object store remote credentials used.
        
        :param bucket_replica_link: (required)
        :type bucket_replica_link: BucketReplicaLink
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param remote_buckets: A list of remote_buckets to query for. Overrides remote_bucket_names keyword argument.
        :type remote_buckets: ReferenceType or List[ReferenceType], optional
        :param local_buckets: A list of local_buckets to query for. Overrides local_bucket_ids and local_bucket_names keyword arguments.
        :type local_buckets: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param local_bucket_ids: A comma-separated list of local bucket IDs. If after filtering, there is not at
                                least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `local_bucket_names`
                                query parameter.
        :type local_bucket_ids: List[str]
        :param local_bucket_names: A comma-separated list of local bucket names. If there is not at least one
                                resource that matches each of the elements, then an error is returned.
                                This cannot be provided together with `local_bucket_ids` query parameter.
        :type local_bucket_names: List[str]
        :param remote_bucket_names: A comma-separated list of remote bucket names. If there is not at least one
                                    resource that matches each of the elements, then an error is returned.
        :type remote_bucket_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            bucket_replica_link=bucket_replica_link,
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            local_bucket_ids=local_bucket_ids,
            local_bucket_names=local_bucket_names,
            remote_bucket_names=remote_bucket_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids'], kwargs)
        _process_references(local_buckets, ['local_bucket_ids', 'local_bucket_names'], kwargs)
        _process_references(remote_buckets, ['remote_bucket_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'local_bucket_ids', 'local_bucket_names', 'remote_bucket_names', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('BucketReplicaLinksApi', 'api217_bucket_replica_links_patch_with_http_info', kwargs)

    def post_bucket_replica_links(
        self,
        bucket_replica_link: 'models.BucketReplicaLinkPost',
        remote_credential: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        local_bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local bucket IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_bucket_names` query parameter.")] = None,
        local_bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local bucket names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_bucket_ids` query parameter.")] = None,
        remote_bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote bucket names. If there is not at least one resource that matches each of the elements, then an error is returned.")] = None,
        remote_credentials_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote credentials IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_credentials_names` query parameter.")] = None,
        remote_credentials_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote credentials names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_credentials_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST bucket-replica-links
        
        Create a bucket replica link for object replication.
        
        :param bucket_replica_link: (required)
        :type bucket_replica_link: BucketReplicaLinkPost
        :param remote_credential: A list of remote_credential to query for. Overrides remote_credentials_ids and remote_credentials_names keyword arguments.
        :type remote_credential: ReferenceType or List[ReferenceType], optional
        :param remote_buckets: A list of remote_buckets to query for. Overrides remote_bucket_names keyword argument.
        :type remote_buckets: ReferenceType or List[ReferenceType], optional
        :param local_buckets: A list of local_buckets to query for. Overrides local_bucket_ids and local_bucket_names keyword arguments.
        :type local_buckets: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param local_bucket_ids: A comma-separated list of local bucket IDs. If after filtering, there is not at
                                least one resource that matches each of the elements, then an error is
                                returned. This cannot be provided together with the `local_bucket_names`
                                query parameter.
        :type local_bucket_ids: List[str]
        :param local_bucket_names: A comma-separated list of local bucket names. If there is not at least one
                                resource that matches each of the elements, then an error is returned.
                                This cannot be provided together with `local_bucket_ids` query parameter.
        :type local_bucket_names: List[str]
        :param remote_bucket_names: A comma-separated list of remote bucket names. If there is not at least one
                                    resource that matches each of the elements, then an error is returned.
        :type remote_bucket_names: List[str]
        :param remote_credentials_ids: A comma-separated list of remote credentials IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `remote_credentials_names` query parameter.
        :type remote_credentials_ids: List[str]
        :param remote_credentials_names: A comma-separated list of remote credentials names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with the `remote_credentials_ids` query
                                        parameter.
        :type remote_credentials_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            bucket_replica_link=bucket_replica_link,
            x_request_id=x_request_id,
            context_names=context_names,
            local_bucket_ids=local_bucket_ids,
            local_bucket_names=local_bucket_names,
            remote_bucket_names=remote_bucket_names,
            remote_credentials_ids=remote_credentials_ids,
            remote_credentials_names=remote_credentials_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(local_buckets, ['local_bucket_ids', 'local_bucket_names'], kwargs)
        _process_references(remote_buckets, ['remote_bucket_names'], kwargs)
        _process_references(remote_credential, ['remote_credentials_ids', 'remote_credentials_names'], kwargs)
        _fixup_list_type_params(['context_names', 'local_bucket_ids', 'local_bucket_names', 'remote_bucket_names', 'remote_credentials_ids', 'remote_credentials_names'], kwargs)
        return self._call_api('BucketReplicaLinksApi', 'api217_bucket_replica_links_post_with_http_info', kwargs)

    def delete_buckets_bucket_access_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket IDs. If after filtering, there is not at least one resource that matches each of the elements of `bucket_ids`, then an error is returned. This cannot be provided together with the `bucket_names` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket names. If there is not at least one resource that matches each of the elements of `bucket_names`, then an error is returned. This cannot be provided together with the `bucket_ids` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE buckets/bucket-access-policies
        
        Delete a bucket policy of the specified bucket. Either `names` or `bucket_names`/`bucket_ids` query parameters can be used.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param buckets: A list of buckets to query for. Overrides bucket_ids and bucket_names keyword arguments.
        :type buckets: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param bucket_ids: A comma-separated list of bucket IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `bucket_ids`, then an
                        error is returned. This cannot be provided together with the `bucket_names`
                        query parameter. This can be provided with the `ids` query parameter but not
                        with `names`.
        :type bucket_ids: List[str]
        :param bucket_names: A comma-separated list of bucket names. If there is not at least one resource
                            that matches each of the elements of `bucket_names`, then an error is
                            returned. This cannot be provided together with the `bucket_ids` query
                            parameter. This can be provided with the `ids` query parameter but not with
                            `names`.
        :type bucket_names: List[str]
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            bucket_ids=bucket_ids,
            bucket_names=bucket_names,
            context_names=context_names,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(buckets, ['bucket_ids', 'bucket_names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['bucket_ids', 'bucket_names', 'context_names', 'names'], kwargs)
        return self._call_api('BucketsApi', 'api217_buckets_bucket_access_policies_delete_with_http_info', kwargs)

    def get_buckets_bucket_access_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket IDs. If after filtering, there is not at least one resource that matches each of the elements of `bucket_ids`, then an error is returned. This cannot be provided together with the `bucket_names` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket names. If there is not at least one resource that matches each of the elements of `bucket_names`, then an error is returned. This cannot be provided together with the `bucket_ids` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET buckets/bucket-access-policies
        
        List a policy for the specified bucket and its attributes. Either `names` or `bucket_names`/`bucket_ids` query parameters can be used.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param buckets: A list of buckets to query for. Overrides bucket_ids and bucket_names keyword arguments.
        :type buckets: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param bucket_ids: A comma-separated list of bucket IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `bucket_ids`, then an
                        error is returned. This cannot be provided together with the `bucket_names`
                        query parameter. This can be provided with the `ids` query parameter but not
                        with `names`.
        :type bucket_ids: List[str]
        :param bucket_names: A comma-separated list of bucket names. If there is not at least one resource
                            that matches each of the elements of `bucket_names`, then an error is
                            returned. This cannot be provided together with the `bucket_ids` query
                            parameter. This can be provided with the `ids` query parameter but not with
                            `names`.
        :type bucket_names: List[str]
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            bucket_ids=bucket_ids,
            bucket_names=bucket_names,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(buckets, ['bucket_ids', 'bucket_names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['bucket_ids', 'bucket_names', 'context_names', 'names', 'sort'], kwargs)
        return self._call_api('BucketsApi', 'api217_buckets_bucket_access_policies_get_with_http_info', kwargs)

    def post_buckets_bucket_access_policies(
        self,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket IDs. If after filtering, there is not at least one resource that matches each of the elements of `bucket_ids`, then an error is returned. This cannot be provided together with the `bucket_names` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket names. If there is not at least one resource that matches each of the elements of `bucket_names`, then an error is returned. This cannot be provided together with the `bucket_ids` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        policy: Optional['models.BucketAccessPolicyPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST buckets/bucket-access-policies
        
        Create a new policy for the specified bucket. Policy's name will be autogenerated by the system.
        
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param buckets: A list of buckets to query for. Overrides bucket_ids and bucket_names keyword arguments.
        :type buckets: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param bucket_ids: A comma-separated list of bucket IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `bucket_ids`, then an
                        error is returned. This cannot be provided together with the `bucket_names`
                        query parameter. This can be provided with the `ids` query parameter but not
                        with `names`.
        :type bucket_ids: List[str]
        :param bucket_names: A comma-separated list of bucket names. If there is not at least one resource
                            that matches each of the elements of `bucket_names`, then an error is
                            returned. This cannot be provided together with the `bucket_ids` query
                            parameter. This can be provided with the `ids` query parameter but not with
                            `names`.
        :type bucket_names: List[str]
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param policy:
        :type policy: BucketAccessPolicyPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            bucket_ids=bucket_ids,
            bucket_names=bucket_names,
            context_names=context_names,
            policy=policy,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(buckets, ['bucket_ids', 'bucket_names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _fixup_list_type_params(['bucket_ids', 'bucket_names', 'context_names'], kwargs)
        return self._call_api('BucketsApi', 'api217_buckets_bucket_access_policies_post_with_http_info', kwargs)

    def delete_buckets_bucket_access_policies_rules(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket IDs. If after filtering, there is not at least one resource that matches each of the elements of `bucket_ids`, then an error is returned. This cannot be provided together with the `bucket_names` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket names. If there is not at least one resource that matches each of the elements of `bucket_names`, then an error is returned. This cannot be provided together with the `bucket_ids` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE buckets/bucket-access-policies/rules
        
        Delete one or more bucket policy rules for the specified bucket. Either `policy_names` or `bucket_names`/`bucket_ids` query parameters can be used.
        
        :param policies: A list of policies to query for. Overrides policy_names keyword argument.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param buckets: A list of buckets to query for. Overrides bucket_ids and bucket_names keyword arguments.
        :type buckets: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param bucket_ids: A comma-separated list of bucket IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `bucket_ids`, then an
                        error is returned. This cannot be provided together with the `bucket_names`
                        query parameter. This can be provided with the `ids` query parameter but not
                        with `names`.
        :type bucket_ids: List[str]
        :param bucket_names: A comma-separated list of bucket names. If there is not at least one resource
                            that matches each of the elements of `bucket_names`, then an error is
                            returned. This cannot be provided together with the `bucket_ids` query
                            parameter. This can be provided with the `ids` query parameter but not with
                            `names`.
        :type bucket_names: List[str]
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            bucket_ids=bucket_ids,
            bucket_names=bucket_names,
            context_names=context_names,
            names=names,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(buckets, ['bucket_ids', 'bucket_names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _process_references(policies, ['policy_names'], kwargs)
        _fixup_list_type_params(['bucket_ids', 'bucket_names', 'context_names', 'names', 'policy_names'], kwargs)
        return self._call_api('BucketsApi', 'api217_buckets_bucket_access_policies_rules_delete_with_http_info', kwargs)

    def get_buckets_bucket_access_policies_rules(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket IDs. If after filtering, there is not at least one resource that matches each of the elements of `bucket_ids`, then an error is returned. This cannot be provided together with the `bucket_names` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket names. If there is not at least one resource that matches each of the elements of `bucket_names`, then an error is returned. This cannot be provided together with the `bucket_ids` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET buckets/bucket-access-policies/rules
        
        List bucket policy rules for the specified bucket and their attributes. Either `policy_names` or `bucket_names`/`bucket_ids` query parameters can be used.
        
        :param policies: A list of policies to query for. Overrides policy_names keyword argument.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param buckets: A list of buckets to query for. Overrides bucket_ids and bucket_names keyword arguments.
        :type buckets: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param bucket_ids: A comma-separated list of bucket IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `bucket_ids`, then an
                        error is returned. This cannot be provided together with the `bucket_names`
                        query parameter. This can be provided with the `ids` query parameter but not
                        with `names`.
        :type bucket_ids: List[str]
        :param bucket_names: A comma-separated list of bucket names. If there is not at least one resource
                            that matches each of the elements of `bucket_names`, then an error is
                            returned. This cannot be provided together with the `bucket_ids` query
                            parameter. This can be provided with the `ids` query parameter but not with
                            `names`.
        :type bucket_names: List[str]
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            bucket_ids=bucket_ids,
            bucket_names=bucket_names,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            names=names,
            offset=offset,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(buckets, ['bucket_ids', 'bucket_names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _process_references(policies, ['policy_names'], kwargs)
        _fixup_list_type_params(['bucket_ids', 'bucket_names', 'context_names', 'names', 'policy_names', 'sort'], kwargs)
        return self._call_api('BucketsApi', 'api217_buckets_bucket_access_policies_rules_get_with_http_info', kwargs)

    def post_buckets_bucket_access_policies_rules(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        rule: 'models.BucketAccessPolicyRulePost',
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket IDs. If after filtering, there is not at least one resource that matches each of the elements of `bucket_ids`, then an error is returned. This cannot be provided together with the `bucket_names` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket names. If there is not at least one resource that matches each of the elements of `bucket_names`, then an error is returned. This cannot be provided together with the `bucket_ids` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST buckets/bucket-access-policies/rules
        
        Create a new bucket policy rule for the specified bucket. Either `policy_names` or `bucket_names`/`bucket_ids` query parameters can be used.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param rule: (required)
        :type rule: BucketAccessPolicyRulePost
        :param policies: A list of policies to query for. Overrides policy_names keyword argument.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param buckets: A list of buckets to query for. Overrides bucket_ids and bucket_names keyword arguments.
        :type buckets: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param bucket_ids: A comma-separated list of bucket IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `bucket_ids`, then an
                        error is returned. This cannot be provided together with the `bucket_names`
                        query parameter. This can be provided with the `ids` query parameter but not
                        with `names`.
        :type bucket_ids: List[str]
        :param bucket_names: A comma-separated list of bucket names. If there is not at least one resource
                            that matches each of the elements of `bucket_names`, then an error is
                            returned. This cannot be provided together with the `bucket_ids` query
                            parameter. This can be provided with the `ids` query parameter but not with
                            `names`.
        :type bucket_names: List[str]
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            rule=rule,
            x_request_id=x_request_id,
            bucket_ids=bucket_ids,
            bucket_names=bucket_names,
            context_names=context_names,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _process_references(buckets, ['bucket_ids', 'bucket_names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(policies, ['policy_names'], kwargs)
        _fixup_list_type_params(['names', 'bucket_ids', 'bucket_names', 'context_names', 'policy_names'], kwargs)
        return self._call_api('BucketsApi', 'api217_buckets_bucket_access_policies_rules_post_with_http_info', kwargs)

    def delete_buckets_cross_origin_resource_sharing_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket IDs. If after filtering, there is not at least one resource that matches each of the elements of `bucket_ids`, then an error is returned. This cannot be provided together with the `bucket_names` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket names. If there is not at least one resource that matches each of the elements of `bucket_names`, then an error is returned. This cannot be provided together with the `bucket_ids` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE buckets/cross-origin-resource-sharing-policies
        
        Delete a cross origin resource sharing policy of the specified bucket. Either `names` or `bucket_names`/`bucket_ids` query parameters can be used.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param buckets: A list of buckets to query for. Overrides bucket_ids and bucket_names keyword arguments.
        :type buckets: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param bucket_ids: A comma-separated list of bucket IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `bucket_ids`, then an
                        error is returned. This cannot be provided together with the `bucket_names`
                        query parameter. This can be provided with the `ids` query parameter but not
                        with `names`.
        :type bucket_ids: List[str]
        :param bucket_names: A comma-separated list of bucket names. If there is not at least one resource
                            that matches each of the elements of `bucket_names`, then an error is
                            returned. This cannot be provided together with the `bucket_ids` query
                            parameter. This can be provided with the `ids` query parameter but not with
                            `names`.
        :type bucket_names: List[str]
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            bucket_ids=bucket_ids,
            bucket_names=bucket_names,
            context_names=context_names,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(buckets, ['bucket_ids', 'bucket_names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['bucket_ids', 'bucket_names', 'context_names', 'names'], kwargs)
        return self._call_api('BucketsApi', 'api217_buckets_cross_origin_resource_sharing_policies_delete_with_http_info', kwargs)

    def get_buckets_cross_origin_resource_sharing_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket IDs. If after filtering, there is not at least one resource that matches each of the elements of `bucket_ids`, then an error is returned. This cannot be provided together with the `bucket_names` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket names. If there is not at least one resource that matches each of the elements of `bucket_names`, then an error is returned. This cannot be provided together with the `bucket_ids` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET buckets/cross-origin-resource-sharing-policies
        
        List cross origin resource sharing policy for the specified bucket and its attributes. Either `names` or `bucket_names`/`bucket_ids` query parameters can be used.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param buckets: A list of buckets to query for. Overrides bucket_ids and bucket_names keyword arguments.
        :type buckets: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param bucket_ids: A comma-separated list of bucket IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `bucket_ids`, then an
                        error is returned. This cannot be provided together with the `bucket_names`
                        query parameter. This can be provided with the `ids` query parameter but not
                        with `names`.
        :type bucket_ids: List[str]
        :param bucket_names: A comma-separated list of bucket names. If there is not at least one resource
                            that matches each of the elements of `bucket_names`, then an error is
                            returned. This cannot be provided together with the `bucket_ids` query
                            parameter. This can be provided with the `ids` query parameter but not with
                            `names`.
        :type bucket_names: List[str]
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            bucket_ids=bucket_ids,
            bucket_names=bucket_names,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(buckets, ['bucket_ids', 'bucket_names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['bucket_ids', 'bucket_names', 'context_names', 'names', 'sort'], kwargs)
        return self._call_api('BucketsApi', 'api217_buckets_cross_origin_resource_sharing_policies_get_with_http_info', kwargs)

    def post_buckets_cross_origin_resource_sharing_policies(
        self,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket IDs. If after filtering, there is not at least one resource that matches each of the elements of `bucket_ids`, then an error is returned. This cannot be provided together with the `bucket_names` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket names. If there is not at least one resource that matches each of the elements of `bucket_names`, then an error is returned. This cannot be provided together with the `bucket_ids` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        policy: Optional['models.CrossOriginResourceSharingPolicyPatch'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST buckets/cross-origin-resource-sharing-policies
        
        Create a new cross origin resource sharing policy for the specified bucket. Policy's name will be autogenerated by the system.
        
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param buckets: A list of buckets to query for. Overrides bucket_ids and bucket_names keyword arguments.
        :type buckets: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param bucket_ids: A comma-separated list of bucket IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `bucket_ids`, then an
                        error is returned. This cannot be provided together with the `bucket_names`
                        query parameter. This can be provided with the `ids` query parameter but not
                        with `names`.
        :type bucket_ids: List[str]
        :param bucket_names: A comma-separated list of bucket names. If there is not at least one resource
                            that matches each of the elements of `bucket_names`, then an error is
                            returned. This cannot be provided together with the `bucket_ids` query
                            parameter. This can be provided with the `ids` query parameter but not with
                            `names`.
        :type bucket_names: List[str]
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param policy:
        :type policy: CrossOriginResourceSharingPolicyPatch
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            bucket_ids=bucket_ids,
            bucket_names=bucket_names,
            context_names=context_names,
            policy=policy,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(buckets, ['bucket_ids', 'bucket_names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _fixup_list_type_params(['bucket_ids', 'bucket_names', 'context_names'], kwargs)
        return self._call_api('BucketsApi', 'api217_buckets_cross_origin_resource_sharing_policies_post_with_http_info', kwargs)

    def delete_buckets_cross_origin_resource_sharing_policies_rules(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket IDs. If after filtering, there is not at least one resource that matches each of the elements of `bucket_ids`, then an error is returned. This cannot be provided together with the `bucket_names` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket names. If there is not at least one resource that matches each of the elements of `bucket_names`, then an error is returned. This cannot be provided together with the `bucket_ids` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE buckets/cross-origin-resource-sharing-policies/rules
        
        Delete one or more cross origin resource sharing policy rules for the specified bucket. Either `policy_names` or `bucket_names` query parameters can be used.
        
        :param policies: A list of policies to query for. Overrides policy_names keyword argument.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param buckets: A list of buckets to query for. Overrides bucket_ids and bucket_names keyword arguments.
        :type buckets: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param bucket_ids: A comma-separated list of bucket IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `bucket_ids`, then an
                        error is returned. This cannot be provided together with the `bucket_names`
                        query parameter. This can be provided with the `ids` query parameter but not
                        with `names`.
        :type bucket_ids: List[str]
        :param bucket_names: A comma-separated list of bucket names. If there is not at least one resource
                            that matches each of the elements of `bucket_names`, then an error is
                            returned. This cannot be provided together with the `bucket_ids` query
                            parameter. This can be provided with the `ids` query parameter but not with
                            `names`.
        :type bucket_names: List[str]
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            bucket_ids=bucket_ids,
            bucket_names=bucket_names,
            context_names=context_names,
            names=names,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(buckets, ['bucket_ids', 'bucket_names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _process_references(policies, ['policy_names'], kwargs)
        _fixup_list_type_params(['bucket_ids', 'bucket_names', 'context_names', 'names', 'policy_names'], kwargs)
        return self._call_api('BucketsApi', 'api217_buckets_cross_origin_resource_sharing_policies_rules_delete_with_http_info', kwargs)

    def get_buckets_cross_origin_resource_sharing_policies_rules(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket IDs. If after filtering, there is not at least one resource that matches each of the elements of `bucket_ids`, then an error is returned. This cannot be provided together with the `bucket_names` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket names. If there is not at least one resource that matches each of the elements of `bucket_names`, then an error is returned. This cannot be provided together with the `bucket_ids` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET buckets/cross-origin-resource-sharing-policies/rules
        
        List cross origin resource sharing policy rules for the specified bucket and their attributes. Either `policy_names` or `bucket_names` query parameters can be used.
        
        :param policies: A list of policies to query for. Overrides policy_names keyword argument.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param buckets: A list of buckets to query for. Overrides bucket_ids and bucket_names keyword arguments.
        :type buckets: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param bucket_ids: A comma-separated list of bucket IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `bucket_ids`, then an
                        error is returned. This cannot be provided together with the `bucket_names`
                        query parameter. This can be provided with the `ids` query parameter but not
                        with `names`.
        :type bucket_ids: List[str]
        :param bucket_names: A comma-separated list of bucket names. If there is not at least one resource
                            that matches each of the elements of `bucket_names`, then an error is
                            returned. This cannot be provided together with the `bucket_ids` query
                            parameter. This can be provided with the `ids` query parameter but not with
                            `names`.
        :type bucket_names: List[str]
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            bucket_ids=bucket_ids,
            bucket_names=bucket_names,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            names=names,
            offset=offset,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(buckets, ['bucket_ids', 'bucket_names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _process_references(policies, ['policy_names'], kwargs)
        _fixup_list_type_params(['bucket_ids', 'bucket_names', 'context_names', 'names', 'policy_names', 'sort'], kwargs)
        return self._call_api('BucketsApi', 'api217_buckets_cross_origin_resource_sharing_policies_rules_get_with_http_info', kwargs)

    def post_buckets_cross_origin_resource_sharing_policies_rules(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        rule: 'models.CrossOriginResourceSharingPolicyRulePost',
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket IDs. If after filtering, there is not at least one resource that matches each of the elements of `bucket_ids`, then an error is returned. This cannot be provided together with the `bucket_names` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket names. If there is not at least one resource that matches each of the elements of `bucket_names`, then an error is returned. This cannot be provided together with the `bucket_ids` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST buckets/cross-origin-resource-sharing-policies/rules
        
        Create a new cross origin resource sharing policy rule for the specified bucket. Either `policy_names` or `bucket_names` query parameters can be used.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param rule: (required)
        :type rule: CrossOriginResourceSharingPolicyRulePost
        :param policies: A list of policies to query for. Overrides policy_names keyword argument.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param buckets: A list of buckets to query for. Overrides bucket_ids and bucket_names keyword arguments.
        :type buckets: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param bucket_ids: A comma-separated list of bucket IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `bucket_ids`, then an
                        error is returned. This cannot be provided together with the `bucket_names`
                        query parameter. This can be provided with the `ids` query parameter but not
                        with `names`.
        :type bucket_ids: List[str]
        :param bucket_names: A comma-separated list of bucket names. If there is not at least one resource
                            that matches each of the elements of `bucket_names`, then an error is
                            returned. This cannot be provided together with the `bucket_ids` query
                            parameter. This can be provided with the `ids` query parameter but not with
                            `names`.
        :type bucket_names: List[str]
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            rule=rule,
            x_request_id=x_request_id,
            bucket_ids=bucket_ids,
            bucket_names=bucket_names,
            context_names=context_names,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _process_references(buckets, ['bucket_ids', 'bucket_names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(policies, ['policy_names'], kwargs)
        _fixup_list_type_params(['names', 'bucket_ids', 'bucket_names', 'context_names', 'policy_names'], kwargs)
        return self._call_api('BucketsApi', 'api217_buckets_cross_origin_resource_sharing_policies_rules_post_with_http_info', kwargs)

    def delete_buckets(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE buckets
        
        Delete object store buckets.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names'], kwargs)
        return self._call_api('BucketsApi', 'api217_buckets_delete_with_http_info', kwargs)

    def get_buckets(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. If not set, lists both objects that are destroyed and those that are not destroyed. If object name(s) are specified in the `names` parameter, then each object referenced must exist. If `destroyed` is set to `true`, then each object referenced must also be destroyed. If `destroyed` is set to `false`, then each object referenced must also not be destroyed. An error is returned if any of these conditions are not met.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET buckets
        
        List object store bucket attributes such as creation time and space usage.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        If not set, lists both objects that are destroyed and those that are not
                        destroyed. If object name(s) are specified in the `names` parameter, then
                        each object referenced must exist. If `destroyed` is set to `true`, then
                        each object referenced must also be destroyed. If `destroyed` is set to
                        `false`, then each object referenced must also not be destroyed. An error is
                        returned if any of these conditions are not met.
        :type destroyed: bool
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'sort'], kwargs)
        return self._call_api('BucketsApi', 'api217_buckets_get_with_http_info', kwargs)

    def patch_buckets(
        self,
        bucket: 'models.BucketPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        ignore_usage: Annotated[Optional[StrictBool], Field(description="Allow update operations that lead to a `hard_limit_enabled` object store account, bucket, or file system with usage over its limiting value. For object store accounts and buckets, the limiting value is that of `quota_limit`, and for file systems it is that of `provisioned`. The operation can be setting `hard_limit_enabled` when usage is higher than the limiting value, modifying the limiting value to a value under usage when `hard_limit_enabled`, recovering a destroyed bucket of an object store account that causes an account's space usage to go over its hard `quota_limit`. Also allows update operations that would cause usage of the requested storage class to go over its warning threshold.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH buckets
        
        Modify object store bucket attributes such as destroyed and versioning.
        
        :param bucket: (required)
        :type bucket: BucketPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param ignore_usage: Allow update operations that lead to a `hard_limit_enabled` object store
                            account, bucket, or file system with usage over its limiting value. For
                            object store accounts and buckets, the limiting value is that of
                            `quota_limit`, and for file systems it is that of `provisioned`. The
                            operation can be setting `hard_limit_enabled` when usage is higher than the
                            limiting value, modifying the limiting value to a value under usage when
                            `hard_limit_enabled`, recovering a destroyed bucket of an object store
                            account that causes an account's space usage to go over its hard
                            `quota_limit`. Also allows update operations that would cause usage of the
                            requested storage class to go over its warning threshold.
        :type ignore_usage: bool
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            bucket=bucket,
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            ignore_usage=ignore_usage,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names'], kwargs)
        return self._call_api('BucketsApi', 'api217_buckets_patch_with_http_info', kwargs)

    def get_buckets_performance(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET buckets/performance
        
        List performance metrics for a bucket.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            end_time=end_time,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('BucketsApi', 'api217_buckets_performance_get_with_http_info', kwargs)

    def post_buckets(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        bucket: 'models.BucketPost',
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST buckets
        
        Create a new object store bucket.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param bucket: (required)
        :type bucket: BucketPost
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            bucket=bucket,
            x_request_id=x_request_id,
            context_names=context_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _fixup_list_type_params(['names', 'context_names'], kwargs)
        return self._call_api('BucketsApi', 'api217_buckets_post_with_http_info', kwargs)

    def get_buckets_s3_specific_performance(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET buckets/s3-specific-performance
        
        List performance metrics specific to S3 operations for a bucket.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            end_time=end_time,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('BucketsApi', 'api217_buckets_s3_specific_performance_get_with_http_info', kwargs)

    def delete_certificate_groups_certificates(
        self,
        certificates: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        certificate_group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group ids. If there is not at least one resource that matches each of the elements of `certificate_group_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_names` parameter.")] = None,
        certificate_group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group names. If there is not at least one resource that matches each of the elements of `certificate_group_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_ids` parameter.")] = None,
        certificate_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate ids. If there is not at least one resource that matches each of the elements of `certificate_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_names` parameter.")] = None,
        certificate_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate names. If there is not at least one resource that matches each of the elements of `certificate_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_ids` parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE certificate-groups/certificates
        
        Delete one or more certificate groups.
        
        :param certificates: A list of certificates to query for. Overrides certificate_ids and certificate_names keyword arguments.
        :type certificates: ReferenceType or List[ReferenceType], optional
        :param certificate_groups: A list of certificate_groups to query for. Overrides certificate_group_ids and certificate_group_names keyword arguments.
        :type certificate_groups: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param certificate_group_ids: A comma-separated list of certificate group ids. If there is not at least one
                                    resource that matches each of the elements of `certificate_group_ids`,
                                    then an error is returned. This cannot be provided in conjunction with
                                    the `certificate_group_names` parameter.
        :type certificate_group_ids: List[str]
        :param certificate_group_names: A comma-separated list of certificate group names. If there is not at least one
                                        resource that matches each of the elements of `certificate_group_names`,
                                        then an error is returned. This cannot be provided in conjunction with
                                        the `certificate_group_ids` parameter.
        :type certificate_group_names: List[str]
        :param certificate_ids: A comma-separated list of certificate ids. If there is not at least one resource
                                that matches each of the elements of `certificate_ids`, then an error is
                                returned. This cannot be provided in conjunction with the
                                `certificate_names` parameter.
        :type certificate_ids: List[str]
        :param certificate_names: A comma-separated list of certificate names. If there is not at least one
                                resource that matches each of the elements of `certificate_names`, then an
                                error is returned. This cannot be provided in conjunction with the
                                `certificate_ids` parameter.
        :type certificate_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            certificate_group_ids=certificate_group_ids,
            certificate_group_names=certificate_group_names,
            certificate_ids=certificate_ids,
            certificate_names=certificate_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(certificate_groups, ['certificate_group_ids', 'certificate_group_names'], kwargs)
        _process_references(certificates, ['certificate_ids', 'certificate_names'], kwargs)
        _fixup_list_type_params(['certificate_group_ids', 'certificate_group_names', 'certificate_ids', 'certificate_names'], kwargs)
        return self._call_api('CertificateGroupsApi', 'api217_certificate_groups_certificates_delete_with_http_info', kwargs)

    def get_certificate_groups_certificates(
        self,
        certificates: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        certificate_group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group ids. If there is not at least one resource that matches each of the elements of `certificate_group_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_names` parameter.")] = None,
        certificate_group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group names. If there is not at least one resource that matches each of the elements of `certificate_group_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_ids` parameter.")] = None,
        certificate_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate ids. If there is not at least one resource that matches each of the elements of `certificate_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_names` parameter.")] = None,
        certificate_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate names. If there is not at least one resource that matches each of the elements of `certificate_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_ids` parameter.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET certificate-groups/certificates
        
        List membership associations between groups and certificates on the array.
        
        :param certificates: A list of certificates to query for. Overrides certificate_ids and certificate_names keyword arguments.
        :type certificates: ReferenceType or List[ReferenceType], optional
        :param certificate_groups: A list of certificate_groups to query for. Overrides certificate_group_ids and certificate_group_names keyword arguments.
        :type certificate_groups: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param certificate_group_ids: A comma-separated list of certificate group ids. If there is not at least one
                                    resource that matches each of the elements of `certificate_group_ids`,
                                    then an error is returned. This cannot be provided in conjunction with
                                    the `certificate_group_names` parameter.
        :type certificate_group_ids: List[str]
        :param certificate_group_names: A comma-separated list of certificate group names. If there is not at least one
                                        resource that matches each of the elements of `certificate_group_names`,
                                        then an error is returned. This cannot be provided in conjunction with
                                        the `certificate_group_ids` parameter.
        :type certificate_group_names: List[str]
        :param certificate_ids: A comma-separated list of certificate ids. If there is not at least one resource
                                that matches each of the elements of `certificate_ids`, then an error is
                                returned. This cannot be provided in conjunction with the
                                `certificate_names` parameter.
        :type certificate_ids: List[str]
        :param certificate_names: A comma-separated list of certificate names. If there is not at least one
                                resource that matches each of the elements of `certificate_names`, then an
                                error is returned. This cannot be provided in conjunction with the
                                `certificate_ids` parameter.
        :type certificate_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            certificate_group_ids=certificate_group_ids,
            certificate_group_names=certificate_group_names,
            certificate_ids=certificate_ids,
            certificate_names=certificate_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(certificate_groups, ['certificate_group_ids', 'certificate_group_names'], kwargs)
        _process_references(certificates, ['certificate_ids', 'certificate_names'], kwargs)
        _fixup_list_type_params(['certificate_group_ids', 'certificate_group_names', 'certificate_ids', 'certificate_names', 'sort'], kwargs)
        return self._call_api('CertificateGroupsApi', 'api217_certificate_groups_certificates_get_with_http_info', kwargs)

    def post_certificate_groups_certificates(
        self,
        certificates: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        certificate_group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group ids. If there is not at least one resource that matches each of the elements of `certificate_group_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_names` parameter.")] = None,
        certificate_group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group names. If there is not at least one resource that matches each of the elements of `certificate_group_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_ids` parameter.")] = None,
        certificate_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate ids. If there is not at least one resource that matches each of the elements of `certificate_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_names` parameter.")] = None,
        certificate_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate names. If there is not at least one resource that matches each of the elements of `certificate_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_ids` parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST certificate-groups/certificates
        
        Add one or more certificates to one or more certificate groups on the array.
        
        :param certificates: A list of certificates to query for. Overrides certificate_ids and certificate_names keyword arguments.
        :type certificates: ReferenceType or List[ReferenceType], optional
        :param certificate_groups: A list of certificate_groups to query for. Overrides certificate_group_ids and certificate_group_names keyword arguments.
        :type certificate_groups: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param certificate_group_ids: A comma-separated list of certificate group ids. If there is not at least one
                                    resource that matches each of the elements of `certificate_group_ids`,
                                    then an error is returned. This cannot be provided in conjunction with
                                    the `certificate_group_names` parameter.
        :type certificate_group_ids: List[str]
        :param certificate_group_names: A comma-separated list of certificate group names. If there is not at least one
                                        resource that matches each of the elements of `certificate_group_names`,
                                        then an error is returned. This cannot be provided in conjunction with
                                        the `certificate_group_ids` parameter.
        :type certificate_group_names: List[str]
        :param certificate_ids: A comma-separated list of certificate ids. If there is not at least one resource
                                that matches each of the elements of `certificate_ids`, then an error is
                                returned. This cannot be provided in conjunction with the
                                `certificate_names` parameter.
        :type certificate_ids: List[str]
        :param certificate_names: A comma-separated list of certificate names. If there is not at least one
                                resource that matches each of the elements of `certificate_names`, then an
                                error is returned. This cannot be provided in conjunction with the
                                `certificate_ids` parameter.
        :type certificate_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            certificate_group_ids=certificate_group_ids,
            certificate_group_names=certificate_group_names,
            certificate_ids=certificate_ids,
            certificate_names=certificate_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(certificate_groups, ['certificate_group_ids', 'certificate_group_names'], kwargs)
        _process_references(certificates, ['certificate_ids', 'certificate_names'], kwargs)
        _fixup_list_type_params(['certificate_group_ids', 'certificate_group_names', 'certificate_ids', 'certificate_names'], kwargs)
        return self._call_api('CertificateGroupsApi', 'api217_certificate_groups_certificates_post_with_http_info', kwargs)

    def delete_certificate_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE certificate-groups
        
        Delete one or more certificate groups from the array.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('CertificateGroupsApi', 'api217_certificate_groups_delete_with_http_info', kwargs)

    def get_certificate_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET certificate-groups
        
        Display all array certificate groups.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('CertificateGroupsApi', 'api217_certificate_groups_get_with_http_info', kwargs)

    def post_certificate_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST certificate-groups
        
        Create one or more certificate groups on the array.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('CertificateGroupsApi', 'api217_certificate_groups_post_with_http_info', kwargs)

    def get_certificate_groups_uses(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET certificate-groups/uses
        
        List how certificate groups are being used and by what.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('CertificateGroupsApi', 'api217_certificate_groups_uses_get_with_http_info', kwargs)

    def delete_certificates_certificate_groups(
        self,
        certificates: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        certificate_group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group ids. If there is not at least one resource that matches each of the elements of `certificate_group_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_names` parameter.")] = None,
        certificate_group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group names. If there is not at least one resource that matches each of the elements of `certificate_group_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_ids` parameter.")] = None,
        certificate_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate ids. If there is not at least one resource that matches each of the elements of `certificate_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_names` parameter.")] = None,
        certificate_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate names. If there is not at least one resource that matches each of the elements of `certificate_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_ids` parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE certificates/certificate-groups
        
        Remove one or more certificates from one or more certificate groups.
        
        :param certificates: A list of certificates to query for. Overrides certificate_ids and certificate_names keyword arguments.
        :type certificates: ReferenceType or List[ReferenceType], optional
        :param certificate_groups: A list of certificate_groups to query for. Overrides certificate_group_ids and certificate_group_names keyword arguments.
        :type certificate_groups: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param certificate_group_ids: A comma-separated list of certificate group ids. If there is not at least one
                                    resource that matches each of the elements of `certificate_group_ids`,
                                    then an error is returned. This cannot be provided in conjunction with
                                    the `certificate_group_names` parameter.
        :type certificate_group_ids: List[str]
        :param certificate_group_names: A comma-separated list of certificate group names. If there is not at least one
                                        resource that matches each of the elements of `certificate_group_names`,
                                        then an error is returned. This cannot be provided in conjunction with
                                        the `certificate_group_ids` parameter.
        :type certificate_group_names: List[str]
        :param certificate_ids: A comma-separated list of certificate ids. If there is not at least one resource
                                that matches each of the elements of `certificate_ids`, then an error is
                                returned. This cannot be provided in conjunction with the
                                `certificate_names` parameter.
        :type certificate_ids: List[str]
        :param certificate_names: A comma-separated list of certificate names. If there is not at least one
                                resource that matches each of the elements of `certificate_names`, then an
                                error is returned. This cannot be provided in conjunction with the
                                `certificate_ids` parameter.
        :type certificate_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            certificate_group_ids=certificate_group_ids,
            certificate_group_names=certificate_group_names,
            certificate_ids=certificate_ids,
            certificate_names=certificate_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(certificate_groups, ['certificate_group_ids', 'certificate_group_names'], kwargs)
        _process_references(certificates, ['certificate_ids', 'certificate_names'], kwargs)
        _fixup_list_type_params(['certificate_group_ids', 'certificate_group_names', 'certificate_ids', 'certificate_names'], kwargs)
        return self._call_api('CertificatesApi', 'api217_certificates_certificate_groups_delete_with_http_info', kwargs)

    def get_certificates_certificate_groups(
        self,
        certificates: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        certificate_group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group ids. If there is not at least one resource that matches each of the elements of `certificate_group_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_names` parameter.")] = None,
        certificate_group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group names. If there is not at least one resource that matches each of the elements of `certificate_group_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_ids` parameter.")] = None,
        certificate_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate ids. If there is not at least one resource that matches each of the elements of `certificate_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_names` parameter.")] = None,
        certificate_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate names. If there is not at least one resource that matches each of the elements of `certificate_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_ids` parameter.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET certificates/certificate-groups
        
        List membership associations between groups and certificates.
        
        :param certificates: A list of certificates to query for. Overrides certificate_ids and certificate_names keyword arguments.
        :type certificates: ReferenceType or List[ReferenceType], optional
        :param certificate_groups: A list of certificate_groups to query for. Overrides certificate_group_ids and certificate_group_names keyword arguments.
        :type certificate_groups: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param certificate_group_ids: A comma-separated list of certificate group ids. If there is not at least one
                                    resource that matches each of the elements of `certificate_group_ids`,
                                    then an error is returned. This cannot be provided in conjunction with
                                    the `certificate_group_names` parameter.
        :type certificate_group_ids: List[str]
        :param certificate_group_names: A comma-separated list of certificate group names. If there is not at least one
                                        resource that matches each of the elements of `certificate_group_names`,
                                        then an error is returned. This cannot be provided in conjunction with
                                        the `certificate_group_ids` parameter.
        :type certificate_group_names: List[str]
        :param certificate_ids: A comma-separated list of certificate ids. If there is not at least one resource
                                that matches each of the elements of `certificate_ids`, then an error is
                                returned. This cannot be provided in conjunction with the
                                `certificate_names` parameter.
        :type certificate_ids: List[str]
        :param certificate_names: A comma-separated list of certificate names. If there is not at least one
                                resource that matches each of the elements of `certificate_names`, then an
                                error is returned. This cannot be provided in conjunction with the
                                `certificate_ids` parameter.
        :type certificate_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            certificate_group_ids=certificate_group_ids,
            certificate_group_names=certificate_group_names,
            certificate_ids=certificate_ids,
            certificate_names=certificate_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(certificate_groups, ['certificate_group_ids', 'certificate_group_names'], kwargs)
        _process_references(certificates, ['certificate_ids', 'certificate_names'], kwargs)
        _fixup_list_type_params(['certificate_group_ids', 'certificate_group_names', 'certificate_ids', 'certificate_names', 'sort'], kwargs)
        return self._call_api('CertificatesApi', 'api217_certificates_certificate_groups_get_with_http_info', kwargs)

    def post_certificates_certificate_groups(
        self,
        certificates: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        certificate_groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        certificate_group_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group ids. If there is not at least one resource that matches each of the elements of `certificate_group_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_names` parameter.")] = None,
        certificate_group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate group names. If there is not at least one resource that matches each of the elements of `certificate_group_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_group_ids` parameter.")] = None,
        certificate_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate ids. If there is not at least one resource that matches each of the elements of `certificate_ids`, then an error is returned. This cannot be provided in conjunction with the `certificate_names` parameter.")] = None,
        certificate_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of certificate names. If there is not at least one resource that matches each of the elements of `certificate_names`, then an error is returned. This cannot be provided in conjunction with the `certificate_ids` parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST certificates/certificate-groups
        
        Add one or more certificates to one or more certificate groups.
        
        :param certificates: A list of certificates to query for. Overrides certificate_ids and certificate_names keyword arguments.
        :type certificates: ReferenceType or List[ReferenceType], optional
        :param certificate_groups: A list of certificate_groups to query for. Overrides certificate_group_ids and certificate_group_names keyword arguments.
        :type certificate_groups: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param certificate_group_ids: A comma-separated list of certificate group ids. If there is not at least one
                                    resource that matches each of the elements of `certificate_group_ids`,
                                    then an error is returned. This cannot be provided in conjunction with
                                    the `certificate_group_names` parameter.
        :type certificate_group_ids: List[str]
        :param certificate_group_names: A comma-separated list of certificate group names. If there is not at least one
                                        resource that matches each of the elements of `certificate_group_names`,
                                        then an error is returned. This cannot be provided in conjunction with
                                        the `certificate_group_ids` parameter.
        :type certificate_group_names: List[str]
        :param certificate_ids: A comma-separated list of certificate ids. If there is not at least one resource
                                that matches each of the elements of `certificate_ids`, then an error is
                                returned. This cannot be provided in conjunction with the
                                `certificate_names` parameter.
        :type certificate_ids: List[str]
        :param certificate_names: A comma-separated list of certificate names. If there is not at least one
                                resource that matches each of the elements of `certificate_names`, then an
                                error is returned. This cannot be provided in conjunction with the
                                `certificate_ids` parameter.
        :type certificate_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            certificate_group_ids=certificate_group_ids,
            certificate_group_names=certificate_group_names,
            certificate_ids=certificate_ids,
            certificate_names=certificate_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(certificate_groups, ['certificate_group_ids', 'certificate_group_names'], kwargs)
        _process_references(certificates, ['certificate_ids', 'certificate_names'], kwargs)
        _fixup_list_type_params(['certificate_group_ids', 'certificate_group_names', 'certificate_ids', 'certificate_names'], kwargs)
        return self._call_api('CertificatesApi', 'api217_certificates_certificate_groups_post_with_http_info', kwargs)

    def delete_certificates(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE certificates
        
        Delete a CA certificate from the array.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('CertificatesApi', 'api217_certificates_delete_with_http_info', kwargs)

    def get_certificates(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET certificates
        
        List array certificates and their attributes.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('CertificatesApi', 'api217_certificates_get_with_http_info', kwargs)

    def patch_certificates(
        self,
        certificate: 'models.CertificatePatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH certificates
        
        Modify SSL certificate attributes such as passphrases and intermediate certificates.
        
        :param certificate: (required)
        :type certificate: CertificatePatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            certificate=certificate,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('CertificatesApi', 'api217_certificates_patch_with_http_info', kwargs)

    def post_certificates(
        self,
        certificate: 'models.CertificatePost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST certificates
        
        Upload a CA certificate to the array.
        
        :param certificate: (required)
        :type certificate: CertificatePost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            certificate=certificate,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('CertificatesApi', 'api217_certificates_post_with_http_info', kwargs)

    def get_certificates_uses(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET certificates/uses
        
        List how certificates are being used and by what.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('CertificatesApi', 'api217_certificates_uses_get_with_http_info', kwargs)

    def get_arrays_clients_performance(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET clients-performance
        
        List NFS client I/O performance metrics.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            names=names,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names', 'sort'], kwargs)
        return self._call_api('ClientsApi', 'api217_arrays_clients_performance_get_with_http_info', kwargs)

    def delete_dns(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE dns
        
        Deletes a DNS configuration.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('DNSApi', 'api217_dns_delete_with_http_info', kwargs)

    def get_dns(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET dns
        
        Displays the current DNS configurations and their parameters including domain suffix, the list of DNS name server IP addresses, and the list of services that DNS parameters apply to.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('DNSApi', 'api217_dns_get_with_http_info', kwargs)

    def patch_dns(
        self,
        dns: 'models.Dns',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH dns
        
        Modify a DNS configuration.
        
        :param dns: (required)
        :type dns: Dns
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            dns=dns,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('DNSApi', 'api217_dns_patch_with_http_info', kwargs)

    def post_dns(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        dns: 'models.DnsPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST dns
        
        Creates new DNS configuration with parameters including the domain suffix, the list of DNS name server IP addresses, and the list of services that DNS parameters apply to.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param dns: (required)
        :type dns: DnsPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            dns=dns,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('DNSApi', 'api217_dns_post_with_http_info', kwargs)

    def get_directory_services(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET directory-services
        
        List directory service configuration information.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api217_directory_services_get_with_http_info', kwargs)

    def patch_directory_services(
        self,
        directory_service: 'models.DirectoryService',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH directory-services
        
        Modifies and tests the directory service configuration.
        
        :param directory_service: (required)
        :type directory_service: DirectoryService
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            directory_service=directory_service,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api217_directory_services_patch_with_http_info', kwargs)

    def delete_directory_services_roles(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE directory-service/roles
        
        Delete an RBAC group configuration setting for manageability.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api217_directory_services_roles_delete_with_http_info', kwargs)

    def get_directory_services_roles(
        self,
        roles: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `names`, `role_names`, or `role_ids` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `names`, then an error is returned. This cannot be provided together with the `ids`, `role_names`, or `role_ids` query parameters.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        role_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of role_ids. If after filtering, there is not at least one resource that matches each of the elements of `role_ids`, then an error is returned. This cannot be provided together with the `ids`, `names` or `role_names` query parameters. This query parameter is deprecated for use with directory service roles. If this parameter is used to query or modify directory service roles, but more than 1 configuration exists with a given role id, an error will be returned in order to avoid ambiguous operation.")] = None,
        role_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of role_names. If there is not at least one resource that matches each of the elements of `role_names`, then an error is returned. This cannot be provided together with the `ids`, `names`, or `role_ids` query parameters. This query parameter is deprecated for use with directory service roles. If this parameter is used to query or modify directory service roles, but more than 1 configuration exists with a given role name, an error will be returned in order to avoid ambiguous operation.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET directory-service/roles
        
        Return array's RBAC group configuration settings for manageability.
        
        :param roles: A list of roles to query for. Overrides role_ids and role_names keyword arguments.
        :type roles: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `names`, `role_names`,
                    or `role_ids` query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `names`, then an
                    error is returned. This cannot be provided together with the `ids`,
                    `role_names`, or `role_ids` query parameters.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param role_ids: A comma-separated list of role_ids. If after filtering, there is not at least
                        one resource that matches each of the elements of `role_ids`, then an error
                        is returned. This cannot be provided together with the `ids`, `names` or
                        `role_names` query parameters. This query parameter is deprecated for use
                        with directory service roles. If this parameter is used to query or modify
                        directory service roles, but more than 1 configuration exists with a given
                        role id, an error will be returned in order to avoid ambiguous operation.
        :type role_ids: List[str]
        :param role_names: A comma-separated list of role_names. If there is not at least one resource that
                        matches each of the elements of `role_names`, then an error is returned.
                        This cannot be provided together with the `ids`, `names`, or `role_ids`
                        query parameters. This query parameter is deprecated for use with directory
                        service roles. If this parameter is used to query or modify directory
                        service roles, but more than 1 configuration exists with a given role name,
                        an error will be returned in order to avoid ambiguous operation.
        :type role_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            role_ids=role_ids,
            role_names=role_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _process_references(roles, ['role_ids', 'role_names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'role_ids', 'role_names', 'sort'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api217_directory_services_roles_get_with_http_info', kwargs)

    def patch_directory_services_roles(
        self,
        directory_service_roles: 'models.DirectoryServiceRole',
        roles: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `names`, `role_names`, or `role_ids` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `names`, then an error is returned. This cannot be provided together with the `ids`, `role_names`, or `role_ids` query parameters.")] = None,
        role_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of role_ids. If after filtering, there is not at least one resource that matches each of the elements of `role_ids`, then an error is returned. This cannot be provided together with the `ids`, `names` or `role_names` query parameters. This query parameter is deprecated for use with directory service roles. If this parameter is used to query or modify directory service roles, but more than 1 configuration exists with a given role id, an error will be returned in order to avoid ambiguous operation.")] = None,
        role_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of role_names. If there is not at least one resource that matches each of the elements of `role_names`, then an error is returned. This cannot be provided together with the `ids`, `names`, or `role_ids` query parameters. This query parameter is deprecated for use with directory service roles. If this parameter is used to query or modify directory service roles, but more than 1 configuration exists with a given role name, an error will be returned in order to avoid ambiguous operation.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH directory-service/roles
        
        Update an RBAC group configuration setting for manageability.
        
        :param directory_service_roles: (required)
        :type directory_service_roles: DirectoryServiceRole
        :param roles: A list of roles to query for. Overrides role_ids and role_names keyword arguments.
        :type roles: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `names`, `role_names`,
                    or `role_ids` query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `names`, then an
                    error is returned. This cannot be provided together with the `ids`,
                    `role_names`, or `role_ids` query parameters.
        :type names: List[str]
        :param role_ids: A comma-separated list of role_ids. If after filtering, there is not at least
                        one resource that matches each of the elements of `role_ids`, then an error
                        is returned. This cannot be provided together with the `ids`, `names` or
                        `role_names` query parameters. This query parameter is deprecated for use
                        with directory service roles. If this parameter is used to query or modify
                        directory service roles, but more than 1 configuration exists with a given
                        role id, an error will be returned in order to avoid ambiguous operation.
        :type role_ids: List[str]
        :param role_names: A comma-separated list of role_names. If there is not at least one resource that
                        matches each of the elements of `role_names`, then an error is returned.
                        This cannot be provided together with the `ids`, `names`, or `role_ids`
                        query parameters. This query parameter is deprecated for use with directory
                        service roles. If this parameter is used to query or modify directory
                        service roles, but more than 1 configuration exists with a given role name,
                        an error will be returned in order to avoid ambiguous operation.
        :type role_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            directory_service_roles=directory_service_roles,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            role_ids=role_ids,
            role_names=role_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _process_references(roles, ['role_ids', 'role_names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'role_ids', 'role_names'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api217_directory_services_roles_patch_with_http_info', kwargs)

    def post_directory_services_roles(
        self,
        directory_service_roles: 'models.DirectoryServiceRole',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST directory-service/roles
        
        Create an RBAC group configuration setting for manageability.
        
        :param directory_service_roles: (required)
        :type directory_service_roles: DirectoryServiceRole
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            directory_service_roles=directory_service_roles,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api217_directory_services_roles_post_with_http_info', kwargs)

    def get_directory_services_test(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET directory-services/test
        
        Test the configured directory services on the array.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api217_directory_services_test_get_with_http_info', kwargs)

    def patch_directory_services_test(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        directory_service: Annotated[Optional['models.DirectoryService'], Field(description="An optional directory service configuration that, if provided, will be used to overwrite aspects of the existing directory service objects when performing tests.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH directory-service/test
        
        Test the configured directory services on the array. Optionally, provide modifications which will be used to perform the tests, but will not be applied to the current configuration.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param directory_service: An optional directory service configuration that, if provided, will be used to
                                overwrite aspects of the existing directory service objects when
                                performing tests.
        :type directory_service: DirectoryService
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            names=names,
            sort=sort,
            directory_service=directory_service,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('DirectoryServicesApi', 'api217_directory_services_test_patch_with_http_info', kwargs)

    def get_drives(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET drives
        
        List array drive information.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('DrivesApi', 'api217_drives_get_with_http_info', kwargs)

    def delete_file_system_exports(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE file-system-exports
        
        Deletes a file system export.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names'], kwargs)
        return self._call_api('FileSystemExportsApi', 'api217_file_system_exports_delete_with_http_info', kwargs)

    def get_file_system_exports(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-system-exports
        
        List one or more file system exports.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'sort'], kwargs)
        return self._call_api('FileSystemExportsApi', 'api217_file_system_exports_get_with_http_info', kwargs)

    def patch_file_system_exports(
        self,
        file_system_export: 'models.FileSystemExport',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH file-system-exports
        
        Modify a file system exports attributes.
        
        :param file_system_export: (required)
        :type file_system_export: FileSystemExport
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            file_system_export=file_system_export,
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names'], kwargs)
        return self._call_api('FileSystemExportsApi', 'api217_file_system_exports_patch_with_http_info', kwargs)

    def post_file_system_exports(
        self,
        file_system_export: 'models.FileSystemExportPost',
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST file-system-exports
        
        Create a file system export.
        
        :param file_system_export: (required)
        :type file_system_export: FileSystemExportPost
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            file_system_export=file_system_export,
            x_request_id=x_request_id,
            context_names=context_names,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('FileSystemExportsApi', 'api217_file_system_exports_post_with_http_info', kwargs)

    def delete_file_system_replica_links(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        cancel_in_progress_transfers: Annotated[Optional[StrictBool], Field(description="This parameter must be set to `true` in order to delete a file system replication link (which can cancel any in-progress replication transfers). Setting this parameter to `true` is acknowledgement that any in-progress replication transfers on the specified links will be cancelled when this request is fulfilled.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        remote_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system IDs. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_names` query parameter.")] = None,
        remote_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_ids` query parameter.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE file-system-replica-links
        
        Delete a file system replication link.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param remote_file_systems: A list of remote_file_systems to query for. Overrides remote_file_system_ids and remote_file_system_names keyword arguments.
        :type remote_file_systems: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param cancel_in_progress_transfers: This parameter must be set to `true` in order to delete a file system
                                            replication link (which can cancel any in-progress replication
                                            transfers). Setting this parameter to `true` is acknowledgement that
                                            any in-progress replication transfers on the specified links will be
                                            cancelled when this request is fulfilled.
        :type cancel_in_progress_transfers: bool
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param remote_file_system_ids: A comma-separated list of remote file system IDs. If there is not at least one
                                    resource that matches each of the elements, then an error is returned.
                                    This cannot be provided together with the `remote_file_system_names`
                                    query parameter.
        :type remote_file_system_ids: List[str]
        :param remote_file_system_names: A comma-separated list of remote file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with the `remote_file_system_ids` query
                                        parameter.
        :type remote_file_system_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            cancel_in_progress_transfers=cancel_in_progress_transfers,
            context_names=context_names,
            ids=ids,
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            remote_file_system_ids=remote_file_system_ids,
            remote_file_system_names=remote_file_system_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids'], kwargs)
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(remote_file_systems, ['remote_file_system_ids', 'remote_file_system_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'local_file_system_ids', 'local_file_system_names', 'remote_file_system_ids', 'remote_file_system_names', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('FileSystemReplicaLinksApi', 'api217_file_system_replica_links_delete_with_http_info', kwargs)

    def get_file_system_replica_links(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        remote_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system IDs. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_names` query parameter.")] = None,
        remote_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_ids` query parameter.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-system-replica-links
        
        List file system replication link.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param remote_file_systems: A list of remote_file_systems to query for. Overrides remote_file_system_ids and remote_file_system_names keyword arguments.
        :type remote_file_systems: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param remote_file_system_ids: A comma-separated list of remote file system IDs. If there is not at least one
                                    resource that matches each of the elements, then an error is returned.
                                    This cannot be provided together with the `remote_file_system_names`
                                    query parameter.
        :type remote_file_system_ids: List[str]
        :param remote_file_system_names: A comma-separated list of remote file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with the `remote_file_system_ids` query
                                        parameter.
        :type remote_file_system_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            offset=offset,
            remote_file_system_ids=remote_file_system_ids,
            remote_file_system_names=remote_file_system_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids'], kwargs)
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(remote_file_systems, ['remote_file_system_ids', 'remote_file_system_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'local_file_system_ids', 'local_file_system_names', 'remote_file_system_ids', 'remote_file_system_names', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('FileSystemReplicaLinksApi', 'api217_file_system_replica_links_get_with_http_info', kwargs)

    def patch_file_system_replica_links(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        replicate_now: Annotated[Optional[StrictBool], Field(description="If set to `true`, replicates the contents to the specified targets. The `replicate_now` parameters can only be `true` with the partial-replica file system links.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH file-system-replica-links
        
        Update a file system replication link.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param replicate_now: If set to `true`, replicates the contents to the specified targets. The
                            `replicate_now` parameters can only be `true` with the partial-replica file
                            system links.
        :type replicate_now: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            replicate_now=replicate_now,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids'], kwargs)
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'local_file_system_ids', 'local_file_system_names', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('FileSystemReplicaLinksApi', 'api217_file_system_replica_links_patch_with_http_info', kwargs)

    def delete_file_system_replica_links_policies(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE file-system-replica-links/policies
        
        Remove a policy from a file system replication link.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            member_ids=member_ids,
            policy_ids=policy_ids,
            policy_names=policy_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(members, ['member_ids'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['context_names', 'local_file_system_ids', 'local_file_system_names', 'member_ids', 'policy_ids', 'policy_names', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('FileSystemReplicaLinksApi', 'api217_file_system_replica_links_policies_delete_with_http_info', kwargs)

    def get_file_system_replica_links_policies(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        remote_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system IDs. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_names` query parameter.")] = None,
        remote_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_ids` query parameter.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-system-replica-links/policies
        
        List file system replication link policies.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param remote_file_systems: A list of remote_file_systems to query for. Overrides remote_file_system_ids and remote_file_system_names keyword arguments.
        :type remote_file_systems: ReferenceType or List[ReferenceType], optional
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_file_system_ids: A comma-separated list of remote file system IDs. If there is not at least one
                                    resource that matches each of the elements, then an error is returned.
                                    This cannot be provided together with the `remote_file_system_names`
                                    query parameter.
        :type remote_file_system_ids: List[str]
        :param remote_file_system_names: A comma-separated list of remote file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with the `remote_file_system_ids` query
                                        parameter.
        :type remote_file_system_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            member_ids=member_ids,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            remote_file_system_ids=remote_file_system_ids,
            remote_file_system_names=remote_file_system_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(members, ['member_ids'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _process_references(remote_file_systems, ['remote_file_system_ids', 'remote_file_system_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['context_names', 'local_file_system_ids', 'local_file_system_names', 'member_ids', 'policy_ids', 'policy_names', 'remote_file_system_ids', 'remote_file_system_names', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('FileSystemReplicaLinksApi', 'api217_file_system_replica_links_policies_get_with_http_info', kwargs)

    def post_file_system_replica_links_policies(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST file-system-replica-links/policies
        
        Add a policy to a file system replication link.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            member_ids=member_ids,
            policy_ids=policy_ids,
            policy_names=policy_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(members, ['member_ids'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['context_names', 'local_file_system_ids', 'local_file_system_names', 'member_ids', 'policy_ids', 'policy_names', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('FileSystemReplicaLinksApi', 'api217_file_system_replica_links_policies_post_with_http_info', kwargs)

    def post_file_system_replica_links(
        self,
        file_system_replica_link: 'models.FileSystemReplicaLink',
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        remote_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_ids` query parameter.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST file-system-replica-links
        
        Create a file system replication link.
        
        :param file_system_replica_link: (required)
        :type file_system_replica_link: FileSystemReplicaLink
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param remote_file_systems: A list of remote_file_systems to query for. Overrides remote_file_system_names keyword argument.
        :type remote_file_systems: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param remote_file_system_names: A comma-separated list of remote file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with the `remote_file_system_ids` query
                                        parameter.
        :type remote_file_system_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            file_system_replica_link=file_system_replica_link,
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            remote_file_system_names=remote_file_system_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids'], kwargs)
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(remote_file_systems, ['remote_file_system_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'local_file_system_ids', 'local_file_system_names', 'remote_file_system_names', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('FileSystemReplicaLinksApi', 'api217_file_system_replica_links_post_with_http_info', kwargs)

    def get_file_system_replica_links_transfer(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        names_or_owners: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names_or_owner_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. Either the names of the snapshots or the owning file systems.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-system-replica-links/transfer
        
        List the transfer status details for file system replication.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param names_or_owners: A list of names_or_owners to query for. Overrides names_or_owner_names keyword argument.
        :type names_or_owners: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names_or_owner_names: A comma-separated list of resource names. Either the names of the snapshots or
                                    the owning file systems.
        :type names_or_owner_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names_or_owner_names=names_or_owner_names,
            offset=offset,
            remote_ids=remote_ids,
            remote_names=remote_names,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids'], kwargs)
        _process_references(names_or_owners, ['names_or_owner_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names_or_owner_names', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('FileSystemReplicaLinksApi', 'api217_file_system_replica_links_transfer_get_with_http_info', kwargs)

    def delete_file_system_snapshots(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE file-system-snapshots
        
        Delete a file system snapshot.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names'], kwargs)
        return self._call_api('FileSystemSnapshotsApi', 'api217_file_system_snapshots_delete_with_http_info', kwargs)

    def get_file_system_snapshots(
        self,
        owners: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        names_or_owners: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. If not set, lists both objects that are destroyed and those that are not destroyed. If object name(s) are specified in the `names` parameter, then each object referenced must exist. If `destroyed` is set to `true`, then each object referenced must also be destroyed. If `destroyed` is set to `false`, then each object referenced must also not be destroyed. An error is returned if any of these conditions are not met.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names_or_owner_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. Either the names of the snapshots or the owning file systems.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        owner_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of owning file system IDs. If after filtering, there is not at least one resource that matches each of the elements of owner IDs, then an error is returned. This cannot be provided together with the `ids`, `names_or_owner_names`, or `names_or_sources` query parameters.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-system-snapshots
        
        List file system snapshots. Note: if more than 150,000 items would be returned in the response, an error will be thrown and query parameters must be used to limit the items queried.
        
        :param owners: A list of owners to query for. Overrides owner_ids keyword argument.
        :type owners: ReferenceType or List[ReferenceType], optional
        :param names_or_owners: A list of names_or_owners to query for. Overrides names_or_owner_names keyword argument.
        :type names_or_owners: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        If not set, lists both objects that are destroyed and those that are not
                        destroyed. If object name(s) are specified in the `names` parameter, then
                        each object referenced must exist. If `destroyed` is set to `true`, then
                        each object referenced must also be destroyed. If `destroyed` is set to
                        `false`, then each object referenced must also not be destroyed. An error is
                        returned if any of these conditions are not met.
        :type destroyed: bool
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names_or_owner_names: A comma-separated list of resource names. Either the names of the snapshots or
                                    the owning file systems.
        :type names_or_owner_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param owner_ids: A comma-separated list of owning file system IDs. If after filtering, there is
                        not at least one resource that matches each of the elements of owner IDs,
                        then an error is returned. This cannot be provided together with the `ids`,
                        `names_or_owner_names`, or `names_or_sources` query parameters.
        :type owner_ids: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names_or_owner_names=names_or_owner_names,
            offset=offset,
            owner_ids=owner_ids,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids'], kwargs)
        _process_references(names_or_owners, ['names_or_owner_names'], kwargs)
        _process_references(owners, ['owner_ids'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names_or_owner_names', 'owner_ids', 'sort'], kwargs)
        return self._call_api('FileSystemSnapshotsApi', 'api217_file_system_snapshots_get_with_http_info', kwargs)

    def patch_file_system_snapshots(
        self,
        file_system_snapshot: 'models.FileSystemSnapshot',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        latest_replica: Annotated[Optional[StrictBool], Field(description="Used when destroying a snapshot. If not present or `false`, and the snapshot is the latest replicated snapshot, then destroy will fail. If `true` or the snapshot is not the latest replicated snapshot, then destroy will be successful.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH file-system-snapshots
        
        Modify file system snapshot attributes.
        
        :param file_system_snapshot: (required)
        :type file_system_snapshot: FileSystemSnapshot
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param latest_replica: Used when destroying a snapshot. If not present or `false`, and the snapshot is
                            the latest replicated snapshot, then destroy will fail. If `true` or the
                            snapshot is not the latest replicated snapshot, then destroy will be
                            successful.
        :type latest_replica: bool
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            file_system_snapshot=file_system_snapshot,
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            latest_replica=latest_replica,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names'], kwargs)
        return self._call_api('FileSystemSnapshotsApi', 'api217_file_system_snapshots_patch_with_http_info', kwargs)

    def delete_file_system_snapshots_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE file-system-snapshots/policies
        
        Remove snapshot scheduling policies from a file system.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('FileSystemSnapshotsApi', 'api217_file_system_snapshots_policies_delete_with_http_info', kwargs)

    def get_file_system_snapshots_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-system-snapshots/policies
        
        List file system snapshots mapped to snapshot scheduling policies. Note: if more than 150,000 items would be returned in the response, an error will be thrown and query parameters must be used to limit the items queried.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('FileSystemSnapshotsApi', 'api217_file_system_snapshots_policies_get_with_http_info', kwargs)

    def post_file_system_snapshots(
        self,
        sources: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        send: Annotated[Optional[StrictBool], Field(description="Whether to replicate created snapshots immediately to other arrays. If it's `false`, created snapshots may still be replicated to other arrays according to policy.")] = None,
        source_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of source file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `source_ids`, then an error is returned. This cannot be provided together with the `names_or_sources` or `sources` query parameters.")] = None,
        source_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of names for the source of the object. If there is not at least one resource that matches each of the elements of `source_names`, an error is returned.")] = None,
        targets: Annotated[Optional[conlist(StrictStr)], Field(description="The target arrays to replicate created snapshots to. Only valid when `send` is `true`.")] = None,
        file_system_snapshot: Optional['models.FileSystemSnapshotPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST file-system-snapshots
        
        Create a snapshot for a specified source file system. If a source file system is not specified, creates snapshots for all file systems on the array.
        
        :param sources: A list of sources to query for. Overrides source_ids and source_names keyword arguments.
        :type sources: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param send: Whether to replicate created snapshots immediately to other arrays. If it's
                    `false`, created snapshots may still be replicated to other arrays according
                    to policy.
        :type send: bool
        :param source_ids: A comma-separated list of source file system IDs. If after filtering, there is
                        not at least one resource that matches each of the elements of `source_ids`,
                        then an error is returned. This cannot be provided together with the
                        `names_or_sources` or `sources` query parameters.
        :type source_ids: List[str]
        :param source_names: A comma-separated list of names for the source of the object. If there is not at
                            least one resource that matches each of the elements of `source_names`, an
                            error is returned.
        :type source_names: List[str]
        :param targets: The target arrays to replicate created snapshots to. Only valid when `send` is
                        `true`.
        :type targets: List[str]
        :param file_system_snapshot:
        :type file_system_snapshot: FileSystemSnapshotPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            send=send,
            source_ids=source_ids,
            source_names=source_names,
            targets=targets,
            file_system_snapshot=file_system_snapshot,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(sources, ['source_ids', 'source_names'], kwargs)
        _fixup_list_type_params(['context_names', 'source_ids', 'source_names', 'targets'], kwargs)
        return self._call_api('FileSystemSnapshotsApi', 'api217_file_system_snapshots_post_with_http_info', kwargs)

    def delete_file_system_snapshots_transfer(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE file-system-snapshots/transfer
        
        Delete file system snapshot transfers from the source array to the target array.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('FileSystemSnapshotsApi', 'api217_file_system_snapshots_transfer_delete_with_http_info', kwargs)

    def get_file_system_snapshots_transfer(
        self,
        names_or_owners: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names_or_owner_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. Either the names of the snapshots or the owning file systems.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-system-snapshots/transfer
        
        List file system snapshot transfers from the source array to the target array. Note: if more than 150,000 items would be returned in the response, an error will be thrown and query parameters must be used to limit the items queried.
        
        :param names_or_owners: A list of names_or_owners to query for. Overrides names_or_owner_names keyword argument.
        :type names_or_owners: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names_or_owner_names: A comma-separated list of resource names. Either the names of the snapshots or
                                    the owning file systems.
        :type names_or_owner_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names_or_owner_names=names_or_owner_names,
            offset=offset,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids'], kwargs)
        _process_references(names_or_owners, ['names_or_owner_names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names_or_owner_names', 'sort'], kwargs)
        return self._call_api('FileSystemSnapshotsApi', 'api217_file_system_snapshots_transfer_get_with_http_info', kwargs)

    def delete_file_systems_audit_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE file-systems/audit-policies
        
        Remove the audit policy mapped to a file system.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('FileSystemsApi', 'api217_file_systems_audit_policies_delete_with_http_info', kwargs)

    def get_file_systems_audit_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-systems/audit-policies
        
        List file systems mapped to a audit policy.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('FileSystemsApi', 'api217_file_systems_audit_policies_get_with_http_info', kwargs)

    def post_file_systems_audit_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST file-systems/audit-policies
        
        Map a audit policy to a file system.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('FileSystemsApi', 'api217_file_systems_audit_policies_post_with_http_info', kwargs)

    def delete_file_systems(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE file-systems
        
        Deletes a file system. Deleting a file system is equivalent to eradication. A file system's `destroyed` parameter must be set to `true` before a file system can be deleted.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names'], kwargs)
        return self._call_api('FileSystemsApi', 'api217_file_systems_delete_with_http_info', kwargs)

    def get_file_systems(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        destroyed: Annotated[Optional[StrictBool], Field(description="If set to `true`, lists only destroyed objects that are in the eradication pending state. If set to `false`, lists only objects that are not destroyed. If not set, lists both objects that are destroyed and those that are not destroyed. If object name(s) are specified in the `names` parameter, then each object referenced must exist. If `destroyed` is set to `true`, then each object referenced must also be destroyed. If `destroyed` is set to `false`, then each object referenced must also not be destroyed. An error is returned if any of these conditions are not met.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-systems
        
        List one or more file systems on the array.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param destroyed: If set to `true`, lists only destroyed objects that are in the eradication
                        pending state. If set to `false`, lists only objects that are not destroyed.
                        If not set, lists both objects that are destroyed and those that are not
                        destroyed. If object name(s) are specified in the `names` parameter, then
                        each object referenced must exist. If `destroyed` is set to `true`, then
                        each object referenced must also be destroyed. If `destroyed` is set to
                        `false`, then each object referenced must also not be destroyed. An error is
                        returned if any of these conditions are not met.
        :type destroyed: bool
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            destroyed=destroyed,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'sort'], kwargs)
        return self._call_api('FileSystemsApi', 'api217_file_systems_get_with_http_info', kwargs)

    def get_file_systems_groups_performance(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        gids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group IDs. This cannot be provided together with `group_names` query parameter.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group names. This cannot be provided together with `gids` query parameter.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-systems/groups/performance
        
        List a groups I/O performance metrics on a file system.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param gids: A comma-separated list of group IDs. This cannot be provided together with
                    `group_names` query parameter.
        :type gids: List[str]
        :param group_names: A comma-separated list of group names. This cannot be provided together with
                            `gids` query parameter.
        :type group_names: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            gids=gids,
            group_names=group_names,
            limit=limit,
            names=names,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(groups, ['group_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'gids', 'group_names', 'names', 'sort'], kwargs)
        return self._call_api('FileSystemsApi', 'api217_file_systems_groups_performance_get_with_http_info', kwargs)

    def get_file_systems_locks_clients(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Get a list of clients that hold active file locks
        
        Lists all clients that hold active file locks.
        
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('FileSystemsApi', 'api217_file_systems_locks_clients_get_with_http_info', kwargs)

    def delete_file_systems_locks(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        clients: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        client_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of ip addresses of clients. For IPv6 both the extended format (x:x:x:x:x:x:x:x) and the shortened format are supported.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        inodes: Annotated[Optional[conlist(Union[StrictFloat, StrictInt])], Field(description="A comma-separated list of inodes used for filtering file locks query by inodes. This may only be specified if `file_system_ids` or `file_system_names` is also specified. This cannot be provided together with the `paths` query parameter.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        paths: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of paths used for filtering file locks query by paths. This may only be specified if `file_system_ids` or `file_system_names` is also specified. This cannot be provided together with the `inodes` query parameter.")] = None,
        recursive: Annotated[Optional[StrictBool], Field(description="Flag used to indicate that the action should be done recursively. If set to `true` and used e.g. with `path` pointing to a directory, the operation will delete all locks in given directory and subdirectories recursively. For more fine grained control over deleted locks, use delete by name. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Invalidate file locks
        
        Invalidates file locks. It can be used to either delete an individual lock by name or multiple locks filtered by parameters. E.g. to delete locks held by a client on specific file, parameters `client_names`, `file_system_ids` or `file_system_names` and `path` must be specified. When `names` is specified, no other query parameter can be specified.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param clients: A list of clients to query for. Overrides client_names keyword argument.
        :type clients: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param client_names: A comma-separated list of ip addresses of clients. For IPv6 both the extended
                            format (x:x:x:x:x:x:x:x) and the shortened format are supported.
        :type client_names: List[str]
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param inodes: A comma-separated list of inodes used for filtering file locks query by inodes.
                    This may only be specified if `file_system_ids` or `file_system_names` is
                    also specified. This cannot be provided together with the `paths` query
                    parameter.
        :type inodes: List[float]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param paths: A comma-separated list of paths used for filtering file locks query by paths.
                    This may only be specified if `file_system_ids` or `file_system_names` is
                    also specified. This cannot be provided together with the `inodes` query
                    parameter.
        :type paths: List[str]
        :param recursive: Flag used to indicate that the action should be done recursively. If set to
                        `true` and used e.g. with `path` pointing to a directory, the operation will
                        delete all locks in given directory and subdirectories recursively. For more
                        fine grained control over deleted locks, use delete by name. If not
                        specified, defaults to `false`.
        :type recursive: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            client_names=client_names,
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            inodes=inodes,
            names=names,
            paths=paths,
            recursive=recursive,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(clients, ['client_names'], kwargs)
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['client_names', 'file_system_ids', 'file_system_names', 'inodes', 'names', 'paths'], kwargs)
        return self._call_api('FileSystemsApi', 'api217_file_systems_locks_delete_with_http_info', kwargs)

    def get_file_systems_locks(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        clients: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        client_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of ip addresses of clients. For IPv6 both the extended format (x:x:x:x:x:x:x:x) and the shortened format are supported.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        inodes: Annotated[Optional[conlist(Union[StrictFloat, StrictInt])], Field(description="A comma-separated list of inodes used for filtering file locks query by inodes. This may only be specified if `file_system_ids` or `file_system_names` is also specified. This cannot be provided together with the `paths` query parameter.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        paths: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of paths used for filtering file locks query by paths. This may only be specified if `file_system_ids` or `file_system_names` is also specified. This cannot be provided together with the `inodes` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Get a list of active file locks
        
        Lists all active file locks that satisfy the conditions specified by the parameters.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param clients: A list of clients to query for. Overrides client_names keyword argument.
        :type clients: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param client_names: A comma-separated list of ip addresses of clients. For IPv6 both the extended
                            format (x:x:x:x:x:x:x:x) and the shortened format are supported.
        :type client_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param inodes: A comma-separated list of inodes used for filtering file locks query by inodes.
                    This may only be specified if `file_system_ids` or `file_system_names` is
                    also specified. This cannot be provided together with the `paths` query
                    parameter.
        :type inodes: List[float]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param paths: A comma-separated list of paths used for filtering file locks query by paths.
                    This may only be specified if `file_system_ids` or `file_system_names` is
                    also specified. This cannot be provided together with the `inodes` query
                    parameter.
        :type paths: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            client_names=client_names,
            continuation_token=continuation_token,
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            inodes=inodes,
            limit=limit,
            names=names,
            paths=paths,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(clients, ['client_names'], kwargs)
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['client_names', 'file_system_ids', 'file_system_names', 'inodes', 'names', 'paths'], kwargs)
        return self._call_api('FileSystemsApi', 'api217_file_systems_locks_get_with_http_info', kwargs)

    def post_file_systems_locks_nlm_reclamations(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Initiate NLM reclamation.
        
        NLM reclamation is a system-wide operation, affecting all clients, and so only one may be in progress at a time. Attempting to initiate reclamation while one is in progress will result in an error. When NLM reclamation is initiated, all NLM locks are deleted and client applications are notified that they can reacquire their locks within a grace period.
        
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('FileSystemsApi', 'api217_file_systems_locks_nlm_reclamations_post_with_http_info', kwargs)

    def delete_file_systems_open_files(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE file-systems/open-files
        
        Close open file from given identifiers.
        
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids'], kwargs)
        _fixup_list_type_params(['ids'], kwargs)
        return self._call_api('FileSystemsApi', 'api217_file_systems_open_files_delete_with_http_info', kwargs)

    def get_file_systems_open_files(
        self,
        protocols: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of file protocols. Valid values include `nfs` and `smb`.")],
        users: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        sessions: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        clients: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        client_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of ip addresses of clients. For IPv6 both the extended format (x:x:x:x:x:x:x:x) and the shortened format are supported.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        paths: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of paths used for filtering open files query.")] = None,
        session_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of session names used for filtering open files query. Files opened in any of the specified sessions will be returned.")] = None,
        user_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of user names used for filtering open files query. Files opened by any of the specified users will be returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-systems/open-files
        
        List open files.
        
        :param protocols: A comma-separated list of file protocols. Valid values include `nfs` and `smb`.
                        (required)
        :type protocols: List[str]
        :param users: A list of users to query for. Overrides user_names keyword argument.
        :type users: ReferenceType or List[ReferenceType], optional
        :param sessions: A list of sessions to query for. Overrides session_names keyword argument.
        :type sessions: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param clients: A list of clients to query for. Overrides client_names keyword argument.
        :type clients: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param client_names: A comma-separated list of ip addresses of clients. For IPv6 both the extended
                            format (x:x:x:x:x:x:x:x) and the shortened format are supported.
        :type client_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param paths: A comma-separated list of paths used for filtering open files query.
        :type paths: List[str]
        :param session_names: A comma-separated list of session names used for filtering open files query.
                            Files opened in any of the specified sessions will be returned.
        :type session_names: List[str]
        :param user_names: A comma-separated list of user names used for filtering open files query. Files
                        opened by any of the specified users will be returned.
        :type user_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            protocols=protocols,
            x_request_id=x_request_id,
            client_names=client_names,
            continuation_token=continuation_token,
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            ids=ids,
            limit=limit,
            paths=paths,
            session_names=session_names,
            user_names=user_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(clients, ['client_names'], kwargs)
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(references, ['ids'], kwargs)
        _process_references(sessions, ['session_names'], kwargs)
        _process_references(users, ['user_names'], kwargs)
        _fixup_list_type_params(['protocols', 'client_names', 'file_system_ids', 'file_system_names', 'ids', 'paths', 'session_names', 'user_names'], kwargs)
        return self._call_api('FileSystemsApi', 'api217_file_systems_open_files_get_with_http_info', kwargs)

    def patch_file_systems(
        self,
        file_system: 'models.FileSystemPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        cancel_in_progress_storage_class_transition: Annotated[Optional[StrictBool], Field(description="If set to `true`, the storage class policy of this file system will be set to the requested storage class policy, even if a transition to a different storage class is in-progress. Setting this parameter to `true` is acknowledgement that any in-progress transition on this file system will be cancelled. If not specified, the default value is `false`.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        delete_link_on_eradication: Annotated[Optional[StrictBool], Field(description="If set to `true`, the file system can be destroyed, even if it has a replica link. If set to `false`, the file system cannot be destroyed if it has a replica link. Defaults to `false`.")] = None,
        discard_detailed_permissions: Annotated[Optional[StrictBool], Field(description="This parameter must be set to `true` in order to change a file system's `access_control_style` from a style that supports more detailed access control lists to a style that only supports less detailed mode bits as a form of permission control. This parameter may not be set to `true` any other time. Setting this parameter to `true` is acknowledgement that any more detailed access control lists currently set within the file system will be lost, and NFS permission controls will only be enforced at the granularity level of NFS mode bits.")] = None,
        discard_non_snapshotted_data: Annotated[Optional[StrictBool], Field(description="This parameter must be set to `true` in order to restore a file system from a snapshot or to demote a file system (which restores the file system from the common baseline snapshot). Setting this parameter to `true` is acknowledgement that any non-snapshotted data currently in the file system will be irretrievably lost.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        ignore_usage: Annotated[Optional[StrictBool], Field(description="Allow update operations that lead to a `hard_limit_enabled` object store account, bucket, or file system with usage over its limiting value. For object store accounts and buckets, the limiting value is that of `quota_limit`, and for file systems it is that of `provisioned`. The operation can be setting `hard_limit_enabled` when usage is higher than the limiting value, modifying the limiting value to a value under usage when `hard_limit_enabled`, recovering a destroyed bucket of an object store account that causes an account's space usage to go over its hard `quota_limit`. Also allows update operations that would cause usage of the requested storage class to go over its warning threshold.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH file-systems
        
        Modify a file system's attributes including its export protocols and limits.
        
        :param file_system: (required)
        :type file_system: FileSystemPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param cancel_in_progress_storage_class_transition: If set to `true`, the storage class policy of this file system will be set to
                                                            the requested storage class policy, even if a transition to a
                                                            different storage class is in-progress. Setting this parameter to
                                                            `true` is acknowledgement that any in-progress transition on this
                                                            file system will be cancelled. If not specified, the default value
                                                            is `false`.
        :type cancel_in_progress_storage_class_transition: bool
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param delete_link_on_eradication: If set to `true`, the file system can be destroyed, even if it has a replica
                                        link. If set to `false`, the file system cannot be destroyed if it has a
                                        replica link. Defaults to `false`.
        :type delete_link_on_eradication: bool
        :param discard_detailed_permissions: This parameter must be set to `true` in order to change a file system's
                                            `access_control_style` from a style that supports more detailed access
                                            control lists to a style that only supports less detailed mode bits as
                                            a form of permission control. This parameter may not be set to `true`
                                            any other time. Setting this parameter to `true` is acknowledgement
                                            that any more detailed access control lists currently set within the
                                            file system will be lost, and NFS permission controls will only be
                                            enforced at the granularity level of NFS mode bits.
        :type discard_detailed_permissions: bool
        :param discard_non_snapshotted_data: This parameter must be set to `true` in order to restore a file system from a
                                            snapshot or to demote a file system (which restores the file system
                                            from the common baseline snapshot). Setting this parameter to `true` is
                                            acknowledgement that any non-snapshotted data currently in the file
                                            system will be irretrievably lost.
        :type discard_non_snapshotted_data: bool
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param ignore_usage: Allow update operations that lead to a `hard_limit_enabled` object store
                            account, bucket, or file system with usage over its limiting value. For
                            object store accounts and buckets, the limiting value is that of
                            `quota_limit`, and for file systems it is that of `provisioned`. The
                            operation can be setting `hard_limit_enabled` when usage is higher than the
                            limiting value, modifying the limiting value to a value under usage when
                            `hard_limit_enabled`, recovering a destroyed bucket of an object store
                            account that causes an account's space usage to go over its hard
                            `quota_limit`. Also allows update operations that would cause usage of the
                            requested storage class to go over its warning threshold.
        :type ignore_usage: bool
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            file_system=file_system,
            x_request_id=x_request_id,
            cancel_in_progress_storage_class_transition=cancel_in_progress_storage_class_transition,
            context_names=context_names,
            delete_link_on_eradication=delete_link_on_eradication,
            discard_detailed_permissions=discard_detailed_permissions,
            discard_non_snapshotted_data=discard_non_snapshotted_data,
            ids=ids,
            ignore_usage=ignore_usage,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names'], kwargs)
        return self._call_api('FileSystemsApi', 'api217_file_systems_patch_with_http_info', kwargs)

    def get_file_systems_performance(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        protocol: Annotated[Optional[StrictStr], Field(description="Display the performance of a specified protocol. Valid values are `all`, `HTTP`, `SMB`, `NFS`, and `S3`. If not specified, defaults to `all`, which will provide the combined performance of all available protocols.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-systems/performance
        
        Displays the performance metrics for a file system.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param protocol: Display the performance of a specified protocol. Valid values are `all`, `HTTP`,
                        `SMB`, `NFS`, and `S3`. If not specified, defaults to `all`, which will
                        provide the combined performance of all available protocols.
        :type protocol: str
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            end_time=end_time,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            protocol=protocol,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('FileSystemsApi', 'api217_file_systems_performance_get_with_http_info', kwargs)

    def get_file_systems_policies_all(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-systems/policies-all
        
        List file system policies. Note: if more than 150,000 items would be returned in the response, an error will be thrown and query parameters must be used to limit the items queried.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('FileSystemsApi', 'api217_file_systems_policies_all_get_with_http_info', kwargs)

    def delete_file_systems_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE file-systems/policies
        
        Remove a snapshot scheduling policy from a file system.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('FileSystemsApi', 'api217_file_systems_policies_delete_with_http_info', kwargs)

    def get_file_systems_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-systems/policies
        
        List file system snapshot scheduling policies. Note: if more than 150,000 items would be returned in the response, an error will be thrown and query parameters must be used to limit the items queried.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('FileSystemsApi', 'api217_file_systems_policies_get_with_http_info', kwargs)

    def post_file_systems_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST file-systems/policies
        
        Apply a snapshot scheduling policy to a file system. Only one file system can be mapped to a policy at a time.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('FileSystemsApi', 'api217_file_systems_policies_post_with_http_info', kwargs)

    def post_file_systems(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        file_system: 'models.FileSystemPost',
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        default_exports: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of export types to be created using default access. Creating a file system with an explicit `nfs.rules` or `nfs.export_policy` value will always create a NFS export to the default server regardless of this flag. If these are not set and `default_exports` includes `nfs`, then `nfs.rules` will be set to \"*(rw,no_root_squash)\" and a NFS export to the default server will be created. Otherwise `nfs.rules` will be set to \"\" and no NFS export will be created. Creating a file system with an explicit `smb.client_policy` or `smb.share_policy` value will always create a SMB export to the default server regardless of this flag. If these are not set and `default_exports` includes `smb`, then a SMB export to the default server will be created with default policies. Otherwise no SMB export will be created. Use empty string (\"\") to not create these default exports. Default is `nfs,smb`.")] = None,
        discard_non_snapshotted_data: Annotated[Optional[StrictBool], Field(description="This parameter must be set to `true` in order to restore a file system from a snapshot or to demote a file system (which restores the file system from the common baseline snapshot). Setting this parameter to `true` is acknowledgement that any non-snapshotted data currently in the file system will be irretrievably lost.")] = None,
        overwrite: Annotated[Optional[StrictBool], Field(description="When used for snapshot restore, overwrites (`true`) an existing file system.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST file-systems
        
        Create a file system on the current array.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param file_system: (required)
        :type file_system: FileSystemPost
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param default_exports: A comma-separated list of export types to be created using default access.
                                Creating a file system with an explicit `nfs.rules` or `nfs.export_policy`
                                value will always create a NFS export to the default server regardless of
                                this flag. If these are not set and `default_exports` includes `nfs`, then
                                `nfs.rules` will be set to "*(rw,no_root_squash)" and a NFS export to the
                                default server will be created. Otherwise `nfs.rules` will be set to ""
                                and no NFS export will be created. Creating a file system with an explicit
                                `smb.client_policy` or `smb.share_policy` value will always create a SMB
                                export to the default server regardless of this flag. If these are not set
                                and `default_exports` includes `smb`, then a SMB export to the default
                                server will be created with default policies. Otherwise no SMB export will
                                be created. Use empty string ("") to not create these default exports.
                                Default is `nfs,smb`.
        :type default_exports: List[str]
        :param discard_non_snapshotted_data: This parameter must be set to `true` in order to restore a file system from a
                                            snapshot or to demote a file system (which restores the file system
                                            from the common baseline snapshot). Setting this parameter to `true` is
                                            acknowledgement that any non-snapshotted data currently in the file
                                            system will be irretrievably lost.
        :type discard_non_snapshotted_data: bool
        :param overwrite: When used for snapshot restore, overwrites (`true`) an existing file system.
        :type overwrite: bool
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            file_system=file_system,
            x_request_id=x_request_id,
            context_names=context_names,
            default_exports=default_exports,
            discard_non_snapshotted_data=discard_non_snapshotted_data,
            overwrite=overwrite,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['names', 'context_names', 'default_exports', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('FileSystemsApi', 'api217_file_systems_post_with_http_info', kwargs)

    def delete_file_systems_sessions(
        self,
        users: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        clients: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        client_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of ip addresses of clients. For IPv6 both the extended format (x:x:x:x:x:x:x:x) and the shortened format are supported.")] = None,
        disruptive: Annotated[Optional[StrictBool], Field(description="If set to `true`, a wide scope of sessions may be deleted in a single action using a single query parameter from `user_names`, `client_names`, or `protocols`. Otherwise, multiple query parameters must be specified to narrow the impact of deletion and avoid potential for accidental disruption of clients.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        protocols: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file protocols. Valid values include `nfs` and `smb`.")] = None,
        user_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of user names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete sessions
        
        Delete sessions. It can be used to either delete an individual session by name or multiple sessions filtered by parameters. E.g. to delete SMBv3 sessions held by specific client, `protocols` and `client_names` must be specified. To prevent accidental deletes, setting flag `disruptive` to `true` is required when only a single query parameter is part of the query. E.g. to delete all SMBv3 sessions, query parameters `protocols` and `disruptive` must be set. When `names` is specified, no other query parameter can be specified.
        
        :param users: A list of users to query for. Overrides user_names keyword argument.
        :type users: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param clients: A list of clients to query for. Overrides client_names keyword argument.
        :type clients: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param client_names: A comma-separated list of ip addresses of clients. For IPv6 both the extended
                            format (x:x:x:x:x:x:x:x) and the shortened format are supported.
        :type client_names: List[str]
        :param disruptive: If set to `true`, a wide scope of sessions may be deleted in a single action
                        using a single query parameter from `user_names`, `client_names`, or
                        `protocols`. Otherwise, multiple query parameters must be specified to
                        narrow the impact of deletion and avoid potential for accidental disruption
                        of clients.
        :type disruptive: bool
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param protocols: A comma-separated list of file protocols. Valid values include `nfs` and `smb`.
        :type protocols: List[str]
        :param user_names: A comma-separated list of user names.
        :type user_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            client_names=client_names,
            disruptive=disruptive,
            names=names,
            protocols=protocols,
            user_names=user_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(clients, ['client_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _process_references(users, ['user_names'], kwargs)
        _fixup_list_type_params(['client_names', 'names', 'protocols', 'user_names'], kwargs)
        return self._call_api('FileSystemsApi', 'api217_file_systems_sessions_delete_with_http_info', kwargs)

    def get_file_systems_sessions(
        self,
        users: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        clients: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        client_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of ip addresses of clients. For IPv6 both the extended format (x:x:x:x:x:x:x:x) and the shortened format are supported.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        protocols: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file protocols. Valid values include `nfs` and `smb`.")] = None,
        user_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of user names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Get a list of active sessions
        
        Lists all active sessions that satisfy the conditions specified by the parameters.
        
        :param users: A list of users to query for. Overrides user_names keyword argument.
        :type users: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param clients: A list of clients to query for. Overrides client_names keyword argument.
        :type clients: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param client_names: A comma-separated list of ip addresses of clients. For IPv6 both the extended
                            format (x:x:x:x:x:x:x:x) and the shortened format are supported.
        :type client_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param protocols: A comma-separated list of file protocols. Valid values include `nfs` and `smb`.
        :type protocols: List[str]
        :param user_names: A comma-separated list of user names.
        :type user_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            client_names=client_names,
            continuation_token=continuation_token,
            limit=limit,
            names=names,
            protocols=protocols,
            user_names=user_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(clients, ['client_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _process_references(users, ['user_names'], kwargs)
        _fixup_list_type_params(['client_names', 'names', 'protocols', 'user_names'], kwargs)
        return self._call_api('FileSystemsApi', 'api217_file_systems_sessions_get_with_http_info', kwargs)

    def get_file_systems_users_performance(
        self,
        users: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        uids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of user IDs. This cannot be provided together with `user_names` query parameter.")] = None,
        user_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of user names. This cannot be provided together with `uids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-systems/users/performance
        
        List a users I/O performance metrics on a file system.
        
        :param users: A list of users to query for. Overrides user_names keyword argument.
        :type users: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param uids: A comma-separated list of user IDs. This cannot be provided together with
                    `user_names` query parameter.
        :type uids: List[int]
        :param user_names: A comma-separated list of user names. This cannot be provided together with
                        `uids` query parameter.
        :type user_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            names=names,
            sort=sort,
            total_only=total_only,
            uids=uids,
            user_names=user_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _process_references(users, ['user_names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'names', 'sort', 'uids', 'user_names'], kwargs)
        return self._call_api('FileSystemsApi', 'api217_file_systems_users_performance_get_with_http_info', kwargs)

    def get_file_systems_worm_data_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET file-systems/worm-data-policies
        
        List file systems mapped to a WORM data policy.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('FileSystemsApi', 'api217_file_systems_worm_data_policies_get_with_http_info', kwargs)

    def delete_fleets(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Supports exactly one value.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource names specified. Supports exactly one value.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE Fleets
        
        Permanently delete a fleet. A fleet can only be deleted if the current array is the only array in the fleet.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Supports exactly
                    one value.
        :type ids: List[str]
        :param names: Performs the operation on the unique resource names specified. Supports exactly
                    one value.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('FleetsApi', 'api217_fleets_delete_with_http_info', kwargs)

    def get_fleets_fleet_key(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET fleet-key
        
        Displays the time remaining on the fleet key. Note: fleet key itself is not displayed, since that is only available at the time of fleet key creation.
        
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            offset=offset,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('FleetsApi', 'api217_fleets_fleet_key_get_with_http_info', kwargs)

    def post_fleets_fleet_key(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST fleet-key
        
        Creates a fleet key allowing an array to be added to a fleet. This is the only time the fleet key is displayed, it cannot be retrieved subsequently. Note: Creation of a subsequent key invalidates all keys created earlier.
        
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('FleetsApi', 'api217_fleets_fleet_key_post_with_http_info', kwargs)

    def get_fleets(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Supports exactly one value.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource names specified. Supports exactly one value.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET fleets
        
        Displays information about the fleets known to the array.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: Performs the operation on the unique resource IDs specified. Supports exactly
                    one value.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: Performs the operation on the unique resource names specified. Supports exactly
                    one value.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('FleetsApi', 'api217_fleets_get_with_http_info', kwargs)

    def delete_fleets_members(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        unreachable: Annotated[Optional[StrictBool], Field(description="If set to `true`, allows a one-sided disconnect when the connection status is `connecting` instead of `connected` or `partially connected`. If set to `false`, it works just like normal coordinated disconnect. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Remove fleet members
        
        Remove the specified array(s) from the fleet. Note: that this will only succeed if the array(s) to be removed are not making use of any fleet resources.
        
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param unreachable: If set to `true`, allows a one-sided disconnect when the connection status is
                            `connecting` instead of `connected` or `partially connected`. If set to
                            `false`, it works just like normal coordinated disconnect. If not
                            specified, defaults to `false`.
        :type unreachable: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            member_ids=member_ids,
            member_names=member_names,
            unreachable=unreachable,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names'], kwargs)
        return self._call_api('FleetsApi', 'api217_fleets_members_delete_with_http_info', kwargs)

    def get_fleets_members(
        self,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        fleets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        fleet_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique Fleet IDs specified. This query currently accepts only 1 ID.")] = None,
        fleet_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique Fleet names specified. Enter multiple names in comma-separated format. For example, `name01,name02`. This query currently accepts only 1 name.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET fleet members
        
        Displays the members in the current fleet.
        
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param fleets: A list of fleets to query for. Overrides fleet_ids and fleet_names keyword arguments.
        :type fleets: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param fleet_ids: Performs the operation on the unique Fleet IDs specified. This query currently
                        accepts only 1 ID.
        :type fleet_ids: List[str]
        :param fleet_names: Performs the operation on the unique Fleet names specified. Enter multiple names
                            in comma-separated format. For example, `name01,name02`. This query
                            currently accepts only 1 name.
        :type fleet_names: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            fleet_ids=fleet_ids,
            fleet_names=fleet_names,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(fleets, ['fleet_ids', 'fleet_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _fixup_list_type_params(['fleet_ids', 'fleet_names', 'member_ids', 'member_names', 'sort'], kwargs)
        return self._call_api('FleetsApi', 'api217_fleets_members_get_with_http_info', kwargs)

    def post_fleets_members(
        self,
        fleets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        fleet_ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique Fleet IDs specified. This query currently accepts only 1 ID.")] = None,
        fleet_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique Fleet names specified. Enter multiple names in comma-separated format. For example, `name01,name02`. This query currently accepts only 1 name.")] = None,
        members: Annotated[Optional['models.FleetMemberPost'], Field(description="Info about the members being added to fleet.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST fleets
        
        Adds arrays to an existing fleet. This API needs to be run from the array that's joining the fleet. To add the current array to the fleet, specify its own array id or name as well as the fleet key generated on any array already in the fleet. `resource_type` is `remote-arrays`. The array's ID and name can be retrieved with a call to `GET /arrays` on the array.
        
        :param fleets: A list of fleets to query for. Overrides fleet_ids and fleet_names keyword arguments.
        :type fleets: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param fleet_ids: Performs the operation on the unique Fleet IDs specified. This query currently
                        accepts only 1 ID.
        :type fleet_ids: List[str]
        :param fleet_names: Performs the operation on the unique Fleet names specified. Enter multiple names
                            in comma-separated format. For example, `name01,name02`. This query
                            currently accepts only 1 name.
        :type fleet_names: List[str]
        :param members: Info about the members being added to fleet.
        :type members: FleetMemberPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            fleet_ids=fleet_ids,
            fleet_names=fleet_names,
            members=members,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(fleets, ['fleet_ids', 'fleet_names'], kwargs)
        _fixup_list_type_params(['fleet_ids', 'fleet_names'], kwargs)
        return self._call_api('FleetsApi', 'api217_fleets_members_post_with_http_info', kwargs)

    def patch_fleets(
        self,
        fleet: 'models.FleetPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource IDs specified. Supports exactly one value.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource names specified. Supports exactly one value.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH fleets
        
        Rename a fleet by passing the old name in `name` query parameter, and the new name in the `name` parameter in the request body.
        
        :param fleet: (required)
        :type fleet: FleetPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: Performs the operation on the unique resource IDs specified. Supports exactly
                    one value.
        :type ids: List[str]
        :param names: Performs the operation on the unique resource names specified. Supports exactly
                    one value.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            fleet=fleet,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('FleetsApi', 'api217_fleets_patch_with_http_info', kwargs)

    def post_fleets(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique resource names specified. Supports exactly one value.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST fleets
        
        Creates a fleet and adds the current array as its first member. Additional arrays can be added to the fleet with `POST /fleets/members`
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique resource names specified. Supports exactly
                    one value.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('FleetsApi', 'api217_fleets_post_with_http_info', kwargs)

    def get_hardware(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET hardware
        
        List hardware slots and bays and the status of installed components.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('HardwareApi', 'api217_hardware_get_with_http_info', kwargs)

    def patch_hardware(
        self,
        hardware: 'models.Hardware',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH hardware
        
        Controls the visual identification light of the specified hardware component.
        
        :param hardware: (required)
        :type hardware: Hardware
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            hardware=hardware,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('HardwareApi', 'api217_hardware_patch_with_http_info', kwargs)

    def get_hardware_connectors(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET hardware-connectors
        
        The endpoint is deprecated. Use the `/network-interfaces/connectors` endpoint instead. List array connection information.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('HardwareConnectorsApi', 'api217_hardware_connectors_get_with_http_info', kwargs)

    def patch_hardware_connectors(
        self,
        hardware_connector: 'models.HardwareConnector',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH hardware-connectors
        
        The endpoint is deprecated. Use the `/network-interfaces/connectors` endpoint instead. Modify array connection information.
        
        :param hardware_connector: (required)
        :type hardware_connector: HardwareConnector
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            hardware_connector=hardware_connector,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('HardwareConnectorsApi', 'api217_hardware_connectors_patch_with_http_info', kwargs)

    def get_hardware_connectors_performance(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET hardware-connectors/performance
        
        The endpoint is deprecated. Use the `/network-interfaces/connectors/performance` endpoint instead. Displays network statistics, historical bandwidth, and error reporting for all specified hardware connectors.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            end_time=end_time,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('HardwareConnectorsApi', 'api217_hardware_connectors_performance_get_with_http_info', kwargs)

    def delete_kmip(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a KMIP server configuration
        
        Deletes a KMIP server configuration. A server can only be deleted when not in use by the array.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('KMIPApi', 'api217_kmip_delete_with_http_info', kwargs)

    def get_kmip(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List KMIP server configurations
        
        Displays a list of KMIP server configurations.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('KMIPApi', 'api217_kmip_get_with_http_info', kwargs)

    def patch_kmip(
        self,
        kmip_server: 'models.KmipServer',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify a KMIP server configuration
        
        Modifies KMIP server properties - URI, certificate, certificate group.
        
        :param kmip_server: (required)
        :type kmip_server: KmipServer
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            kmip_server=kmip_server,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('KMIPApi', 'api217_kmip_patch_with_http_info', kwargs)

    def post_kmip(
        self,
        kmip_server: 'models.KmipServer',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a KMIP server configuration
        
        Creates a KMIP server configuration.
        
        :param kmip_server: (required)
        :type kmip_server: KmipServer
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            kmip_server=kmip_server,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('KMIPApi', 'api217_kmip_post_with_http_info', kwargs)

    def get_kmip_test(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Displays KMIP server test results
        
        Displays a detailed result of of KMIP server test.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('KMIPApi', 'api217_kmip_test_get_with_http_info', kwargs)

    def delete_keytabs(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE keytabs
        
        Delete a Kerberos keytab file.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('KeytabsApi', 'api217_keytabs_delete_with_http_info', kwargs)

    def get_keytabs_download(
        self,
        keytabs: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        keytab_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of keytab IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `keytab_names` query parameter.")] = None,
        keytab_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of keytab names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `keytab_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET keytabs/download
        
        Download a Kerberos keytab file. The file can be downloaded in the native binary format or a base64 encoded format. If not specified, defaults to binary.
        
        :param keytabs: A list of keytabs to query for. Overrides keytab_ids and keytab_names keyword arguments.
        :type keytabs: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param keytab_ids: A comma-separated list of keytab IDs. If after filtering, there is not at least
                        one resource that matches each of the elements, then an error is returned.
                        This cannot be provided together with the `keytab_names` query parameter.
        :type keytab_ids: List[str]
        :param keytab_names: A comma-separated list of keytab names. If there is not at least one resource
                            that matches each of the elements, then an error is returned. This cannot
                            be provided together with `keytab_ids` query parameter.
        :type keytab_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            keytab_ids=keytab_ids,
            keytab_names=keytab_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(keytabs, ['keytab_ids', 'keytab_names'], kwargs)
        _fixup_list_type_params(['keytab_ids', 'keytab_names'], kwargs)
        return self._call_api('KeytabsApi', 'api217_keytabs_download_get_with_http_info', kwargs)

    def get_keytabs(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET keytabs
        
        List a Kerberos keytab file and its configuration information.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('KeytabsApi', 'api217_keytabs_get_with_http_info', kwargs)

    def post_keytabs(
        self,
        keytab: 'models.KeytabPost',
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        name_prefixes: Annotated[Optional[StrictStr], Field(description="The prefix to use for the names of all Kerberos keytab objects that are being created.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST keytabs
        
        Import a Kerberos keytab file from a Key Distribution Center.
        
        :param keytab: (required)
        :type keytab: KeytabPost
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param name_prefixes: The prefix to use for the names of all Kerberos keytab objects that are being
                            created.
        :type name_prefixes: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            keytab=keytab,
            x_request_id=x_request_id,
            name_prefixes=name_prefixes,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('KeytabsApi', 'api217_keytabs_post_with_http_info', kwargs)

    def post_keytabs_upload(
        self,
        keytab_file: Annotated[StrictStr, Field(..., description="The keytab file to upload.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        name_prefixes: Annotated[Optional[StrictStr], Field(description="The prefix to use for the names of all Kerberos keytab objects that are being created.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST keytabs/upload
        
        Upload a Kerberos keytab file to the array. The file can be uploaded in the native binary format or a base64 encoded format. If not specified, defaults to binary. The procedure to upload a file may vary depending on the type of REST client.
        
        :param keytab_file: The keytab file to upload. (required)
        :type keytab_file: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param name_prefixes: The prefix to use for the names of all Kerberos keytab objects that are being
                            created.
        :type name_prefixes: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            keytab_file=keytab_file,
            x_request_id=x_request_id,
            name_prefixes=name_prefixes,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('KeytabsApi', 'api217_keytabs_upload_post_with_http_info', kwargs)

    def delete_legal_holds(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete a legal hold
        
        Delete a legal hold instance. Deletion is not allowed if the legal hold is applied to one or more paths.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('LegalHoldsApi', 'api217_legal_holds_delete_with_http_info', kwargs)

    def get_legal_holds(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List legal holds
        
        List legal holds.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('LegalHoldsApi', 'api217_legal_holds_get_with_http_info', kwargs)

    def get_legal_holds_held_entities(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        paths: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of paths used for filtering file locks query by paths. This may only be specified if `file_system_ids` or `file_system_names` is also specified. This cannot be provided together with the `inodes` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List held entities
        
        List entities to which a legal hold has been applied.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param paths: A comma-separated list of paths used for filtering file locks query by paths.
                    This may only be specified if `file_system_ids` or `file_system_names` is
                    also specified. This cannot be provided together with the `inodes` query
                    parameter.
        :type paths: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            ids=ids,
            limit=limit,
            names=names,
            paths=paths,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'ids', 'names', 'paths'], kwargs)
        return self._call_api('LegalHoldsApi', 'api217_legal_holds_held_entities_get_with_http_info', kwargs)

    def patch_legal_holds_held_entities(
        self,
        released: Annotated[StrictBool, Field(..., description="This is a flag to set when releasing an attached legal hold from a path.")],
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        paths: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of paths used for filtering file locks query by paths. This may only be specified if `file_system_ids` or `file_system_names` is also specified. This cannot be provided together with the `inodes` query parameter.")] = None,
        recursive: Annotated[Optional[StrictBool], Field(description="This is a flag to set when recursively applying/releasing legal holds on entities. By default, it is set to be false. The `recursive` flag is required when applying/releasing a hold to/from a directory.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Release this legal hold from the given entity
        
        Release this legal hold from the given entity. The `names`, `file_system_names`, `paths` and `released` query parameters are required. The `recursive` flag is required when releasing a hold from a directory.
        
        :param released: This is a flag to set when releasing an attached legal hold from a path.
                        (required)
        :type released: bool
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param paths: A comma-separated list of paths used for filtering file locks query by paths.
                    This may only be specified if `file_system_ids` or `file_system_names` is
                    also specified. This cannot be provided together with the `inodes` query
                    parameter.
        :type paths: List[str]
        :param recursive: This is a flag to set when recursively applying/releasing legal holds on
                        entities. By default, it is set to be false. The `recursive` flag is
                        required when applying/releasing a hold to/from a directory.
        :type recursive: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            released=released,
            x_request_id=x_request_id,
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            ids=ids,
            names=names,
            paths=paths,
            recursive=recursive,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'ids', 'names', 'paths'], kwargs)
        return self._call_api('LegalHoldsApi', 'api217_legal_holds_held_entities_patch_with_http_info', kwargs)

    def post_legal_holds_held_entities(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        paths: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of paths used for filtering file locks query by paths. This may only be specified if `file_system_ids` or `file_system_names` is also specified. This cannot be provided together with the `inodes` query parameter.")] = None,
        recursive: Annotated[Optional[StrictBool], Field(description="This is a flag to set when recursively applying/releasing legal holds on entities. By default, it is set to be false. The `recursive` flag is required when applying/releasing a hold to/from a directory.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Apply this legal hold to a new entity
        
        Apply this legal hold to a new entity. The `names`, `file_system_names` and `paths` query parameters are required. The `recursive` flag is required when applying a hold to a directory.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param paths: A comma-separated list of paths used for filtering file locks query by paths.
                    This may only be specified if `file_system_ids` or `file_system_names` is
                    also specified. This cannot be provided together with the `inodes` query
                    parameter.
        :type paths: List[str]
        :param recursive: This is a flag to set when recursively applying/releasing legal holds on
                        entities. By default, it is set to be false. The `recursive` flag is
                        required when applying/releasing a hold to/from a directory.
        :type recursive: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            ids=ids,
            names=names,
            paths=paths,
            recursive=recursive,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['file_system_ids', 'file_system_names', 'ids', 'names', 'paths'], kwargs)
        return self._call_api('LegalHoldsApi', 'api217_legal_holds_held_entities_post_with_http_info', kwargs)

    def patch_legal_holds(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        hold: Optional['models.LegalHold'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Update a legal hold
        
        Update a legal hold instance.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param hold:
        :type hold: LegalHold
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            hold=hold,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('LegalHoldsApi', 'api217_legal_holds_patch_with_http_info', kwargs)

    def post_legal_holds(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        hold: Optional['models.LegalHold'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a legal hold
        
        Create a legal hold instance.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param hold:
        :type hold: LegalHold
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            x_request_id=x_request_id,
            hold=hold,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('LegalHoldsApi', 'api217_legal_holds_post_with_http_info', kwargs)

    def delete_lifecycle_rules(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket IDs. If after filtering, there is not at least one resource that matches each of the elements of `bucket_ids`, then an error is returned. This cannot be provided together with the `bucket_names` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket names. If there is not at least one resource that matches each of the elements of `bucket_names`, then an error is returned. This cannot be provided together with the `bucket_ids` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE lifecycle-rules
        
        Deletes individual lifecycle rules by name or id, or deletes all rules for a bucket. If `ids` is specified, `bucket_names` or `bucket_ids` is also required. If `bucket_names` or `bucket_ids` are specified without `ids`, delete all the rules for the bucket.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param buckets: A list of buckets to query for. Overrides bucket_ids and bucket_names keyword arguments.
        :type buckets: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param bucket_ids: A comma-separated list of bucket IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `bucket_ids`, then an
                        error is returned. This cannot be provided together with the `bucket_names`
                        query parameter. This can be provided with the `ids` query parameter but not
                        with `names`.
        :type bucket_ids: List[str]
        :param bucket_names: A comma-separated list of bucket names. If there is not at least one resource
                            that matches each of the elements of `bucket_names`, then an error is
                            returned. This cannot be provided together with the `bucket_ids` query
                            parameter. This can be provided with the `ids` query parameter but not with
                            `names`.
        :type bucket_names: List[str]
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            bucket_ids=bucket_ids,
            bucket_names=bucket_names,
            context_names=context_names,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(buckets, ['bucket_ids', 'bucket_names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['bucket_ids', 'bucket_names', 'context_names', 'ids', 'names'], kwargs)
        return self._call_api('LifecycleRulesApi', 'api217_lifecycle_rules_delete_with_http_info', kwargs)

    def get_lifecycle_rules(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket IDs. If after filtering, there is not at least one resource that matches each of the elements of `bucket_ids`, then an error is returned. This cannot be provided together with the `bucket_names` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket names. If there is not at least one resource that matches each of the elements of `bucket_names`, then an error is returned. This cannot be provided together with the `bucket_ids` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET lifecycle-rules
        
        Returns a list of lifecycle rules. If `names` is specified, list the individual rules. If `ids` is specified, `bucket_names` or `bucket_ids` is also required. If `bucket_names` or `bucket_ids` are specified without `ids`, list all the rules for the bucket.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param buckets: A list of buckets to query for. Overrides bucket_ids and bucket_names keyword arguments.
        :type buckets: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param bucket_ids: A comma-separated list of bucket IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `bucket_ids`, then an
                        error is returned. This cannot be provided together with the `bucket_names`
                        query parameter. This can be provided with the `ids` query parameter but not
                        with `names`.
        :type bucket_ids: List[str]
        :param bucket_names: A comma-separated list of bucket names. If there is not at least one resource
                            that matches each of the elements of `bucket_names`, then an error is
                            returned. This cannot be provided together with the `bucket_ids` query
                            parameter. This can be provided with the `ids` query parameter but not with
                            `names`.
        :type bucket_names: List[str]
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            bucket_ids=bucket_ids,
            bucket_names=bucket_names,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(buckets, ['bucket_ids', 'bucket_names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['bucket_ids', 'bucket_names', 'context_names', 'ids', 'names', 'sort'], kwargs)
        return self._call_api('LifecycleRulesApi', 'api217_lifecycle_rules_get_with_http_info', kwargs)

    def patch_lifecycle_rules(
        self,
        lifecycle: 'models.LifecycleRulePatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        buckets: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        bucket_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket IDs. If after filtering, there is not at least one resource that matches each of the elements of `bucket_ids`, then an error is returned. This cannot be provided together with the `bucket_names` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        bucket_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of bucket names. If there is not at least one resource that matches each of the elements of `bucket_names`, then an error is returned. This cannot be provided together with the `bucket_ids` query parameter. This can be provided with the `ids` query parameter but not with `names`.")] = None,
        confirm_date: Annotated[Optional[StrictBool], Field(description="If set to `true`, then confirm the date of `keep_current_version_until` is correct.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH lifecycle-rules
        
        Modify an existing lifecycle rule by name or id. If `ids` is specified, `bucket_names` or `bucket_ids` is also required.
        
        :param lifecycle: (required)
        :type lifecycle: LifecycleRulePatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param buckets: A list of buckets to query for. Overrides bucket_ids and bucket_names keyword arguments.
        :type buckets: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param bucket_ids: A comma-separated list of bucket IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `bucket_ids`, then an
                        error is returned. This cannot be provided together with the `bucket_names`
                        query parameter. This can be provided with the `ids` query parameter but not
                        with `names`.
        :type bucket_ids: List[str]
        :param bucket_names: A comma-separated list of bucket names. If there is not at least one resource
                            that matches each of the elements of `bucket_names`, then an error is
                            returned. This cannot be provided together with the `bucket_ids` query
                            parameter. This can be provided with the `ids` query parameter but not with
                            `names`.
        :type bucket_names: List[str]
        :param confirm_date: If set to `true`, then confirm the date of `keep_current_version_until` is
                            correct.
        :type confirm_date: bool
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            lifecycle=lifecycle,
            x_request_id=x_request_id,
            bucket_ids=bucket_ids,
            bucket_names=bucket_names,
            confirm_date=confirm_date,
            context_names=context_names,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(buckets, ['bucket_ids', 'bucket_names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['bucket_ids', 'bucket_names', 'context_names', 'ids', 'names'], kwargs)
        return self._call_api('LifecycleRulesApi', 'api217_lifecycle_rules_patch_with_http_info', kwargs)

    def post_lifecycle_rules(
        self,
        rule: 'models.LifecycleRulePost',
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        confirm_date: Annotated[Optional[StrictBool], Field(description="If set to `true`, then confirm the date of `keep_current_version_until` is correct.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST lifecycle-rules
        
        Creates a lifecycle rule. `bucket` and `keep_previous_version_for` are required. If `rule_id` is not specified, it will be automatically generated in the format "fbRuleIdX".
        
        :param rule: (required)
        :type rule: LifecycleRulePost
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param confirm_date: If set to `true`, then confirm the date of `keep_current_version_until` is
                            correct.
        :type confirm_date: bool
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            rule=rule,
            x_request_id=x_request_id,
            confirm_date=confirm_date,
            context_names=context_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _fixup_list_type_params(['context_names'], kwargs)
        return self._call_api('LifecycleRulesApi', 'api217_lifecycle_rules_post_with_http_info', kwargs)

    def delete_link_aggregation_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE link-aggregation-groups
        
        Remove a link aggregation group to unbind the ports.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('LinkAggregationGroupsApi', 'api217_link_aggregation_groups_delete_with_http_info', kwargs)

    def get_link_aggregation_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET link-aggregation-groups
        
        List the status and attributes of the Ethernet ports in the configured link aggregation groups.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('LinkAggregationGroupsApi', 'api217_link_aggregation_groups_get_with_http_info', kwargs)

    def patch_link_aggregation_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        link_aggregation_group: Optional['models.LinkAggregationGroupPatch'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH link-aggregation-groups
        
        Modify link aggregation groups by adding and removing Ethernet ports.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param link_aggregation_group:
        :type link_aggregation_group: LinkAggregationGroupPatch
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            link_aggregation_group=link_aggregation_group,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('LinkAggregationGroupsApi', 'api217_link_aggregation_groups_patch_with_http_info', kwargs)

    def post_link_aggregation_groups(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        link_aggregation_group: 'models.LinkAggregationGroup',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST link-aggregation-groups
        
        Create a link aggregation group of Ethernet ports on the array.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param link_aggregation_group: (required)
        :type link_aggregation_group: LinkAggregationGroup
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            link_aggregation_group=link_aggregation_group,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('LinkAggregationGroupsApi', 'api217_link_aggregation_groups_post_with_http_info', kwargs)

    def get_logs_async_download(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET logs-async/download
        
        Download the files which contain a history of log events from the array to provide to Pure Technical Services for analysis.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('LogsApi', 'api217_logs_async_download_get_with_http_info', kwargs)

    def get_logs_async(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET logs-async
        
        List the attributes and status of preparation for a history of log events from the array to provide to Pure Technical Services for analysis.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('LogsApi', 'api217_logs_async_get_with_http_info', kwargs)

    def patch_logs_async(
        self,
        logs_async: 'models.LogsAsync',
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH logs-async
        
        Start the preparation for a history of log events from the array to provide to Pure Technical Services for analysis.
        
        :param logs_async: (required)
        :type logs_async: LogsAsync
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            logs_async=logs_async,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('LogsApi', 'api217_logs_async_patch_with_http_info', kwargs)

    def get_logs(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET logs
        
        Download a history of log events from the array to provide to Pure Technical Services for analysis.
        
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            end_time=end_time,
            start_time=start_time,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('LogsApi', 'api217_logs_get_with_http_info', kwargs)

    def delete_maintenance_windows(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete maintenance window
        
        Deletes an active maintenance window before its scheduled end (`expire`) time. The `names` parameter is required and must be set to `array`.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('MaintenanceWindowsApi', 'api217_maintenance_windows_delete_with_http_info', kwargs)

    def get_maintenance_windows(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List maintenance window details
        
        Displays maintenance window details, including start time, end time, and maintenance type.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('MaintenanceWindowsApi', 'api217_maintenance_windows_get_with_http_info', kwargs)

    def post_maintenance_windows(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        maintenance_window: 'models.MaintenanceWindowPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a maintenance window
        
        Creates a maintenance window that suppresses alerts for a specified period of time. A maintenance window can be manually closed at any time. The `names` and `timeout` parameters are required. Set the `names` parameter to `array`.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param maintenance_window: (required)
        :type maintenance_window: MaintenanceWindowPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            maintenance_window=maintenance_window,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('MaintenanceWindowsApi', 'api217_maintenance_windows_post_with_http_info', kwargs)

    def get_network_interfaces_connectors(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET network-interfaces/connectors
        
        List network connector information
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('NetworkInterfacesApi', 'api217_network_interfaces_connectors_get_with_http_info', kwargs)

    def patch_network_interfaces_connectors(
        self,
        network_connector: 'models.HardwareConnector',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH network-interfaces/connectors
        
        Modify network connector information.
        
        :param network_connector: (required)
        :type network_connector: HardwareConnector
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            network_connector=network_connector,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('NetworkInterfacesApi', 'api217_network_interfaces_connectors_patch_with_http_info', kwargs)

    def get_network_interfaces_connectors_performance(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET network connectors performance statistics
        
        Displays network statistics, historical bandwidth, and error reporting for all specified network connectors.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            end_time=end_time,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('NetworkInterfacesApi', 'api217_network_interfaces_connectors_performance_get_with_http_info', kwargs)

    def get_network_interfaces_connectors_settings(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET global network settings for network connectors
        
        Display the global network settings for network connectors.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('NetworkInterfacesApi', 'api217_network_interfaces_connectors_settings_get_with_http_info', kwargs)

    def delete_network_interfaces(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE network-interfaces
        
        Remove a VIP. Once a data VIP is removed, any clients connected through the data VIP will lose their connection to the file system or bucket.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('NetworkInterfacesApi', 'api217_network_interfaces_delete_with_http_info', kwargs)

    def get_network_interfaces(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET network-interfaces
        
        List network interfaces and their attributes.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('NetworkInterfacesApi', 'api217_network_interfaces_get_with_http_info', kwargs)

    def patch_network_interfaces(
        self,
        network_interface: 'models.NetworkInterfacePatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH network-interfaces
        
        Modify the attributes of a VIP.
        
        :param network_interface: (required)
        :type network_interface: NetworkInterfacePatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            network_interface=network_interface,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('NetworkInterfacesApi', 'api217_network_interfaces_patch_with_http_info', kwargs)

    def get_network_interfaces_ping(
        self,
        destination: Annotated[StrictStr, Field(..., description="A destination specified by user to run the network diagnosis against. Can be a hostname or an IP.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        component_name: Annotated[Optional[StrictStr], Field(description="Used by ping and trace to specify where to run the operation. Valid values are controllers and blades from hardware list. If not specified, defaults to all available controllers and selected blades.")] = None,
        count: Annotated[Optional[StrictInt], Field(description="Used by ping to specify the number of packets to send. If not specified, defaults to 1.")] = None,
        packet_size: Annotated[Optional[StrictInt], Field(description="Used by ping to specify the number of data bytes to be sent per packet. If not specified, defaults to 56.")] = None,
        print_latency: Annotated[Optional[StrictBool], Field(description="Used by ping to specify whether or not to print the full user-to-user latency. If not specified, defaults to false.")] = None,
        resolve_hostname: Annotated[Optional[StrictBool], Field(description="Used by ping and trace to specify whether or not to map IP addresses to host names. If not specified, defaults to true.")] = None,
        source: Annotated[Optional[StrictStr], Field(description="Used by ping and trace to specify the property where to start to run the specified operation. The property can be subnet or IP.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET network-interfaces/ping
        
        Display network interface ping result.
        
        :param destination: A destination specified by user to run the network diagnosis against. Can be a
                            hostname or an IP. (required)
        :type destination: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param component_name: Used by ping and trace to specify where to run the operation. Valid values are
                            controllers and blades from hardware list. If not specified, defaults to
                            all available controllers and selected blades.
        :type component_name: str
        :param count: Used by ping to specify the number of packets to send. If not specified,
                    defaults to 1.
        :type count: int
        :param packet_size: Used by ping to specify the number of data bytes to be sent per packet. If not
                            specified, defaults to 56.
        :type packet_size: int
        :param print_latency: Used by ping to specify whether or not to print the full user-to-user latency.
                            If not specified, defaults to false.
        :type print_latency: bool
        :param resolve_hostname: Used by ping and trace to specify whether or not to map IP addresses to host
                                names. If not specified, defaults to true.
        :type resolve_hostname: bool
        :param source: Used by ping and trace to specify the property where to start to run the
                    specified operation. The property can be subnet or IP.
        :type source: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            destination=destination,
            x_request_id=x_request_id,
            component_name=component_name,
            count=count,
            packet_size=packet_size,
            print_latency=print_latency,
            resolve_hostname=resolve_hostname,
            source=source,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('NetworkInterfacesApi', 'api217_network_interfaces_ping_get_with_http_info', kwargs)

    def post_network_interfaces(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        network_interface: 'models.NetworkInterface',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST network-interfaces
        
        Create a VIP to export data or perform replication.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param network_interface: (required)
        :type network_interface: NetworkInterface
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            network_interface=network_interface,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('NetworkInterfacesApi', 'api217_network_interfaces_post_with_http_info', kwargs)

    def get_network_interfaces_trace(
        self,
        destination: Annotated[StrictStr, Field(..., description="A destination specified by user to run the network diagnosis against. Can be a hostname or an IP.")],
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        component_name: Annotated[Optional[StrictStr], Field(description="Used by ping and trace to specify where to run the operation. Valid values are controllers and blades from hardware list. If not specified, defaults to all available controllers and selected blades.")] = None,
        discover_mtu: Annotated[Optional[StrictBool], Field(description="Used by trace to specify whether or not to discover the MTU along the path being traced. If not specified, defaults to false.")] = None,
        fragment_packet: Annotated[Optional[StrictBool], Field(description="Used by trace to specify whether or not to fragment packets. If not specified, defaults to true.")] = None,
        method: Annotated[Optional[StrictStr], Field(description="Used by trace to specify which method to use for trace operations. Valid values are `icmp`, `tcp`, and `udp`. If not specified, defaults to 'udp'.")] = None,
        port: Annotated[Optional[StrictStr], Field(description="Used by trace to specify a destination port.")] = None,
        resolve_hostname: Annotated[Optional[StrictBool], Field(description="Used by ping and trace to specify whether or not to map IP addresses to host names. If not specified, defaults to true.")] = None,
        source: Annotated[Optional[StrictStr], Field(description="Used by ping and trace to specify the property where to start to run the specified operation. The property can be subnet or IP.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET network-interfaces/trace
        
        Display network interface trace result.
        
        :param destination: A destination specified by user to run the network diagnosis against. Can be a
                            hostname or an IP. (required)
        :type destination: str
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param component_name: Used by ping and trace to specify where to run the operation. Valid values are
                            controllers and blades from hardware list. If not specified, defaults to
                            all available controllers and selected blades.
        :type component_name: str
        :param discover_mtu: Used by trace to specify whether or not to discover the MTU along the path being
                            traced. If not specified, defaults to false.
        :type discover_mtu: bool
        :param fragment_packet: Used by trace to specify whether or not to fragment packets. If not specified,
                                defaults to true.
        :type fragment_packet: bool
        :param method: Used by trace to specify which method to use for trace operations. Valid values
                    are `icmp`, `tcp`, and `udp`. If not specified, defaults to 'udp'.
        :type method: str
        :param port: Used by trace to specify a destination port.
        :type port: str
        :param resolve_hostname: Used by ping and trace to specify whether or not to map IP addresses to host
                                names. If not specified, defaults to true.
        :type resolve_hostname: bool
        :param source: Used by ping and trace to specify the property where to start to run the
                    specified operation. The property can be subnet or IP.
        :type source: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            destination=destination,
            x_request_id=x_request_id,
            component_name=component_name,
            discover_mtu=discover_mtu,
            fragment_packet=fragment_packet,
            method=method,
            port=port,
            resolve_hostname=resolve_hostname,
            source=source,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('NetworkInterfacesApi', 'api217_network_interfaces_trace_get_with_http_info', kwargs)

    def delete_sso_oidc_idps(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete OIDC SSO configurations
        
        Delete OIDC SSO configurations.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('OIDCSSOApi', 'api217_sso_oidc_idps_delete_with_http_info', kwargs)

    def get_sso_oidc_idps(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List OIDC SSO configurations
        
        Displays the OIDC SSO configuration settings in the array.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('OIDCSSOApi', 'api217_sso_oidc_idps_get_with_http_info', kwargs)

    def patch_sso_oidc_idps(
        self,
        idp: 'models.OidcSsoPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify OIDC SSO configuration
        
        Modify one or more attributes of OIDC SSO configuration.
        
        :param idp: (required)
        :type idp: OidcSsoPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            idp=idp,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('OIDCSSOApi', 'api217_sso_oidc_idps_patch_with_http_info', kwargs)

    def post_sso_oidc_idps(
        self,
        idp: 'models.OidcSsoPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create OIDC SSO configuration
        
        Create OIDC SSO configuration.
        
        :param idp: (required)
        :type idp: OidcSsoPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            idp=idp,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('OIDCSSOApi', 'api217_sso_oidc_idps_post_with_http_info', kwargs)

    def delete_object_store_access_keys(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-access-keys
        
        Delete an object store access key. Once an access key has been deleted, it cannot be recovered.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            x_request_id=x_request_id,
            context_names=context_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _fixup_list_type_params(['names', 'context_names'], kwargs)
        return self._call_api('ObjectStoreAccessKeysApi', 'api217_object_store_access_keys_delete_with_http_info', kwargs)

    def get_object_store_access_keys(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-access-keys
        
        List object store access keys.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['context_names', 'names', 'sort'], kwargs)
        return self._call_api('ObjectStoreAccessKeysApi', 'api217_object_store_access_keys_get_with_http_info', kwargs)

    def patch_object_store_access_keys(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        object_store_access_key: 'models.ObjectStoreAccessKey',
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH object-store-access-keys
        
        Enable or disable object store access keys.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param object_store_access_key: (required)
        :type object_store_access_key: ObjectStoreAccessKey
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            object_store_access_key=object_store_access_key,
            x_request_id=x_request_id,
            context_names=context_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _fixup_list_type_params(['names', 'context_names'], kwargs)
        return self._call_api('ObjectStoreAccessKeysApi', 'api217_object_store_access_keys_patch_with_http_info', kwargs)

    def post_object_store_access_keys(
        self,
        object_store_access_key: 'models.ObjectStoreAccessKeyPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names to import. To import a set of credentials, this field must be specified with the `secret_access_key` body parameter. If both of these are not specified, the system will generate a new set of credentials.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-access-keys
        
        Create or import object store access keys.
        
        :param object_store_access_key: (required)
        :type object_store_access_key: ObjectStoreAccessKeyPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param names: A comma-separated list of resource names to import. To import a set of
                    credentials, this field must be specified with the `secret_access_key` body
                    parameter. If both of these are not specified, the system will generate a new
                    set of credentials.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            object_store_access_key=object_store_access_key,
            x_request_id=x_request_id,
            context_names=context_names,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['context_names', 'names'], kwargs)
        return self._call_api('ObjectStoreAccessKeysApi', 'api217_object_store_access_keys_post_with_http_info', kwargs)

    def delete_object_store_accounts(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-accounts
        
        Delete an object store account.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names'], kwargs)
        return self._call_api('ObjectStoreAccountsApi', 'api217_object_store_accounts_delete_with_http_info', kwargs)

    def get_object_store_accounts(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-accounts
        
        List object store accounts and their attributes.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'sort'], kwargs)
        return self._call_api('ObjectStoreAccountsApi', 'api217_object_store_accounts_get_with_http_info', kwargs)

    def patch_object_store_accounts(
        self,
        object_store_account: 'models.ObjectStoreAccountPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        ignore_usage: Annotated[Optional[StrictBool], Field(description="Allow update operations that lead to a `hard_limit_enabled` object store account, bucket, or file system with usage over its limiting value. For object store accounts and buckets, the limiting value is that of `quota_limit`, and for file systems it is that of `provisioned`. The operation can be setting `hard_limit_enabled` when usage is higher than the limiting value, modifying the limiting value to a value under usage when `hard_limit_enabled`, recovering a destroyed bucket of an object store account that causes an account's space usage to go over its hard `quota_limit`. Also allows update operations that would cause usage of the requested storage class to go over its warning threshold.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH object-store-accounts
        
        Modify object store account attributes such as quota limit and bucket defaults.
        
        :param object_store_account: (required)
        :type object_store_account: ObjectStoreAccountPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param ignore_usage: Allow update operations that lead to a `hard_limit_enabled` object store
                            account, bucket, or file system with usage over its limiting value. For
                            object store accounts and buckets, the limiting value is that of
                            `quota_limit`, and for file systems it is that of `provisioned`. The
                            operation can be setting `hard_limit_enabled` when usage is higher than the
                            limiting value, modifying the limiting value to a value under usage when
                            `hard_limit_enabled`, recovering a destroyed bucket of an object store
                            account that causes an account's space usage to go over its hard
                            `quota_limit`. Also allows update operations that would cause usage of the
                            requested storage class to go over its warning threshold.
        :type ignore_usage: bool
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            object_store_account=object_store_account,
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            ignore_usage=ignore_usage,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names'], kwargs)
        return self._call_api('ObjectStoreAccountsApi', 'api217_object_store_accounts_patch_with_http_info', kwargs)

    def post_object_store_accounts(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        object_store_account: Optional['models.ObjectStoreAccountPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-accounts
        
        Create an object store account.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param object_store_account:
        :type object_store_account: ObjectStoreAccountPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            x_request_id=x_request_id,
            context_names=context_names,
            object_store_account=object_store_account,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _fixup_list_type_params(['names', 'context_names'], kwargs)
        return self._call_api('ObjectStoreAccountsApi', 'api217_object_store_accounts_post_with_http_info', kwargs)

    def delete_object_store_remote_credentials(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-remote-credentials
        
        Delete object store remote credentials.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names'], kwargs)
        return self._call_api('ObjectStoreRemoteCredentialsApi', 'api217_object_store_remote_credentials_delete_with_http_info', kwargs)

    def get_object_store_remote_credentials(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-remote-credentials
        
        List object store remote credentials used by bucket replica links to access buckets on remote arrays or targets.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'sort'], kwargs)
        return self._call_api('ObjectStoreRemoteCredentialsApi', 'api217_object_store_remote_credentials_get_with_http_info', kwargs)

    def patch_object_store_remote_credentials(
        self,
        remote_credentials: 'models.ObjectStoreRemoteCredentials',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH object-store-remote-credentials
        
        Rename and/or change the access key/secret key pair for object store remote credentials.
        
        :param remote_credentials: (required)
        :type remote_credentials: ObjectStoreRemoteCredentials
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            remote_credentials=remote_credentials,
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names'], kwargs)
        return self._call_api('ObjectStoreRemoteCredentialsApi', 'api217_object_store_remote_credentials_patch_with_http_info', kwargs)

    def post_object_store_remote_credentials(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        remote_credentials: 'models.ObjectStoreRemoteCredentialsPost',
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-remote-credentials
        
        Create object store remote credentials to set up bucket replicat links to a remote array or target.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param remote_credentials: (required)
        :type remote_credentials: ObjectStoreRemoteCredentialsPost
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            remote_credentials=remote_credentials,
            x_request_id=x_request_id,
            context_names=context_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _fixup_list_type_params(['names', 'context_names'], kwargs)
        return self._call_api('ObjectStoreRemoteCredentialsApi', 'api217_object_store_remote_credentials_post_with_http_info', kwargs)

    def delete_object_store_roles(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-roles
        
        Delete existing object store roles.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names'], kwargs)
        return self._call_api('ObjectStoreRolesApi', 'api217_object_store_roles_delete_with_http_info', kwargs)

    def get_object_store_roles(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-roles
        
        List object store roles and their attributes.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'sort'], kwargs)
        return self._call_api('ObjectStoreRolesApi', 'api217_object_store_roles_get_with_http_info', kwargs)

    def delete_object_store_roles_object_store_access_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-roles/object-store-access-policies
        
        Revoke an object store role's access policy.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('ObjectStoreRolesApi', 'api217_object_store_roles_object_store_access_policies_delete_with_http_info', kwargs)

    def get_object_store_roles_object_store_access_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-roles/object-store-access-policies
        
        List object store roles and their access policies.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('ObjectStoreRolesApi', 'api217_object_store_roles_object_store_access_policies_get_with_http_info', kwargs)

    def post_object_store_roles_object_store_access_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-roles/object-store-access-policies
        
        Grant access policies to an object store role.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('ObjectStoreRolesApi', 'api217_object_store_roles_object_store_access_policies_post_with_http_info', kwargs)

    def get_object_store_roles_object_store_trust_policies_download(
        self,
        roles: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        role_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of object store role IDs. If after filtering, there is not at least one resource that matches each of the elements of `role_ids`, then an error is returned. This cannot be provided together with the `role_names` query parameter.")] = None,
        role_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of object store role names. If there is not at least one resource that matches each of the elements of `role_names`, then an error is returned. This cannot be provided together with the `role_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-roles/object-store-trust-policies/download
        
        Download object store roles and their trust policies in native AWS format.
        
        :param roles: A list of roles to query for. Overrides role_ids and role_names keyword arguments.
        :type roles: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param role_ids: A comma-separated list of object store role IDs. If after filtering, there is
                        not at least one resource that matches each of the elements of `role_ids`,
                        then an error is returned. This cannot be provided together with the
                        `role_names` query parameter.
        :type role_ids: List[str]
        :param role_names: A comma-separated list of object store role names. If there is not at least one
                        resource that matches each of the elements of `role_names`, then an error is
                        returned. This cannot be provided together with the `role_ids` query
                        parameter.
        :type role_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            names=names,
            role_ids=role_ids,
            role_names=role_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _process_references(roles, ['role_ids', 'role_names'], kwargs)
        _fixup_list_type_params(['names', 'role_ids', 'role_names'], kwargs)
        return self._call_api('ObjectStoreRolesApi', 'api217_object_store_roles_object_store_trust_policies_download_get_with_http_info', kwargs)

    def get_object_store_roles_object_store_trust_policies(
        self,
        roles: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        role_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of object store role IDs. If after filtering, there is not at least one resource that matches each of the elements of `role_ids`, then an error is returned. This cannot be provided together with the `role_names` query parameter.")] = None,
        role_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of object store role names. If there is not at least one resource that matches each of the elements of `role_names`, then an error is returned. This cannot be provided together with the `role_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-roles/object-store-trust-policies
        
        List object store roles and their trust policies.
        
        :param roles: A list of roles to query for. Overrides role_ids and role_names keyword arguments.
        :type roles: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param role_ids: A comma-separated list of object store role IDs. If after filtering, there is
                        not at least one resource that matches each of the elements of `role_ids`,
                        then an error is returned. This cannot be provided together with the
                        `role_names` query parameter.
        :type role_ids: List[str]
        :param role_names: A comma-separated list of object store role names. If there is not at least one
                        resource that matches each of the elements of `role_names`, then an error is
                        returned. This cannot be provided together with the `role_ids` query
                        parameter.
        :type role_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            names=names,
            offset=offset,
            role_ids=role_ids,
            role_names=role_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _process_references(roles, ['role_ids', 'role_names'], kwargs)
        _fixup_list_type_params(['context_names', 'names', 'role_ids', 'role_names', 'sort'], kwargs)
        return self._call_api('ObjectStoreRolesApi', 'api217_object_store_roles_object_store_trust_policies_get_with_http_info', kwargs)

    def delete_object_store_roles_object_store_trust_policies_rules(
        self,
        roles: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        indices: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of resource indices. If there is not at least one resource that matches each of the elements of `indices`, then an error is returned.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        role_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of object store role IDs. If after filtering, there is not at least one resource that matches each of the elements of `role_ids`, then an error is returned. This cannot be provided together with the `role_names` query parameter.")] = None,
        role_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of object store role names. If there is not at least one resource that matches each of the elements of `role_names`, then an error is returned. This cannot be provided together with the `role_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-roles/object-store-trust-policies/rules
        
        Delete one or more trust policy rules.
        
        :param roles: A list of roles to query for. Overrides role_ids and role_names keyword arguments.
        :type roles: ReferenceType or List[ReferenceType], optional
        :param policies: A list of policies to query for. Overrides policy_names keyword argument.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param indices: A comma-separated list of resource indices. If there is not at least one
                        resource that matches each of the elements of `indices`, then an error is
                        returned.
        :type indices: List[int]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param role_ids: A comma-separated list of object store role IDs. If after filtering, there is
                        not at least one resource that matches each of the elements of `role_ids`,
                        then an error is returned. This cannot be provided together with the
                        `role_names` query parameter.
        :type role_ids: List[str]
        :param role_names: A comma-separated list of object store role names. If there is not at least one
                        resource that matches each of the elements of `role_names`, then an error is
                        returned. This cannot be provided together with the `role_ids` query
                        parameter.
        :type role_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            indices=indices,
            names=names,
            policy_names=policy_names,
            role_ids=role_ids,
            role_names=role_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _process_references(policies, ['policy_names'], kwargs)
        _process_references(roles, ['role_ids', 'role_names'], kwargs)
        _fixup_list_type_params(['context_names', 'indices', 'names', 'policy_names', 'role_ids', 'role_names'], kwargs)
        return self._call_api('ObjectStoreRolesApi', 'api217_object_store_roles_object_store_trust_policies_rules_delete_with_http_info', kwargs)

    def get_object_store_roles_object_store_trust_policies_rules(
        self,
        roles: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        indices: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of resource indices. If there is not at least one resource that matches each of the elements of `indices`, then an error is returned.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        role_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of object store role IDs. If after filtering, there is not at least one resource that matches each of the elements of `role_ids`, then an error is returned. This cannot be provided together with the `role_names` query parameter.")] = None,
        role_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of object store role names. If there is not at least one resource that matches each of the elements of `role_names`, then an error is returned. This cannot be provided together with the `role_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-roles/object-store-trust-policies/rules
        
        List trust policy rules and their attributes.
        
        :param roles: A list of roles to query for. Overrides role_ids and role_names keyword arguments.
        :type roles: ReferenceType or List[ReferenceType], optional
        :param policies: A list of policies to query for. Overrides policy_names keyword argument.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param indices: A comma-separated list of resource indices. If there is not at least one
                        resource that matches each of the elements of `indices`, then an error is
                        returned.
        :type indices: List[int]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param role_ids: A comma-separated list of object store role IDs. If after filtering, there is
                        not at least one resource that matches each of the elements of `role_ids`,
                        then an error is returned. This cannot be provided together with the
                        `role_names` query parameter.
        :type role_ids: List[str]
        :param role_names: A comma-separated list of object store role names. If there is not at least one
                        resource that matches each of the elements of `role_names`, then an error is
                        returned. This cannot be provided together with the `role_ids` query
                        parameter.
        :type role_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            indices=indices,
            limit=limit,
            names=names,
            offset=offset,
            policy_names=policy_names,
            role_ids=role_ids,
            role_names=role_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _process_references(policies, ['policy_names'], kwargs)
        _process_references(roles, ['role_ids', 'role_names'], kwargs)
        _fixup_list_type_params(['context_names', 'indices', 'names', 'policy_names', 'role_ids', 'role_names', 'sort'], kwargs)
        return self._call_api('ObjectStoreRolesApi', 'api217_object_store_roles_object_store_trust_policies_rules_get_with_http_info', kwargs)

    def patch_object_store_roles_object_store_trust_policies_rules(
        self,
        rule: 'models.TrustPolicyRulePost',
        roles: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        indices: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of resource indices. If there is not at least one resource that matches each of the elements of `indices`, then an error is returned.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        role_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of object store role IDs. If after filtering, there is not at least one resource that matches each of the elements of `role_ids`, then an error is returned. This cannot be provided together with the `role_names` query parameter.")] = None,
        role_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of object store role names. If there is not at least one resource that matches each of the elements of `role_names`, then an error is returned. This cannot be provided together with the `role_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH object-store-roles/object-store-trust-policies/rules
        
        Modify a trust policy rule's attributes.
        
        :param rule: (required)
        :type rule: TrustPolicyRulePost
        :param roles: A list of roles to query for. Overrides role_ids and role_names keyword arguments.
        :type roles: ReferenceType or List[ReferenceType], optional
        :param policies: A list of policies to query for. Overrides policy_names keyword argument.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param indices: A comma-separated list of resource indices. If there is not at least one
                        resource that matches each of the elements of `indices`, then an error is
                        returned.
        :type indices: List[int]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param role_ids: A comma-separated list of object store role IDs. If after filtering, there is
                        not at least one resource that matches each of the elements of `role_ids`,
                        then an error is returned. This cannot be provided together with the
                        `role_names` query parameter.
        :type role_ids: List[str]
        :param role_names: A comma-separated list of object store role names. If there is not at least one
                        resource that matches each of the elements of `role_names`, then an error is
                        returned. This cannot be provided together with the `role_ids` query
                        parameter.
        :type role_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            rule=rule,
            x_request_id=x_request_id,
            context_names=context_names,
            indices=indices,
            names=names,
            policy_names=policy_names,
            role_ids=role_ids,
            role_names=role_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _process_references(policies, ['policy_names'], kwargs)
        _process_references(roles, ['role_ids', 'role_names'], kwargs)
        _fixup_list_type_params(['context_names', 'indices', 'names', 'policy_names', 'role_ids', 'role_names'], kwargs)
        return self._call_api('ObjectStoreRolesApi', 'api217_object_store_roles_object_store_trust_policies_rules_patch_with_http_info', kwargs)

    def post_object_store_roles_object_store_trust_policies_rules(
        self,
        rule: 'models.TrustPolicyRulePost',
        roles: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        role_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of object store role IDs. If after filtering, there is not at least one resource that matches each of the elements of `role_ids`, then an error is returned. This cannot be provided together with the `role_names` query parameter.")] = None,
        role_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of object store role names. If there is not at least one resource that matches each of the elements of `role_names`, then an error is returned. This cannot be provided together with the `role_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-roles/object-store-trust-policies/rules
        
        Create a new trust policy rule.
        
        :param rule: (required)
        :type rule: TrustPolicyRulePost
        :param roles: A list of roles to query for. Overrides role_ids and role_names keyword arguments.
        :type roles: ReferenceType or List[ReferenceType], optional
        :param policies: A list of policies to query for. Overrides policy_names keyword argument.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param role_ids: A comma-separated list of object store role IDs. If after filtering, there is
                        not at least one resource that matches each of the elements of `role_ids`,
                        then an error is returned. This cannot be provided together with the
                        `role_names` query parameter.
        :type role_ids: List[str]
        :param role_names: A comma-separated list of object store role names. If there is not at least one
                        resource that matches each of the elements of `role_names`, then an error is
                        returned. This cannot be provided together with the `role_ids` query
                        parameter.
        :type role_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            rule=rule,
            x_request_id=x_request_id,
            context_names=context_names,
            names=names,
            policy_names=policy_names,
            role_ids=role_ids,
            role_names=role_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _process_references(policies, ['policy_names'], kwargs)
        _process_references(roles, ['role_ids', 'role_names'], kwargs)
        _fixup_list_type_params(['context_names', 'names', 'policy_names', 'role_ids', 'role_names'], kwargs)
        return self._call_api('ObjectStoreRolesApi', 'api217_object_store_roles_object_store_trust_policies_rules_post_with_http_info', kwargs)

    def patch_object_store_roles_object_store_trust_policies_upload(
        self,
        policy_document: Annotated[StrictStr, Field(..., description="The trust policy document to upload.")],
        roles: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        role_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of object store role IDs. If after filtering, there is not at least one resource that matches each of the elements of `role_ids`, then an error is returned. This cannot be provided together with the `role_names` query parameter.")] = None,
        role_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of object store role names. If there is not at least one resource that matches each of the elements of `role_names`, then an error is returned. This cannot be provided together with the `role_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH object-store-roles/object-store-trust-policies/upload
        
        Upload object store roles and their trust policies in native AWS format.
        
        :param policy_document: The trust policy document to upload. (required)
        :type policy_document: str
        :param roles: A list of roles to query for. Overrides role_ids and role_names keyword arguments.
        :type roles: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param role_ids: A comma-separated list of object store role IDs. If after filtering, there is
                        not at least one resource that matches each of the elements of `role_ids`,
                        then an error is returned. This cannot be provided together with the
                        `role_names` query parameter.
        :type role_ids: List[str]
        :param role_names: A comma-separated list of object store role names. If there is not at least one
                        resource that matches each of the elements of `role_names`, then an error is
                        returned. This cannot be provided together with the `role_ids` query
                        parameter.
        :type role_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            policy_document=policy_document,
            x_request_id=x_request_id,
            context_names=context_names,
            names=names,
            role_ids=role_ids,
            role_names=role_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _process_references(roles, ['role_ids', 'role_names'], kwargs)
        _fixup_list_type_params(['context_names', 'names', 'role_ids', 'role_names'], kwargs)
        return self._call_api('ObjectStoreRolesApi', 'api217_object_store_roles_object_store_trust_policies_upload_patch_with_http_info', kwargs)

    def patch_object_store_roles(
        self,
        object_store_role: 'models.ObjectStoreRole',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH object-store-roles
        
        Modify existing object store roles.
        
        :param object_store_role: (required)
        :type object_store_role: ObjectStoreRole
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            object_store_role=object_store_role,
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names'], kwargs)
        return self._call_api('ObjectStoreRolesApi', 'api217_object_store_roles_patch_with_http_info', kwargs)

    def post_object_store_roles(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        object_store_role: 'models.ObjectStoreRolePost',
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-roles
        
        Create new object store roles.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param object_store_role: (required)
        :type object_store_role: ObjectStoreRolePost
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            object_store_role=object_store_role,
            x_request_id=x_request_id,
            context_names=context_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _fixup_list_type_params(['names', 'context_names'], kwargs)
        return self._call_api('ObjectStoreRolesApi', 'api217_object_store_roles_post_with_http_info', kwargs)

    def delete_object_store_users(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-users
        
        Delete an object store user.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names'], kwargs)
        return self._call_api('ObjectStoreUsersApi', 'api217_object_store_users_delete_with_http_info', kwargs)

    def get_object_store_users(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-users
        
        List object store users and their attributes.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'sort'], kwargs)
        return self._call_api('ObjectStoreUsersApi', 'api217_object_store_users_get_with_http_info', kwargs)

    def delete_object_store_users_object_store_access_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-users/object-store-access-policies
        
        Revoke an object store users access policy.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('ObjectStoreUsersApi', 'api217_object_store_users_object_store_access_policies_delete_with_http_info', kwargs)

    def get_object_store_users_object_store_access_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-users/object-store-access-policies
        
        List object store users and their access policies.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('ObjectStoreUsersApi', 'api217_object_store_users_object_store_access_policies_get_with_http_info', kwargs)

    def post_object_store_users_object_store_access_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-users/object-store-access-policies
        
        Grant access policies to an object store user.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('ObjectStoreUsersApi', 'api217_object_store_users_object_store_access_policies_post_with_http_info', kwargs)

    def post_object_store_users(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        full_access: Annotated[Optional[StrictBool], Field(description="If set to `true`, creates an object store user with full permissions. If set to `false`, creates an object store user with no permission. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-users
        
        Create object store users to administer object storage for an object store account.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param full_access: If set to `true`, creates an object store user with full permissions. If set to
                            `false`, creates an object store user with no permission. If not specified,
                            defaults to `false`.
        :type full_access: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            x_request_id=x_request_id,
            context_names=context_names,
            full_access=full_access,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _fixup_list_type_params(['names', 'context_names'], kwargs)
        return self._call_api('ObjectStoreUsersApi', 'api217_object_store_users_post_with_http_info', kwargs)

    def delete_object_store_virtual_hosts(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-virtual-hosts
        
        Delete an object store virtual host.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names'], kwargs)
        return self._call_api('ObjectStoreVirtualHostsApi', 'api217_object_store_virtual_hosts_delete_with_http_info', kwargs)

    def get_object_store_virtual_hosts(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-virtual-hosts
        
        List object store virtual hosts.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'sort'], kwargs)
        return self._call_api('ObjectStoreVirtualHostsApi', 'api217_object_store_virtual_hosts_get_with_http_info', kwargs)

    def post_object_store_virtual_hosts(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-virtual-hosts
        
        Create an object store virtual host. An example of a hostname is buckethost.example.com. A hostname cannot exceed 255 characters in length, it cannot be an IP address, only 10 hostnames are supported, supersets or subsets of existing hostnames with the same root are not allowed. The default hostname is s3.amazonaws.com and it cannot be deleted.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            x_request_id=x_request_id,
            context_names=context_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _fixup_list_type_params(['names', 'context_names'], kwargs)
        return self._call_api('ObjectStoreVirtualHostsApi', 'api217_object_store_virtual_hosts_post_with_http_info', kwargs)

    def get_policies_all(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET policies-all
        
        List all policies of all types.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'sort'], kwargs)
        return self._call_api('PoliciesAllApi', 'api217_policies_all_get_with_http_info', kwargs)

    def get_policies_all_members(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        member_types: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member types. Valid values are `file-systems`, `file-system-snapshots`, `file-system-replica-links`, and `object-store-users`. Different endpoints may accept different subsets of these values.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        remote_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system IDs. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_names` query parameter.")] = None,
        remote_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_ids` query parameter.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET policies-all/members
        
        List policies (of all types) mapped to other entities (file systems, snapshots, file system replica links, and object store users). Note: if more than 150,000 items would be returned in the response, an error will be thrown and query parameters must be used to limit the items queried.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param remote_file_systems: A list of remote_file_systems to query for. Overrides remote_file_system_ids and remote_file_system_names keyword arguments.
        :type remote_file_systems: ReferenceType or List[ReferenceType], optional
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param member_types: A comma-separated list of member types. Valid values are `file-systems`, `file-
                            system-snapshots`, `file-system-replica-links`, and `object-store-users`.
                            Different endpoints may accept different subsets of these values.
        :type member_types: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_file_system_ids: A comma-separated list of remote file system IDs. If there is not at least one
                                    resource that matches each of the elements, then an error is returned.
                                    This cannot be provided together with the `remote_file_system_names`
                                    query parameter.
        :type remote_file_system_ids: List[str]
        :param remote_file_system_names: A comma-separated list of remote file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with the `remote_file_system_ids` query
                                        parameter.
        :type remote_file_system_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            member_ids=member_ids,
            member_names=member_names,
            member_types=member_types,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            remote_file_system_ids=remote_file_system_ids,
            remote_file_system_names=remote_file_system_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _process_references(remote_file_systems, ['remote_file_system_ids', 'remote_file_system_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['context_names', 'local_file_system_ids', 'local_file_system_names', 'member_ids', 'member_names', 'member_types', 'policy_ids', 'policy_names', 'remote_file_system_ids', 'remote_file_system_names', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('PoliciesAllApi', 'api217_policies_all_members_get_with_http_info', kwargs)

    def delete_audit_file_systems_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE audit-file-systems-policies
        
        Delete one or more audit policies.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names'], kwargs)
        return self._call_api('PoliciesAuditForFileSystemsApi', 'api217_audit_file_systems_policies_delete_with_http_info', kwargs)

    def get_audit_file_systems_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET audit-file-systems-policies
        
        Displays a list of audit policies for file systems.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'sort'], kwargs)
        return self._call_api('PoliciesAuditForFileSystemsApi', 'api217_audit_file_systems_policies_get_with_http_info', kwargs)

    def delete_audit_file_systems_policies_members(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE audit-file-systems-policies/members
        
        Remove the audit policy mapped to a file system.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesAuditForFileSystemsApi', 'api217_audit_file_systems_policies_members_delete_with_http_info', kwargs)

    def get_audit_file_systems_policies_members(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET audit-file-systems-policies/members
        
        List file systems mapped to a audit policy.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesAuditForFileSystemsApi', 'api217_audit_file_systems_policies_members_get_with_http_info', kwargs)

    def post_audit_file_systems_policies_members(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST audit-file-systems-policies/members
        
        Map a file system to a audit policy.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesAuditForFileSystemsApi', 'api217_audit_file_systems_policies_members_post_with_http_info', kwargs)

    def patch_audit_file_systems_policies(
        self,
        policy: 'models.AuditFileSystemsPoliciesPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH audit-file-systems-policies
        
        Modify an existing audit policy's attributes.
        
        :param policy: (required)
        :type policy: AuditFileSystemsPoliciesPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            policy=policy,
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names'], kwargs)
        return self._call_api('PoliciesAuditForFileSystemsApi', 'api217_audit_file_systems_policies_patch_with_http_info', kwargs)

    def post_audit_file_systems_policies(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        policy: Optional['models.AuditFileSystemsPoliciesPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST audit-file-systems-policies
        
        Create a new audit policy for file systems.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param policy:
        :type policy: AuditFileSystemsPoliciesPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            x_request_id=x_request_id,
            context_names=context_names,
            policy=policy,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _fixup_list_type_params(['names', 'context_names'], kwargs)
        return self._call_api('PoliciesAuditForFileSystemsApi', 'api217_audit_file_systems_policies_post_with_http_info', kwargs)

    def delete_nfs_export_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        versions: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of versions. This is an optional query param used for concurrency control. The ordering should match the names or ids query param. This will fail with a 412 Precondition failed if the resource was changed and the current version of the resource doesn't match the value in the query param.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE nfs-export-policies
        
        Delete one or more NFS export policies.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param versions: A comma-separated list of versions. This is an optional query param used for
                        concurrency control. The ordering should match the names or ids query param.
                        This will fail with a 412 Precondition failed if the resource was changed
                        and the current version of the resource doesn't match the value in the query
                        param.
        :type versions: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            versions=versions,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'versions'], kwargs)
        return self._call_api('PoliciesNFSApi', 'api217_nfs_export_policies_delete_with_http_info', kwargs)

    def get_nfs_export_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET nfs-export-policies
        
        Displays a list of NFS export policies.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'sort'], kwargs)
        return self._call_api('PoliciesNFSApi', 'api217_nfs_export_policies_get_with_http_info', kwargs)

    def patch_nfs_export_policies(
        self,
        policy: 'models.NfsExportPolicy',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        versions: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of versions. This is an optional query param used for concurrency control. The ordering should match the names or ids query param. This will fail with a 412 Precondition failed if the resource was changed and the current version of the resource doesn't match the value in the query param.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH nfs-export-policies
        
        Modify an existing NFS export policy's attributes.
        
        :param policy: (required)
        :type policy: NfsExportPolicy
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param versions: A comma-separated list of versions. This is an optional query param used for
                        concurrency control. The ordering should match the names or ids query param.
                        This will fail with a 412 Precondition failed if the resource was changed
                        and the current version of the resource doesn't match the value in the query
                        param.
        :type versions: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            policy=policy,
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            versions=versions,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'versions'], kwargs)
        return self._call_api('PoliciesNFSApi', 'api217_nfs_export_policies_patch_with_http_info', kwargs)

    def post_nfs_export_policies(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        policy: Optional['models.NfsExportPolicyPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST nfs-export-policies
        
        Create a new NFS export policy.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param policy:
        :type policy: NfsExportPolicyPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            x_request_id=x_request_id,
            context_names=context_names,
            policy=policy,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _fixup_list_type_params(['names', 'context_names'], kwargs)
        return self._call_api('PoliciesNFSApi', 'api217_nfs_export_policies_post_with_http_info', kwargs)

    def delete_nfs_export_policies_rules(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        versions: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of versions. This is an optional query param used for concurrency control. The ordering should match the names or ids query param. This will fail with a 412 Precondition failed if the resource was changed and the current version of the resource doesn't match the value in the query param.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE nfs-export-policies/rules
        
        Delete one or more NFS export policy rules. One of the following is required: `ids` or `names`.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param versions: A comma-separated list of versions. This is an optional query param used for
                        concurrency control. The ordering should match the names or ids query param.
                        This will fail with a 412 Precondition failed if the resource was changed
                        and the current version of the resource doesn't match the value in the query
                        param.
        :type versions: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            versions=versions,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'versions'], kwargs)
        return self._call_api('PoliciesNFSApi', 'api217_nfs_export_policies_rules_delete_with_http_info', kwargs)

    def get_nfs_export_policies_rules(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET nfs-export-policies/rules
        
        Displays a list of NFS export policy rules. The default sort is by policy name, then index.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesNFSApi', 'api217_nfs_export_policies_rules_get_with_http_info', kwargs)

    def patch_nfs_export_policies_rules(
        self,
        rule: 'models.NfsExportPolicyRule',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        before_rule_id: Annotated[Optional[StrictStr], Field(description="The id of the rule to insert or move a rule before. This cannot be provided together with the `before_rule_name` query parameter.")] = None,
        before_rule_name: Annotated[Optional[StrictStr], Field(description="The name of the rule to insert or move a rule before. This cannot be provided together with the `before_rule_id` query parameter.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        versions: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of versions. This is an optional query param used for concurrency control. The ordering should match the names or ids query param. This will fail with a 412 Precondition failed if the resource was changed and the current version of the resource doesn't match the value in the query param.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH nfs-export-policies/rules
        
        Modify an existing NFS export policy rule. If `before_rule_id` or `before_rule_name` are specified, the rule will be moved before that rule. Rules are ordered in three groups; ip addresses, other and `*` and can only be moved within the appropriate group. One of the following is required: `ids` or `names`.
        
        :param rule: (required)
        :type rule: NfsExportPolicyRule
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param before_rule_id: The id of the rule to insert or move a rule before. This cannot be provided
                            together with the `before_rule_name` query parameter.
        :type before_rule_id: str
        :param before_rule_name: The name of the rule to insert or move a rule before. This cannot be provided
                                together with the `before_rule_id` query parameter.
        :type before_rule_name: str
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param versions: A comma-separated list of versions. This is an optional query param used for
                        concurrency control. The ordering should match the names or ids query param.
                        This will fail with a 412 Precondition failed if the resource was changed
                        and the current version of the resource doesn't match the value in the query
                        param.
        :type versions: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            rule=rule,
            x_request_id=x_request_id,
            before_rule_id=before_rule_id,
            before_rule_name=before_rule_name,
            context_names=context_names,
            ids=ids,
            names=names,
            versions=versions,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'versions'], kwargs)
        return self._call_api('PoliciesNFSApi', 'api217_nfs_export_policies_rules_patch_with_http_info', kwargs)

    def post_nfs_export_policies_rules(
        self,
        rule: 'models.NfsExportPolicyRule',
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        before_rule_id: Annotated[Optional[StrictStr], Field(description="The id of the rule to insert or move a rule before. This cannot be provided together with the `before_rule_name` query parameter.")] = None,
        before_rule_name: Annotated[Optional[StrictStr], Field(description="The name of the rule to insert or move a rule before. This cannot be provided together with the `before_rule_id` query parameter.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        versions: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of versions. This is an optional query param used for concurrency control. The ordering should match the names or ids query param. This will fail with a 412 Precondition failed if the resource was changed and the current version of the resource doesn't match the value in the query param.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST nfs-export-policies/rules
        
        Add a NFS export policy rule. Rules are ordered in three groups; ip addresses, other and `*`. The new rule will be added at the end of the appropriate group if neither `before_rule_id` and `before_rule_name` are specified. Rules can only be inserted into the appropriate group. Either `policy_ids` or `policy_names` parameter is required.
        
        :param rule: (required)
        :type rule: NfsExportPolicyRule
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param before_rule_id: The id of the rule to insert or move a rule before. This cannot be provided
                            together with the `before_rule_name` query parameter.
        :type before_rule_id: str
        :param before_rule_name: The name of the rule to insert or move a rule before. This cannot be provided
                                together with the `before_rule_id` query parameter.
        :type before_rule_name: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param versions: A comma-separated list of versions. This is an optional query param used for
                        concurrency control. The ordering should match the names or ids query param.
                        This will fail with a 412 Precondition failed if the resource was changed
                        and the current version of the resource doesn't match the value in the query
                        param.
        :type versions: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            rule=rule,
            x_request_id=x_request_id,
            before_rule_id=before_rule_id,
            before_rule_name=before_rule_name,
            context_names=context_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            versions=versions,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'policy_ids', 'policy_names', 'versions'], kwargs)
        return self._call_api('PoliciesNFSApi', 'api217_nfs_export_policies_rules_post_with_http_info', kwargs)

    def get_network_access_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET network-access-policies
        
        Displays a list of network access policies.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('PoliciesNetworkAccessApi', 'api217_network_access_policies_get_with_http_info', kwargs)

    def get_network_access_policies_members(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET network-access-policies/members
        
        List network access policies mapped to different configurations on the array.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesNetworkAccessApi', 'api217_network_access_policies_members_get_with_http_info', kwargs)

    def patch_network_access_policies(
        self,
        policy: 'models.NetworkAccessPolicy',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        versions: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of versions. This is an optional query param used for concurrency control. The ordering should match the names or ids query param. This will fail with a 412 Precondition failed if the resource was changed and the current version of the resource doesn't match the value in the query param.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH network-access-policies
        
        Modify an existing network access policy's attributes.
        
        :param policy: (required)
        :type policy: NetworkAccessPolicy
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param versions: A comma-separated list of versions. This is an optional query param used for
                        concurrency control. The ordering should match the names or ids query param.
                        This will fail with a 412 Precondition failed if the resource was changed
                        and the current version of the resource doesn't match the value in the query
                        param.
        :type versions: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            policy=policy,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            versions=versions,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'versions'], kwargs)
        return self._call_api('PoliciesNetworkAccessApi', 'api217_network_access_policies_patch_with_http_info', kwargs)

    def delete_network_access_policies_rules(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        versions: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of versions. This is an optional query param used for concurrency control. The ordering should match the names or ids query param. This will fail with a 412 Precondition failed if the resource was changed and the current version of the resource doesn't match the value in the query param.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE network-access-policies/rules
        
        Delete one or more network access policy rules.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param versions: A comma-separated list of versions. This is an optional query param used for
                        concurrency control. The ordering should match the names or ids query param.
                        This will fail with a 412 Precondition failed if the resource was changed
                        and the current version of the resource doesn't match the value in the query
                        param.
        :type versions: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            versions=versions,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'versions'], kwargs)
        return self._call_api('PoliciesNetworkAccessApi', 'api217_network_access_policies_rules_delete_with_http_info', kwargs)

    def get_network_access_policies_rules(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET network-access-policies/rules
        
        Displays a list of network access policy rules.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesNetworkAccessApi', 'api217_network_access_policies_rules_get_with_http_info', kwargs)

    def patch_network_access_policies_rules(
        self,
        rule: 'models.NetworkAccessPolicyRule',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        before_rule_id: Annotated[Optional[StrictStr], Field(description="The id of the rule to insert or move a rule before. This cannot be provided together with the `before_rule_name` query parameter.")] = None,
        before_rule_name: Annotated[Optional[StrictStr], Field(description="The name of the rule to insert or move a rule before. This cannot be provided together with the `before_rule_id` query parameter.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        versions: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of versions. This is an optional query param used for concurrency control. The ordering should match the names or ids query param. This will fail with a 412 Precondition failed if the resource was changed and the current version of the resource doesn't match the value in the query param.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH network-access-policies/rules
        
        Modify an existing network access policy rule.
        
        :param rule: (required)
        :type rule: NetworkAccessPolicyRule
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param before_rule_id: The id of the rule to insert or move a rule before. This cannot be provided
                            together with the `before_rule_name` query parameter.
        :type before_rule_id: str
        :param before_rule_name: The name of the rule to insert or move a rule before. This cannot be provided
                                together with the `before_rule_id` query parameter.
        :type before_rule_name: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param versions: A comma-separated list of versions. This is an optional query param used for
                        concurrency control. The ordering should match the names or ids query param.
                        This will fail with a 412 Precondition failed if the resource was changed
                        and the current version of the resource doesn't match the value in the query
                        param.
        :type versions: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            rule=rule,
            x_request_id=x_request_id,
            before_rule_id=before_rule_id,
            before_rule_name=before_rule_name,
            ids=ids,
            names=names,
            versions=versions,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'versions'], kwargs)
        return self._call_api('PoliciesNetworkAccessApi', 'api217_network_access_policies_rules_patch_with_http_info', kwargs)

    def post_network_access_policies_rules(
        self,
        rule: 'models.NetworkAccessPolicyRulePost',
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        before_rule_id: Annotated[Optional[StrictStr], Field(description="The id of the rule to insert or move a rule before. This cannot be provided together with the `before_rule_name` query parameter.")] = None,
        before_rule_name: Annotated[Optional[StrictStr], Field(description="The name of the rule to insert or move a rule before. This cannot be provided together with the `before_rule_id` query parameter.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        versions: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of versions. This is an optional query param used for concurrency control. The ordering should match the names or ids query param. This will fail with a 412 Precondition failed if the resource was changed and the current version of the resource doesn't match the value in the query param.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST network-access-policies/rules
        
        Create a new network access policy rule. Either `policy_ids` or `policy_names` parameter is required.
        
        :param rule: (required)
        :type rule: NetworkAccessPolicyRulePost
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param before_rule_id: The id of the rule to insert or move a rule before. This cannot be provided
                            together with the `before_rule_name` query parameter.
        :type before_rule_id: str
        :param before_rule_name: The name of the rule to insert or move a rule before. This cannot be provided
                                together with the `before_rule_id` query parameter.
        :type before_rule_name: str
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param versions: A comma-separated list of versions. This is an optional query param used for
                        concurrency control. The ordering should match the names or ids query param.
                        This will fail with a 412 Precondition failed if the resource was changed
                        and the current version of the resource doesn't match the value in the query
                        param.
        :type versions: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            rule=rule,
            x_request_id=x_request_id,
            before_rule_id=before_rule_id,
            before_rule_name=before_rule_name,
            policy_ids=policy_ids,
            policy_names=policy_names,
            versions=versions,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['policy_ids', 'policy_names', 'versions'], kwargs)
        return self._call_api('PoliciesNetworkAccessApi', 'api217_network_access_policies_rules_post_with_http_info', kwargs)

    def delete_object_store_access_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-access-policies
        
        Delete one or more access policies.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names'], kwargs)
        return self._call_api('PoliciesObjectStoreAccessApi', 'api217_object_store_access_policies_delete_with_http_info', kwargs)

    def get_object_store_access_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        exclude_rules: Annotated[Optional[StrictBool], Field(description="If true, the rules field in each policy will be null. If false, each returned policy will include its list of rules in the response. If not specified, defaults to `false`.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-access-policies
        
        List access policies and their attributes.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param exclude_rules: If true, the rules field in each policy will be null. If false, each returned
                            policy will include its list of rules in the response. If not specified,
                            defaults to `false`.
        :type exclude_rules: bool
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            exclude_rules=exclude_rules,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'sort'], kwargs)
        return self._call_api('PoliciesObjectStoreAccessApi', 'api217_object_store_access_policies_get_with_http_info', kwargs)

    def delete_object_store_access_policies_object_store_roles(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-access-policies/object-store-roles
        
        Revoke an object store role's access policy.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesObjectStoreAccessApi', 'api217_object_store_access_policies_object_store_roles_delete_with_http_info', kwargs)

    def get_object_store_access_policies_object_store_roles(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-access-policies/object-store-roles
        
        List object store roles and their access policies.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesObjectStoreAccessApi', 'api217_object_store_access_policies_object_store_roles_get_with_http_info', kwargs)

    def post_object_store_access_policies_object_store_roles(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-access-policies/object-store-roles
        
        Grant access policies to an object store role.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesObjectStoreAccessApi', 'api217_object_store_access_policies_object_store_roles_post_with_http_info', kwargs)

    def delete_object_store_access_policies_object_store_users(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-access-policies/object-store-users
        
        Revokes an object store user's access policy.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesObjectStoreAccessApi', 'api217_object_store_access_policies_object_store_users_delete_with_http_info', kwargs)

    def get_object_store_access_policies_object_store_users(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-access-policies/object-store-users
        
        List object store users and their access policies.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesObjectStoreAccessApi', 'api217_object_store_access_policies_object_store_users_get_with_http_info', kwargs)

    def post_object_store_access_policies_object_store_users(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-access-policies/object-store-users
        
        Grant access policies to an object store user.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesObjectStoreAccessApi', 'api217_object_store_access_policies_object_store_users_post_with_http_info', kwargs)

    def patch_object_store_access_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        enforce_action_restrictions: Annotated[Optional[StrictBool], Field(description="Certain combinations of actions and other rule elements are inherently ignored if specified together in a rule. If set to `true`, operations which attempt to set these combinations will fail. If set to `false`, such operations will instead be allowed. Defaults to `true`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        policy: Optional['models.ObjectStoreAccessPolicyPatch'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH object-store-access-policies
        
        Modify the rules of an object store access policy.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param enforce_action_restrictions: Certain combinations of actions and other rule elements are inherently ignored
                                            if specified together in a rule. If set to `true`, operations which
                                            attempt to set these combinations will fail. If set to `false`, such
                                            operations will instead be allowed. Defaults to `true`.
        :type enforce_action_restrictions: bool
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param policy:
        :type policy: ObjectStoreAccessPolicyPatch
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            enforce_action_restrictions=enforce_action_restrictions,
            ids=ids,
            names=names,
            policy=policy,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names'], kwargs)
        return self._call_api('PoliciesObjectStoreAccessApi', 'api217_object_store_access_policies_patch_with_http_info', kwargs)

    def post_object_store_access_policies(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        enforce_action_restrictions: Annotated[Optional[StrictBool], Field(description="Certain combinations of actions and other rule elements are inherently ignored if specified together in a rule. If set to `true`, operations which attempt to set these combinations will fail. If set to `false`, such operations will instead be allowed. Defaults to `true`.")] = None,
        policy: Optional['models.ObjectStoreAccessPolicyPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-access-policies
        
        Create a new access policy.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param enforce_action_restrictions: Certain combinations of actions and other rule elements are inherently ignored
                                            if specified together in a rule. If set to `true`, operations which
                                            attempt to set these combinations will fail. If set to `false`, such
                                            operations will instead be allowed. Defaults to `true`.
        :type enforce_action_restrictions: bool
        :param policy:
        :type policy: ObjectStoreAccessPolicyPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            x_request_id=x_request_id,
            context_names=context_names,
            enforce_action_restrictions=enforce_action_restrictions,
            policy=policy,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _fixup_list_type_params(['names', 'context_names'], kwargs)
        return self._call_api('PoliciesObjectStoreAccessApi', 'api217_object_store_access_policies_post_with_http_info', kwargs)

    def delete_object_store_access_policies_rules(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE object-store-access-policies-rules
        
        Delete one or more access policy rules.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            names=names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesObjectStoreAccessApi', 'api217_object_store_access_policies_rules_delete_with_http_info', kwargs)

    def get_object_store_access_policies_rules(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-access-policies-rules
        
        List access policy rules and their attributes.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            names=names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesObjectStoreAccessApi', 'api217_object_store_access_policies_rules_get_with_http_info', kwargs)

    def patch_object_store_access_policies_rules(
        self,
        rule: 'models.PolicyRuleObjectAccessPost',
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        enforce_action_restrictions: Annotated[Optional[StrictBool], Field(description="Certain combinations of actions and other rule elements are inherently ignored if specified together in a rule. If set to `true`, operations which attempt to set these combinations will fail. If set to `false`, such operations will instead be allowed. Defaults to `true`.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH object-store-access-policies-rules
        
        Modify an access policy rule's attributes.
        
        :param rule: (required)
        :type rule: PolicyRuleObjectAccessPost
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param enforce_action_restrictions: Certain combinations of actions and other rule elements are inherently ignored
                                            if specified together in a rule. If set to `true`, operations which
                                            attempt to set these combinations will fail. If set to `false`, such
                                            operations will instead be allowed. Defaults to `true`.
        :type enforce_action_restrictions: bool
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            rule=rule,
            x_request_id=x_request_id,
            context_names=context_names,
            enforce_action_restrictions=enforce_action_restrictions,
            names=names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesObjectStoreAccessApi', 'api217_object_store_access_policies_rules_patch_with_http_info', kwargs)

    def post_object_store_access_policies_rules(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        rule: 'models.PolicyRuleObjectAccessPost',
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        enforce_action_restrictions: Annotated[Optional[StrictBool], Field(description="Certain combinations of actions and other rule elements are inherently ignored if specified together in a rule. If set to `true`, operations which attempt to set these combinations will fail. If set to `false`, such operations will instead be allowed. Defaults to `true`.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST object-store-access-policies-rules
        
        Create a new access policy rule.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param rule: (required)
        :type rule: PolicyRuleObjectAccessPost
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param enforce_action_restrictions: Certain combinations of actions and other rule elements are inherently ignored
                                            if specified together in a rule. If set to `true`, operations which
                                            attempt to set these combinations will fail. If set to `false`, such
                                            operations will instead be allowed. Defaults to `true`.
        :type enforce_action_restrictions: bool
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            rule=rule,
            x_request_id=x_request_id,
            context_names=context_names,
            enforce_action_restrictions=enforce_action_restrictions,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['names', 'context_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesObjectStoreAccessApi', 'api217_object_store_access_policies_rules_post_with_http_info', kwargs)

    def get_object_store_access_policy_actions(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET object-store-access-policy-actions
        
        List valid actions for access policy rules. Each action is either a valid AWS S3 action (prefixed by `s3:`) or our special wildcard action (`s3:*`). Each action, when included in a rule, may restrict which other properties may be set for that rule.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['context_names', 'names', 'sort'], kwargs)
        return self._call_api('PoliciesObjectStoreAccessApi', 'api217_object_store_access_policy_actions_get_with_http_info', kwargs)

    def get_password_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List password policies
        
        Displays a list of password policies.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('PoliciesPasswordApi', 'api217_password_policies_get_with_http_info', kwargs)

    def patch_password_policies(
        self,
        policy: 'models.PasswordPolicy',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify password policies
        
        Modifies one or more password policies. To enable a policy, set `enabled=true`. To disable a policy, set `enabled=false`.
        
        :param policy: (required)
        :type policy: PasswordPolicy
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            policy=policy,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('PoliciesPasswordApi', 'api217_password_policies_patch_with_http_info', kwargs)

    def delete_qos_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE qos-policies
        
        Delete a QoS policy.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('PoliciesQoSApi', 'api217_qos_policies_delete_with_http_info', kwargs)

    def get_qos_policies_file_systems(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET qos-policies/file-systems
        
        List qos policies and their file system members.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesQoSApi', 'api217_qos_policies_file_systems_get_with_http_info', kwargs)

    def get_qos_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET qos-policies
        
        List QoS policies.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('PoliciesQoSApi', 'api217_qos_policies_get_with_http_info', kwargs)

    def get_qos_policies_members(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET qos-policies/members
        
        List qos policies and their managed object members.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesQoSApi', 'api217_qos_policies_members_get_with_http_info', kwargs)

    def patch_qos_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        policy: Optional['models.QosPolicy'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH qos-policies
        
        Modify a QoS policy.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param policy:
        :type policy: QosPolicy
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            policy=policy,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('PoliciesQoSApi', 'api217_qos_policies_patch_with_http_info', kwargs)

    def post_qos_policies(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        policy: 'models.QosPolicy',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST qos-policies
        
        Create a QoS policy.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param policy: (required)
        :type policy: QosPolicy
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            policy=policy,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('PoliciesQoSApi', 'api217_qos_policies_post_with_http_info', kwargs)

    def delete_smb_client_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE smb-client-policies
        
        Delete one or more SMB Client policies.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names'], kwargs)
        return self._call_api('PoliciesSMBClientApi', 'api217_smb_client_policies_delete_with_http_info', kwargs)

    def get_smb_client_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET smb-client-policies
        
        Display SMB Client policies and their attributes.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'sort'], kwargs)
        return self._call_api('PoliciesSMBClientApi', 'api217_smb_client_policies_get_with_http_info', kwargs)

    def patch_smb_client_policies(
        self,
        policy: 'models.SmbClientPolicy',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH smb-client-policies
        
        Modify an existing SMB Client policy's attributes.
        
        :param policy: (required)
        :type policy: SmbClientPolicy
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            policy=policy,
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names'], kwargs)
        return self._call_api('PoliciesSMBClientApi', 'api217_smb_client_policies_patch_with_http_info', kwargs)

    def post_smb_client_policies(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        policy: Optional['models.SmbClientPolicyPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST smb-client-policies
        
        Create a new SMB Client policy.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param policy:
        :type policy: SmbClientPolicyPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            x_request_id=x_request_id,
            context_names=context_names,
            policy=policy,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _fixup_list_type_params(['names', 'context_names'], kwargs)
        return self._call_api('PoliciesSMBClientApi', 'api217_smb_client_policies_post_with_http_info', kwargs)

    def delete_smb_client_policies_rules(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        versions: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of versions. This is an optional query param used for concurrency control. The ordering should match the names or ids query param. This will fail with a 412 Precondition failed if the resource was changed and the current version of the resource doesn't match the value in the query param.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE smb-client-policies/rules
        
        Delete one or more SMB Client policy rules. One of the following is required: `ids` or `names`.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param versions: A comma-separated list of versions. This is an optional query param used for
                        concurrency control. The ordering should match the names or ids query param.
                        This will fail with a 412 Precondition failed if the resource was changed
                        and the current version of the resource doesn't match the value in the query
                        param.
        :type versions: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            versions=versions,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'versions'], kwargs)
        return self._call_api('PoliciesSMBClientApi', 'api217_smb_client_policies_rules_delete_with_http_info', kwargs)

    def get_smb_client_policies_rules(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET smb-client-policies/rules
        
        Displays a list of SMB Client policy rules. The default sort is by policy name, then index.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesSMBClientApi', 'api217_smb_client_policies_rules_get_with_http_info', kwargs)

    def patch_smb_client_policies_rules(
        self,
        rule: 'models.SmbClientPolicyRule',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        before_rule_id: Annotated[Optional[StrictStr], Field(description="The id of the rule to insert or move a rule before. This cannot be provided together with the `before_rule_name` query parameter.")] = None,
        before_rule_name: Annotated[Optional[StrictStr], Field(description="The name of the rule to insert or move a rule before. This cannot be provided together with the `before_rule_id` query parameter.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        versions: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of versions. This is an optional query param used for concurrency control. The ordering should match the names or ids query param. This will fail with a 412 Precondition failed if the resource was changed and the current version of the resource doesn't match the value in the query param.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH smb-client-policies/rules
        
        Modify an existing SMB Client policy rule. If `before_rule_id` or `before_rule_name` are specified, the rule will be moved before that rule. Rules are ordered in three groups; ip addresses, other and `*` and can only be moved within the appropriate group. One of the following is required: `ids` or `names`.
        
        :param rule: (required)
        :type rule: SmbClientPolicyRule
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param before_rule_id: The id of the rule to insert or move a rule before. This cannot be provided
                            together with the `before_rule_name` query parameter.
        :type before_rule_id: str
        :param before_rule_name: The name of the rule to insert or move a rule before. This cannot be provided
                                together with the `before_rule_id` query parameter.
        :type before_rule_name: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param versions: A comma-separated list of versions. This is an optional query param used for
                        concurrency control. The ordering should match the names or ids query param.
                        This will fail with a 412 Precondition failed if the resource was changed
                        and the current version of the resource doesn't match the value in the query
                        param.
        :type versions: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            rule=rule,
            x_request_id=x_request_id,
            before_rule_id=before_rule_id,
            before_rule_name=before_rule_name,
            context_names=context_names,
            ids=ids,
            names=names,
            versions=versions,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'versions'], kwargs)
        return self._call_api('PoliciesSMBClientApi', 'api217_smb_client_policies_rules_patch_with_http_info', kwargs)

    def post_smb_client_policies_rules(
        self,
        rule: 'models.SmbClientPolicyRulePost',
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        before_rule_id: Annotated[Optional[StrictStr], Field(description="The id of the rule to insert or move a rule before. This cannot be provided together with the `before_rule_name` query parameter.")] = None,
        before_rule_name: Annotated[Optional[StrictStr], Field(description="The name of the rule to insert or move a rule before. This cannot be provided together with the `before_rule_id` query parameter.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        versions: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of versions. This is an optional query param used for concurrency control. The ordering should match the names or ids query param. This will fail with a 412 Precondition failed if the resource was changed and the current version of the resource doesn't match the value in the query param.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST smb-client-policies/rules
        
        Add an SMB Client policy rule. Rules are ordered in three groups; ip addresses, other and `*`. The new rule will be added at the end of the appropriate group if neither `before_rule_id` nor `before_rule_name` are specified. Rules can only be inserted into the appropriate group. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.
        
        :param rule: (required)
        :type rule: SmbClientPolicyRulePost
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param before_rule_id: The id of the rule to insert or move a rule before. This cannot be provided
                            together with the `before_rule_name` query parameter.
        :type before_rule_id: str
        :param before_rule_name: The name of the rule to insert or move a rule before. This cannot be provided
                                together with the `before_rule_id` query parameter.
        :type before_rule_name: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param versions: A comma-separated list of versions. This is an optional query param used for
                        concurrency control. The ordering should match the names or ids query param.
                        This will fail with a 412 Precondition failed if the resource was changed
                        and the current version of the resource doesn't match the value in the query
                        param.
        :type versions: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            rule=rule,
            x_request_id=x_request_id,
            before_rule_id=before_rule_id,
            before_rule_name=before_rule_name,
            context_names=context_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            versions=versions,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'policy_ids', 'policy_names', 'versions'], kwargs)
        return self._call_api('PoliciesSMBClientApi', 'api217_smb_client_policies_rules_post_with_http_info', kwargs)

    def delete_smb_share_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE smb-share-policies
        
        Delete one or more SMB Share policies.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names'], kwargs)
        return self._call_api('PoliciesSMBShareApi', 'api217_smb_share_policies_delete_with_http_info', kwargs)

    def get_smb_share_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET smb-share-policies
        
        Display SMB Share policies and their attributes.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'sort'], kwargs)
        return self._call_api('PoliciesSMBShareApi', 'api217_smb_share_policies_get_with_http_info', kwargs)

    def patch_smb_share_policies(
        self,
        policy: 'models.SmbSharePolicy',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH smb-share-policies
        
        Modify an existing SMB Share policy's attributes.
        
        :param policy: (required)
        :type policy: SmbSharePolicy
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            policy=policy,
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names'], kwargs)
        return self._call_api('PoliciesSMBShareApi', 'api217_smb_share_policies_patch_with_http_info', kwargs)

    def post_smb_share_policies(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        policy: Optional['models.SmbSharePolicyPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST smb-share-policies
        
        Create a new SMB Share policy.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param policy:
        :type policy: SmbSharePolicyPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            x_request_id=x_request_id,
            context_names=context_names,
            policy=policy,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _fixup_list_type_params(['names', 'context_names'], kwargs)
        return self._call_api('PoliciesSMBShareApi', 'api217_smb_share_policies_post_with_http_info', kwargs)

    def delete_smb_share_policies_rules(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE smb-share-policies/rules
        
        Delete one or more SMB Share policy rules. One of the following is required: `ids` or `names`. If `names` is provided, the `policy_ids` or `policy_names` parameter is also required.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesSMBShareApi', 'api217_smb_share_policies_rules_delete_with_http_info', kwargs)

    def get_smb_share_policies_rules(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET smb-share-policies/rules
        
        Displays a list of SMB Share policy rules.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesSMBShareApi', 'api217_smb_share_policies_rules_get_with_http_info', kwargs)

    def patch_smb_share_policies_rules(
        self,
        rule: 'models.SmbSharePolicyRule',
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH smb-share-policies/rules
        
        Modify an existing SMB Share policy rule. One of the following is required: `ids` or `names`. If `names` is provided, the `policy_ids` or `policy_names` parameter is also required.
        
        :param rule: (required)
        :type rule: SmbSharePolicyRule
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            rule=rule,
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesSMBShareApi', 'api217_smb_share_policies_rules_patch_with_http_info', kwargs)

    def post_smb_share_policies_rules(
        self,
        rule: 'models.SmbSharePolicyRulePost',
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST smb-share-policies/rules
        
        Add an SMB Share policy rule. The `policy_ids` or `policy_names` parameter is required, but they cannot be set together.
        
        :param rule: (required)
        :type rule: SmbSharePolicyRulePost
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            rule=rule,
            x_request_id=x_request_id,
            context_names=context_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesSMBShareApi', 'api217_smb_share_policies_rules_post_with_http_info', kwargs)

    def delete_admins_ssh_certificate_authority_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE admins/ssh-certificate-authority-policies
        
        Remove a SSH Certificate Authority policy from a specific user.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesSSHCertificateAuthorityApi', 'api217_admins_ssh_certificate_authority_policies_delete_with_http_info', kwargs)

    def get_admins_ssh_certificate_authority_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET admins/ssh-certificate-authority-policies
        
        List SSH Certificate Authority policies mapped to specific users.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesSSHCertificateAuthorityApi', 'api217_admins_ssh_certificate_authority_policies_get_with_http_info', kwargs)

    def post_admins_ssh_certificate_authority_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST admins/ssh-certificate-authority-policies
        
        Map a SSH Certificate Authority policy to a specific user.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesSSHCertificateAuthorityApi', 'api217_admins_ssh_certificate_authority_policies_post_with_http_info', kwargs)

    def delete_arrays_ssh_certificate_authority_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE admins/settings/ssh-certificate-authority-policies
        
        Remove a SSH Certificate Authority policy from being a default for admins.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesSSHCertificateAuthorityApi', 'api217_arrays_ssh_certificate_authority_policies_delete_with_http_info', kwargs)

    def get_arrays_ssh_certificate_authority_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET admins/settings/ssh-certificate-authority-policies
        
        List SSH Certificate Authority policies mapped as defaults for admins.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesSSHCertificateAuthorityApi', 'api217_arrays_ssh_certificate_authority_policies_get_with_http_info', kwargs)

    def post_arrays_ssh_certificate_authority_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST admins/settings/ssh-certificate-authority-policies
        
        Map a SSH Certificate Authority policy as a default for admins.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesSSHCertificateAuthorityApi', 'api217_arrays_ssh_certificate_authority_policies_post_with_http_info', kwargs)

    def delete_ssh_certificate_authority_policies_admins(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE ssh-certificate-authority-policies/admins
        
        Remove a SSH Certificate Authority policy from a specific user.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesSSHCertificateAuthorityApi', 'api217_ssh_certificate_authority_policies_admins_delete_with_http_info', kwargs)

    def get_ssh_certificate_authority_policies_admins(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET ssh-certificate-authority-policies/admins
        
        List SSH Certificate Authority policies mapped to specific users.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesSSHCertificateAuthorityApi', 'api217_ssh_certificate_authority_policies_admins_get_with_http_info', kwargs)

    def post_ssh_certificate_authority_policies_admins(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST ssh-certificate-authority-policies/admins
        
        Map a SSH Certificate Authority policy to a specific user.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesSSHCertificateAuthorityApi', 'api217_ssh_certificate_authority_policies_admins_post_with_http_info', kwargs)

    def delete_ssh_certificate_authority_policies_arrays(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE ssh-certificate-authority-policies/arrays
        
        Remove a SSH Certificate Authority policy from being a default for admins.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesSSHCertificateAuthorityApi', 'api217_ssh_certificate_authority_policies_arrays_delete_with_http_info', kwargs)

    def get_ssh_certificate_authority_policies_arrays(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET ssh-certificate-authority-policies/arrays
        
        List SSH Certificate Authority policies mapped as defaults for admins.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesSSHCertificateAuthorityApi', 'api217_ssh_certificate_authority_policies_arrays_get_with_http_info', kwargs)

    def post_ssh_certificate_authority_policies_arrays(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST ssh-certificate-authority-policies/arrays
        
        Map a SSH Certificate Authority policy as a default for admins.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesSSHCertificateAuthorityApi', 'api217_ssh_certificate_authority_policies_arrays_post_with_http_info', kwargs)

    def delete_ssh_certificate_authority_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete SSH Certificate Authority configurations
        
        Deletes SSH Certificate Authority configurations.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('PoliciesSSHCertificateAuthorityApi', 'api217_ssh_certificate_authority_policies_delete_with_http_info', kwargs)

    def get_ssh_certificate_authority_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List SSH Certificate Authority configurations
        
        List SSH Certificate Authority configurations
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('PoliciesSSHCertificateAuthorityApi', 'api217_ssh_certificate_authority_policies_get_with_http_info', kwargs)

    def get_ssh_certificate_authority_policies_members(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET ssh-certificate-authority-policies/members
        
        List SSH Certificate Authority policies mapped to the admin default settings, or to one or more specific users.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesSSHCertificateAuthorityApi', 'api217_ssh_certificate_authority_policies_members_get_with_http_info', kwargs)

    def patch_ssh_certificate_authority_policies(
        self,
        policy: 'models.SshCertificateAuthorityPolicy',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify SSH Certificate Authority configurations
        
        Modifies one or more attributes of SSH Certificate Authority configurations.
        
        :param policy: (required)
        :type policy: SshCertificateAuthorityPolicy
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            policy=policy,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('PoliciesSSHCertificateAuthorityApi', 'api217_ssh_certificate_authority_policies_patch_with_http_info', kwargs)

    def post_ssh_certificate_authority_policies(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        policy: 'models.SshCertificateAuthorityPolicyPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create SSH Certificate Authority configurations
        
        Creates SSH Certificate Authority configurations.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param policy: (required)
        :type policy: SshCertificateAuthorityPolicyPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            policy=policy,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('PoliciesSSHCertificateAuthorityApi', 'api217_ssh_certificate_authority_policies_post_with_http_info', kwargs)

    def delete_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE policies
        
        Delete one or more snapshot scheduling policies.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names'], kwargs)
        return self._call_api('PoliciesSnapshotApi', 'api217_policies_delete_with_http_info', kwargs)

    def delete_policies_file_system_replica_links(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE policies/file-system-replica-links
        
        Remove a snapshot scheduling policy mapped to a file system replica link.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            member_ids=member_ids,
            policy_ids=policy_ids,
            policy_names=policy_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(members, ['member_ids'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['context_names', 'local_file_system_ids', 'local_file_system_names', 'member_ids', 'policy_ids', 'policy_names', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('PoliciesSnapshotApi', 'api217_policies_file_system_replica_links_delete_with_http_info', kwargs)

    def get_policies_file_system_replica_links(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        remote_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system IDs. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_names` query parameter.")] = None,
        remote_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_ids` query parameter.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET policies/file-system-replica-links
        
        List snapshot scheduling policies for file system replica links. Note: if more than 150,000 items would be returned in the response, an error will be thrown and query parameters must be used to limit the items queried.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param remote_file_systems: A list of remote_file_systems to query for. Overrides remote_file_system_ids and remote_file_system_names keyword arguments.
        :type remote_file_systems: ReferenceType or List[ReferenceType], optional
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_file_system_ids: A comma-separated list of remote file system IDs. If there is not at least one
                                    resource that matches each of the elements, then an error is returned.
                                    This cannot be provided together with the `remote_file_system_names`
                                    query parameter.
        :type remote_file_system_ids: List[str]
        :param remote_file_system_names: A comma-separated list of remote file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with the `remote_file_system_ids` query
                                        parameter.
        :type remote_file_system_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            member_ids=member_ids,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            remote_file_system_ids=remote_file_system_ids,
            remote_file_system_names=remote_file_system_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(members, ['member_ids'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _process_references(remote_file_systems, ['remote_file_system_ids', 'remote_file_system_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['context_names', 'local_file_system_ids', 'local_file_system_names', 'member_ids', 'policy_ids', 'policy_names', 'remote_file_system_ids', 'remote_file_system_names', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('PoliciesSnapshotApi', 'api217_policies_file_system_replica_links_get_with_http_info', kwargs)

    def post_policies_file_system_replica_links(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST policies/file-system-replica-links
        
        Add a snapshot scheduling policy to a file system replica link.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids keyword argument.
        :type members: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            member_ids=member_ids,
            policy_ids=policy_ids,
            policy_names=policy_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(members, ['member_ids'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['context_names', 'local_file_system_ids', 'local_file_system_names', 'member_ids', 'policy_ids', 'policy_names', 'remote_ids', 'remote_names'], kwargs)
        return self._call_api('PoliciesSnapshotApi', 'api217_policies_file_system_replica_links_post_with_http_info', kwargs)

    def delete_policies_file_system_snapshots(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE policies/file-system-snapshots
        
        Remove the snapshot scheduling policy mapped to a file system.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesSnapshotApi', 'api217_policies_file_system_snapshots_delete_with_http_info', kwargs)

    def get_policies_file_system_snapshots(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET policies/file-system-snapshots
        
        List file system snapshots mapped to a snapshot scheduling policy. Note: if more than 150,000 items would be returned in the response, an error will be thrown and query parameters must be used to limit the items queried.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesSnapshotApi', 'api217_policies_file_system_snapshots_get_with_http_info', kwargs)

    def delete_policies_file_systems(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE policies/file-systems
        
        Remove the snapshot scheduling policy mapped to a file system.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesSnapshotApi', 'api217_policies_file_systems_delete_with_http_info', kwargs)

    def get_policies_file_systems(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET policies/file-systems
        
        List file systems mapped to a snapshot scheduling policy. Note: if more than 150,000 items would be returned in the response, an error will be thrown and query parameters must be used to limit the items queried.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesSnapshotApi', 'api217_policies_file_systems_get_with_http_info', kwargs)

    def post_policies_file_systems(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST policies/file-systems
        
        Map a file system to a snapshot scheduling policy.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesSnapshotApi', 'api217_policies_file_systems_post_with_http_info', kwargs)

    def get_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET policies
        
        Display snapshot scheduling policies and their attributes.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'sort'], kwargs)
        return self._call_api('PoliciesSnapshotApi', 'api217_policies_get_with_http_info', kwargs)

    def get_policies_members(
        self,
        remotes: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        remote_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        local_file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        local_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `local_file_system_names` query parameter.")] = None,
        local_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of local file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `local_file_system_ids` query parameter.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        member_types: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member types. Valid values are `file-systems`, `file-system-snapshots`, `file-system-replica-links`, and `object-store-users`. Different endpoints may accept different subsets of these values.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        remote_file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system IDs. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_names` query parameter.")] = None,
        remote_file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote file system names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_file_system_ids` query parameter.")] = None,
        remote_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array IDs. If after filtering, there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with the `remote_names` query parameter.")] = None,
        remote_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of remote array names. If there is not at least one resource that matches each of the elements, then an error is returned. This cannot be provided together with `remote_ids` query parameter.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET policies/members
        
        List snapshot scheduling policies mapped to file systems, snapshots, and file system replica links. Note: if more than 150,000 items would be returned in the response, an error will be thrown and query parameters must be used to limit the items queried.
        
        :param remotes: A list of remotes to query for. Overrides remote_ids and remote_names keyword arguments.
        :type remotes: ReferenceType or List[ReferenceType], optional
        :param remote_file_systems: A list of remote_file_systems to query for. Overrides remote_file_system_ids and remote_file_system_names keyword arguments.
        :type remote_file_systems: ReferenceType or List[ReferenceType], optional
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param local_file_systems: A list of local_file_systems to query for. Overrides local_file_system_ids and local_file_system_names keyword arguments.
        :type local_file_systems: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param local_file_system_ids: A comma-separated list of local file system IDs. If after filtering, there is
                                    not at least one resource that matches each of the elements, then an
                                    error is returned. This cannot be provided together with the
                                    `local_file_system_names` query parameter.
        :type local_file_system_ids: List[str]
        :param local_file_system_names: A comma-separated list of local file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with `local_file_system_ids` query
                                        parameter.
        :type local_file_system_names: List[str]
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param member_types: A comma-separated list of member types. Valid values are `file-systems`, `file-
                            system-snapshots`, `file-system-replica-links`, and `object-store-users`.
                            Different endpoints may accept different subsets of these values.
        :type member_types: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param remote_file_system_ids: A comma-separated list of remote file system IDs. If there is not at least one
                                    resource that matches each of the elements, then an error is returned.
                                    This cannot be provided together with the `remote_file_system_names`
                                    query parameter.
        :type remote_file_system_ids: List[str]
        :param remote_file_system_names: A comma-separated list of remote file system names. If there is not at least one
                                        resource that matches each of the elements, then an error is returned.
                                        This cannot be provided together with the `remote_file_system_ids` query
                                        parameter.
        :type remote_file_system_names: List[str]
        :param remote_ids: A comma-separated list of remote array IDs. If after filtering, there is not at
                        least one resource that matches each of the elements, then an error is
                        returned. This cannot be provided together with the `remote_names` query
                        parameter.
        :type remote_ids: List[str]
        :param remote_names: A comma-separated list of remote array names. If there is not at least one
                            resource that matches each of the elements, then an error is returned. This
                            cannot be provided together with `remote_ids` query parameter.
        :type remote_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            local_file_system_ids=local_file_system_ids,
            local_file_system_names=local_file_system_names,
            member_ids=member_ids,
            member_names=member_names,
            member_types=member_types,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            remote_file_system_ids=remote_file_system_ids,
            remote_file_system_names=remote_file_system_names,
            remote_ids=remote_ids,
            remote_names=remote_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(local_file_systems, ['local_file_system_ids', 'local_file_system_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _process_references(remote_file_systems, ['remote_file_system_ids', 'remote_file_system_names'], kwargs)
        _process_references(remotes, ['remote_ids', 'remote_names'], kwargs)
        _fixup_list_type_params(['context_names', 'local_file_system_ids', 'local_file_system_names', 'member_ids', 'member_names', 'member_types', 'policy_ids', 'policy_names', 'remote_file_system_ids', 'remote_file_system_names', 'remote_ids', 'remote_names', 'sort'], kwargs)
        return self._call_api('PoliciesSnapshotApi', 'api217_policies_members_get_with_http_info', kwargs)

    def patch_policies(
        self,
        policy: 'models.PolicyPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        destroy_snapshots: Annotated[Optional[StrictBool], Field(description="This parameter must be set to `true` in order to modify a policy such that local or remote snapshots would be destroyed.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH policies
        
        Modify a snapshot scheduling policys attributes for when and how often snapshots are created and how long they are retained.
        
        :param policy: (required)
        :type policy: PolicyPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param destroy_snapshots: This parameter must be set to `true` in order to modify a policy such that local
                                or remote snapshots would be destroyed.
        :type destroy_snapshots: bool
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            policy=policy,
            x_request_id=x_request_id,
            context_names=context_names,
            destroy_snapshots=destroy_snapshots,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names'], kwargs)
        return self._call_api('PoliciesSnapshotApi', 'api217_policies_patch_with_http_info', kwargs)

    def post_policies(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        policy: Optional['models.Policy'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST policies
        
        Create a new snapshot scheduling policy with rule attributes to capture file system snapshots for a set period of time and frequency, as well as how long snapshots are retained before being destroyed and eradicated.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param policy:
        :type policy: Policy
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            x_request_id=x_request_id,
            context_names=context_names,
            policy=policy,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _fixup_list_type_params(['names', 'context_names'], kwargs)
        return self._call_api('PoliciesSnapshotApi', 'api217_policies_post_with_http_info', kwargs)

    def delete_network_interfaces_tls_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE network-interfaces/tls-policies
        
        Remove a TLS policy from a network interface.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesTLSApi', 'api217_network_interfaces_tls_policies_delete_with_http_info', kwargs)

    def get_network_interfaces_tls_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET network-interfaces/tls-policies
        
        List network interface TLS policies.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesTLSApi', 'api217_network_interfaces_tls_policies_get_with_http_info', kwargs)

    def post_network_interfaces_tls_policies(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST network-interfaces/tls-policies
        
        Apply a TLS policy to a specific network interface. A given network interface may only have 1 TLS policy applied to it at any given time.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesTLSApi', 'api217_network_interfaces_tls_policies_post_with_http_info', kwargs)

    def delete_tls_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete TLS policies
        
        Deletes TLS policies.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('PoliciesTLSApi', 'api217_tls_policies_delete_with_http_info', kwargs)

    def get_tls_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        effective: Annotated[Optional[StrictBool], Field(description="If `true`, then the TLS policies returned will be fully evaluated. This involves expanding shortened TLS ciphers, removing disabled TLS ciphers from the list of expanded enabled TLS ciphers, and converting values such as `default` and `legacy` into concrete values, in order to return the discrete effective TLS settings that the policies encode. Defaults to `false`.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        purity_defined: Annotated[Optional[StrictBool], Field(description="If `true`, then the results returned will be include the specification for purity-defined values on the current purity version. These values may be used in configurations in order to dynamically adopt new behavior across upgrades, and this option allows the exact behavior for the current version to be returned. Defaults to `false`.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List TLS policies
        
        List TLS policies
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param effective: If `true`, then the TLS policies returned will be fully evaluated. This involves
                        expanding shortened TLS ciphers, removing disabled TLS ciphers from the list
                        of expanded enabled TLS ciphers, and converting values such as `default` and
                        `legacy` into concrete values, in order to return the discrete effective TLS
                        settings that the policies encode. Defaults to `false`.
        :type effective: bool
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param purity_defined: If `true`, then the results returned will be include the specification for
                            purity-defined values on the current purity version. These values may be
                            used in configurations in order to dynamically adopt new behavior across
                            upgrades, and this option allows the exact behavior for the current version
                            to be returned. Defaults to `false`.
        :type purity_defined: bool
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            effective=effective,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            purity_defined=purity_defined,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('PoliciesTLSApi', 'api217_tls_policies_get_with_http_info', kwargs)

    def get_tls_policies_members(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET tls-policies/members
        
        List TLS policies mapped to the array as a whole, or to one or more specific objects on the array (such as network interfaces).
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesTLSApi', 'api217_tls_policies_members_get_with_http_info', kwargs)

    def delete_tls_policies_network_interfaces(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE tls-policies/network-interfaces
        
        Remove a TLS policy from a network interface.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesTLSApi', 'api217_tls_policies_network_interfaces_delete_with_http_info', kwargs)

    def get_tls_policies_network_interfaces(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET tls-policies/network-interfaces
        
        List network interface TLS policies.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesTLSApi', 'api217_tls_policies_network_interfaces_get_with_http_info', kwargs)

    def post_tls_policies_network_interfaces(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST tls-policies/network-interfaces
        
        Apply a TLS policy to a specific network interface. A given network interface may only have 1 TLS policy applied to it at any given time.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            member_ids=member_ids,
            member_names=member_names,
            policy_ids=policy_ids,
            policy_names=policy_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['member_ids', 'member_names', 'policy_ids', 'policy_names'], kwargs)
        return self._call_api('PoliciesTLSApi', 'api217_tls_policies_network_interfaces_post_with_http_info', kwargs)

    def patch_tls_policies(
        self,
        policy: 'models.TlsPolicy',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify TLS policies
        
        Modifies one or more attributes of TLS policies.
        
        :param policy: (required)
        :type policy: TlsPolicy
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            policy=policy,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('PoliciesTLSApi', 'api217_tls_policies_patch_with_http_info', kwargs)

    def post_tls_policies(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        policy: 'models.TlsPolicyPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create TLS policies
        
        Creates TLS policies.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param policy: (required)
        :type policy: TlsPolicyPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            policy=policy,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('PoliciesTLSApi', 'api217_tls_policies_post_with_http_info', kwargs)

    def delete_worm_data_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE worm-data-policies
        
        Delete a WORM data policy. Deletion is not allowed if the policy is attached to one or more file systems.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names'], kwargs)
        return self._call_api('PoliciesWORMDataApi', 'api217_worm_data_policies_delete_with_http_info', kwargs)

    def get_worm_data_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET worm-data-policies
        
        List WORM data policies.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'sort'], kwargs)
        return self._call_api('PoliciesWORMDataApi', 'api217_worm_data_policies_get_with_http_info', kwargs)

    def get_worm_data_policies_members(
        self,
        policies: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        members: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        member_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member IDs. If after filtering, there is not at least one resource that matches each of the elements of `member_ids`, then an error is returned. This cannot be provided together with the `member_names` query parameter.")] = None,
        member_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of member names.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        policy_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy IDs. If after filtering, there is not at least one resource that matches each of the elements of `policy_ids`, then an error is returned. This cannot be provided together with the `policy_names` query parameter.")] = None,
        policy_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of policy names.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET worm-data-policies/members
        
        List members mapped to a WORM data policy.
        
        :param policies: A list of policies to query for. Overrides policy_ids and policy_names keyword arguments.
        :type policies: ReferenceType or List[ReferenceType], optional
        :param members: A list of members to query for. Overrides member_ids and member_names keyword arguments.
        :type members: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param member_ids: A comma-separated list of member IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `member_ids`, then an
                        error is returned. This cannot be provided together with the `member_names`
                        query parameter.
        :type member_ids: List[str]
        :param member_names: A comma-separated list of member names.
        :type member_names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param policy_ids: A comma-separated list of policy IDs. If after filtering, there is not at least
                        one resource that matches each of the elements of `policy_ids`, then an
                        error is returned. This cannot be provided together with the `policy_names`
                        query parameter.
        :type policy_ids: List[str]
        :param policy_names: A comma-separated list of policy names.
        :type policy_names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            member_ids=member_ids,
            member_names=member_names,
            offset=offset,
            policy_ids=policy_ids,
            policy_names=policy_names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(members, ['member_ids', 'member_names'], kwargs)
        _process_references(policies, ['policy_ids', 'policy_names'], kwargs)
        _fixup_list_type_params(['context_names', 'member_ids', 'member_names', 'policy_ids', 'policy_names', 'sort'], kwargs)
        return self._call_api('PoliciesWORMDataApi', 'api217_worm_data_policies_members_get_with_http_info', kwargs)

    def patch_worm_data_policies(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        policy: Optional['models.WormDataPolicy'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH worm-data-policies
        
        Modify a WORM data policy.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param policy:
        :type policy: WormDataPolicy
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            ids=ids,
            names=names,
            policy=policy,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names'], kwargs)
        return self._call_api('PoliciesWORMDataApi', 'api217_worm_data_policies_patch_with_http_info', kwargs)

    def post_worm_data_policies(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        policy: Optional['models.WormDataPolicy'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST worm-data-policies
        
        Create a WORM data policy.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param policy:
        :type policy: WormDataPolicy
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            x_request_id=x_request_id,
            context_names=context_names,
            policy=policy,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _process_references(contexts, ['context_names'], kwargs)
        _fixup_list_type_params(['names', 'context_names'], kwargs)
        return self._call_api('PoliciesWORMDataApi', 'api217_worm_data_policies_post_with_http_info', kwargs)

    def delete_public_keys(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete public key configurations
        
        Deletes public key configurations.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('PublicKeysApi', 'api217_public_keys_delete_with_http_info', kwargs)

    def get_public_keys(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List public key configurations
        
        List public key configurations.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('PublicKeysApi', 'api217_public_keys_get_with_http_info', kwargs)

    def post_public_keys(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        public_key: 'models.PublicKeyPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create public key configurations
        
        Creates public key configurations.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param public_key: (required)
        :type public_key: PublicKeyPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            public_key=public_key,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('PublicKeysApi', 'api217_public_keys_post_with_http_info', kwargs)

    def get_public_keys_uses(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET public-keys/uses
        
        List how public keys are being used and by what.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('PublicKeysApi', 'api217_public_keys_uses_get_with_http_info', kwargs)

    def delete_quotas_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        gids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of group IDs. If there is not at least one resource that matches each of the elements of `gids`, then an error is returned. This cannot be provided together with `group_names` query parameter.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group names. If there is not at least one resource that matches each of the elements of `group_names`, then an error is returned. This cannot be provided together with `gids` query parameter.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE quotas/groups
        
        Delete a hard limit quota for a group.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param gids: A comma-separated list of group IDs. If there is not at least one resource that
                    matches each of the elements of `gids`, then an error is returned. This
                    cannot be provided together with `group_names` query parameter.
        :type gids: List[int]
        :param group_names: A comma-separated list of group names. If there is not at least one resource
                            that matches each of the elements of `group_names`, then an error is
                            returned. This cannot be provided together with `gids` query parameter.
        :type group_names: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            gids=gids,
            group_names=group_names,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(groups, ['group_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['context_names', 'file_system_ids', 'file_system_names', 'gids', 'group_names', 'names'], kwargs)
        return self._call_api('QuotasApi', 'api217_quotas_groups_delete_with_http_info', kwargs)

    def get_quotas_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        gids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of group IDs. If there is not at least one resource that matches each of the elements of `gids`, then an error is returned. This cannot be provided together with `group_names` query parameter.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group names. If there is not at least one resource that matches each of the elements of `group_names`, then an error is returned. This cannot be provided together with `gids` query parameter.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET quotas/groups
        
        List groups with hard limit quotas.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param gids: A comma-separated list of group IDs. If there is not at least one resource that
                    matches each of the elements of `gids`, then an error is returned. This
                    cannot be provided together with `group_names` query parameter.
        :type gids: List[int]
        :param group_names: A comma-separated list of group names. If there is not at least one resource
                            that matches each of the elements of `group_names`, then an error is
                            returned. This cannot be provided together with `gids` query parameter.
        :type group_names: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            gids=gids,
            group_names=group_names,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(groups, ['group_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['context_names', 'file_system_ids', 'file_system_names', 'gids', 'group_names', 'names', 'sort'], kwargs)
        return self._call_api('QuotasApi', 'api217_quotas_groups_get_with_http_info', kwargs)

    def patch_quotas_groups(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        gids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of group IDs. If there is not at least one resource that matches each of the elements of `gids`, then an error is returned. This cannot be provided together with `group_names` query parameter.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group names. If there is not at least one resource that matches each of the elements of `group_names`, then an error is returned. This cannot be provided together with `gids` query parameter.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        quota: Optional['models.GroupQuotaPatch'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH quotas/groups
        
        Modify a quota for a group. Note that if you modify a group's quota to a lower value and that group's usage has already exceeded the new value, writes will automatically halt until usage decreases below the new quota setting.
        
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param gids: A comma-separated list of group IDs. If there is not at least one resource that
                    matches each of the elements of `gids`, then an error is returned. This
                    cannot be provided together with `group_names` query parameter.
        :type gids: List[int]
        :param group_names: A comma-separated list of group names. If there is not at least one resource
                            that matches each of the elements of `group_names`, then an error is
                            returned. This cannot be provided together with `gids` query parameter.
        :type group_names: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param quota:
        :type quota: GroupQuotaPatch
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            gids=gids,
            group_names=group_names,
            names=names,
            quota=quota,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(groups, ['group_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['context_names', 'file_system_ids', 'file_system_names', 'gids', 'group_names', 'names'], kwargs)
        return self._call_api('QuotasApi', 'api217_quotas_groups_patch_with_http_info', kwargs)

    def post_quotas_groups(
        self,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        gids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of group IDs. If there is not at least one resource that matches each of the elements of `gids`, then an error is returned. This cannot be provided together with `group_names` query parameter.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group names. If there is not at least one resource that matches each of the elements of `group_names`, then an error is returned. This cannot be provided together with `gids` query parameter.")] = None,
        quota: Optional['models.GroupQuotaPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST quotas/groups
        
        Create a hard limit quota for a group.
        
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param gids: A comma-separated list of group IDs. If there is not at least one resource that
                    matches each of the elements of `gids`, then an error is returned. This
                    cannot be provided together with `group_names` query parameter.
        :type gids: List[int]
        :param group_names: A comma-separated list of group names. If there is not at least one resource
                            that matches each of the elements of `group_names`, then an error is
                            returned. This cannot be provided together with `gids` query parameter.
        :type group_names: List[str]
        :param quota:
        :type quota: GroupQuotaPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            gids=gids,
            group_names=group_names,
            quota=quota,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(groups, ['group_names'], kwargs)
        _fixup_list_type_params(['context_names', 'file_system_ids', 'file_system_names', 'gids', 'group_names'], kwargs)
        return self._call_api('QuotasApi', 'api217_quotas_groups_post_with_http_info', kwargs)

    def get_quotas_settings(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET quotas-settings
        
        List notification attributes of a group or user quota.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('QuotasApi', 'api217_quotas_settings_get_with_http_info', kwargs)

    def patch_quotas_settings(
        self,
        quota_setting: 'models.QuotaSetting',
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH quotas-settings
        
        Modify the notification attributes of a group or user quota.
        
        :param quota_setting: (required)
        :type quota_setting: QuotaSetting
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            quota_setting=quota_setting,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('QuotasApi', 'api217_quotas_settings_patch_with_http_info', kwargs)

    def delete_quotas_users(
        self,
        users: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        uids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of user IDs. If there is not at least one resource that matches each of the elements of `uids`, then an error is returned. This cannot be provided together with `user_names` query parameter.")] = None,
        user_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of user names. If there is not at least one resource that matches each of the elements of `user_names`, then an error is returned. This cannot be provided together with `uids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE quotas/users
        
        Delete a hard limit file system quota for a user.
        
        :param users: A list of users to query for. Overrides user_names keyword argument.
        :type users: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param uids: A comma-separated list of user IDs. If there is not at least one resource that
                    matches each of the elements of `uids`, then an error is returned. This
                    cannot be provided together with `user_names` query parameter.
        :type uids: List[int]
        :param user_names: A comma-separated list of user names. If there is not at least one resource that
                        matches each of the elements of `user_names`, then an error is returned.
                        This cannot be provided together with `uids` query parameter.
        :type user_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            names=names,
            uids=uids,
            user_names=user_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _process_references(users, ['user_names'], kwargs)
        _fixup_list_type_params(['context_names', 'file_system_ids', 'file_system_names', 'names', 'uids', 'user_names'], kwargs)
        return self._call_api('QuotasApi', 'api217_quotas_users_delete_with_http_info', kwargs)

    def get_quotas_users(
        self,
        users: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        uids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of user IDs. If there is not at least one resource that matches each of the elements of `uids`, then an error is returned. This cannot be provided together with `user_names` query parameter.")] = None,
        user_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of user names. If there is not at least one resource that matches each of the elements of `user_names`, then an error is returned. This cannot be provided together with `uids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET quotas/users
        
        List users with hard limit file system quotas.
        
        :param users: A list of users to query for. Overrides user_names keyword argument.
        :type users: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param uids: A comma-separated list of user IDs. If there is not at least one resource that
                    matches each of the elements of `uids`, then an error is returned. This
                    cannot be provided together with `user_names` query parameter.
        :type uids: List[int]
        :param user_names: A comma-separated list of user names. If there is not at least one resource that
                        matches each of the elements of `user_names`, then an error is returned.
                        This cannot be provided together with `uids` query parameter.
        :type user_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            uids=uids,
            user_names=user_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _process_references(users, ['user_names'], kwargs)
        _fixup_list_type_params(['context_names', 'file_system_ids', 'file_system_names', 'names', 'sort', 'uids', 'user_names'], kwargs)
        return self._call_api('QuotasApi', 'api217_quotas_users_get_with_http_info', kwargs)

    def patch_quotas_users(
        self,
        users: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        uids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of user IDs. If there is not at least one resource that matches each of the elements of `uids`, then an error is returned. This cannot be provided together with `user_names` query parameter.")] = None,
        user_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of user names. If there is not at least one resource that matches each of the elements of `user_names`, then an error is returned. This cannot be provided together with `uids` query parameter.")] = None,
        quota: Optional['models.UserQuotaPatch'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH quotas/users
        
        Modify the attributes of a hard limit file system quota. Note that if you modify a user's quota to a lower value and that users usage has already exceeded the new value, writes will automatically halt until usage decreases below the new quota setting.
        
        :param users: A list of users to query for. Overrides user_names keyword argument.
        :type users: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param uids: A comma-separated list of user IDs. If there is not at least one resource that
                    matches each of the elements of `uids`, then an error is returned. This
                    cannot be provided together with `user_names` query parameter.
        :type uids: List[int]
        :param user_names: A comma-separated list of user names. If there is not at least one resource that
                        matches each of the elements of `user_names`, then an error is returned.
                        This cannot be provided together with `uids` query parameter.
        :type user_names: List[str]
        :param quota:
        :type quota: UserQuotaPatch
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            names=names,
            uids=uids,
            user_names=user_names,
            quota=quota,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(references, ['names'], kwargs)
        _process_references(users, ['user_names'], kwargs)
        _fixup_list_type_params(['context_names', 'file_system_ids', 'file_system_names', 'names', 'uids', 'user_names'], kwargs)
        return self._call_api('QuotasApi', 'api217_quotas_users_patch_with_http_info', kwargs)

    def post_quotas_users(
        self,
        users: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the context specified. If specified, the context names must be an array of size 1, and the single element must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        uids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of user IDs. If there is not at least one resource that matches each of the elements of `uids`, then an error is returned. This cannot be provided together with `user_names` query parameter.")] = None,
        user_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of user names. If there is not at least one resource that matches each of the elements of `user_names`, then an error is returned. This cannot be provided together with `uids` query parameter.")] = None,
        quota: Optional['models.UserQuotaPost'] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST quotas/users
        
        Create a hard limit file system quota for a user.
        
        :param users: A list of users to query for. Overrides user_names keyword argument.
        :type users: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param context_names: Performs the operation on the context specified. If specified, the context names
                            must be an array of size 1, and the single element must be the name of an
                            array in the same fleet. If not specified, the context will default to the
                            array that received this request. Other parameters provided with the
                            request, such as names of volumes or snapshots, are resolved relative to
                            the provided `context`.
        :type context_names: List[str]
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param uids: A comma-separated list of user IDs. If there is not at least one resource that
                    matches each of the elements of `uids`, then an error is returned. This
                    cannot be provided together with `user_names` query parameter.
        :type uids: List[int]
        :param user_names: A comma-separated list of user names. If there is not at least one resource that
                        matches each of the elements of `user_names`, then an error is returned.
                        This cannot be provided together with `uids` query parameter.
        :type user_names: List[str]
        :param quota:
        :type quota: UserQuotaPost
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            context_names=context_names,
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            uids=uids,
            user_names=user_names,
            quota=quota,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(users, ['user_names'], kwargs)
        _fixup_list_type_params(['context_names', 'file_system_ids', 'file_system_names', 'uids', 'user_names'], kwargs)
        return self._call_api('QuotasApi', 'api217_quotas_users_post_with_http_info', kwargs)

    def get_rapid_data_locking(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Get the status of the Rapid Data Locking feature.
        
        Displays the status of the Rapid Data Locking feature.
        
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('RDLApi', 'api217_rapid_data_locking_get_with_http_info', kwargs)

    def patch_rapid_data_locking(
        self,
        rapid_data_locking: 'models.RapidDataLocking',
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modifies the Rapid Data Locking feature.
        
        Modifies the Rapid Data Locking feature. Note that the feature can only be enabled if there are no file systems nor buckets created on the array. Once enabled, the feature cannot be modified.
        
        :param rapid_data_locking: (required)
        :type rapid_data_locking: RapidDataLocking
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            rapid_data_locking=rapid_data_locking,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('RDLApi', 'api217_rapid_data_locking_patch_with_http_info', kwargs)

    def post_rapid_data_locking_rotate(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Rotates the external keys on the associated EKM appliance.
        
        Rotates the external keys on the associated EKM appliance.
        
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('RDLApi', 'api217_rapid_data_locking_rotate_post_with_http_info', kwargs)

    def get_rapid_data_locking_test(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Displays Rapid Data Locking test results.
        
        Displays a detailed result of a Rapid Data Locking test.
        
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('RDLApi', 'api217_rapid_data_locking_test_get_with_http_info', kwargs)

    def get_remote_arrays(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        current_fleet_only: Annotated[Optional[StrictBool], Field(description="If current_fleet_only is specified, then results will only show arrays from the same fleet to which the current array is a member of.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List remote arrays
        
        Lists arrays in the current fleet, as well as arrays that the current array has existing replication connections to.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param current_fleet_only: If current_fleet_only is specified, then results will only show arrays from the
                                same fleet to which the current array is a member of.
        :type current_fleet_only: bool
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            current_fleet_only=current_fleet_only,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('RemoteArraysApi', 'api217_remote_arrays_get_with_http_info', kwargs)

    def get_roles(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET roles
        
        List roles and permission attributes for role-based access control (RBAC).
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('RolesApi', 'api217_roles_get_with_http_info', kwargs)

    def delete_sso_saml2_idps(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Delete SAML2 SSO configurations
        
        Deletes SAML2 SSO configurations.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SAML2SSOApi', 'api217_sso_saml2_idps_delete_with_http_info', kwargs)

    def get_sso_saml2_idps(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List SAML2 SSO configurations
        
        Displays the SAML2 SSO service provider and identity provider configuration settings in the array.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SAML2SSOApi', 'api217_sso_saml2_idps_get_with_http_info', kwargs)

    def patch_sso_saml2_idps(
        self,
        idp: 'models.Saml2Sso',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Modify SAML2 SSO configurations
        
        Modifies one or more attributes of SAML2 SSO configurations.
        
        :param idp: (required)
        :type idp: Saml2Sso
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            idp=idp,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SAML2SSOApi', 'api217_sso_saml2_idps_patch_with_http_info', kwargs)

    def post_sso_saml2_idps(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        idp: 'models.Saml2SsoPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create SAML2 SSO configurations
        
        Creates SAML2 SSO configurations.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param idp: (required)
        :type idp: Saml2SsoPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            idp=idp,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('SAML2SSOApi', 'api217_sso_saml2_idps_post_with_http_info', kwargs)

    def get_sso_saml2_idps_test(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET sso/saml2/idps/test
        
        Test the existing SAML2 SSO configurations in the array.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SAML2SSOApi', 'api217_sso_saml2_idps_test_get_with_http_info', kwargs)

    def patch_sso_saml2_idps_test(
        self,
        idp: 'models.Saml2Sso',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH sso/saml2/idps/test
        
        Modifies and test the provided SAML2 SSO configurations. If the configurations with the specified `ids` or `names` exist, the provided configurations will overwrite the existing configurations, but will not be persisted in the array.
        
        :param idp: (required)
        :type idp: Saml2Sso
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            idp=idp,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SAML2SSOApi', 'api217_sso_saml2_idps_test_patch_with_http_info', kwargs)

    def get_smtp_servers(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET smtp-servers
        
        List SMTP server attributes for the array network.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SMTPApi', 'api217_smtp_servers_get_with_http_info', kwargs)

    def patch_smtp_servers(
        self,
        smtp: 'models.SmtpServer',
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH smtp-servers
        
        Modify SMTP server attributes such as the relay host and sender domain.
        
        :param smtp: (required)
        :type smtp: SmtpServer
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            smtp=smtp,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('SMTPApi', 'api217_smtp_servers_patch_with_http_info', kwargs)

    def get_snmp_agents(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET snmp-agents
        
        List SNMP agent attributes.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SNMPAgentsApi', 'api217_snmp_agents_get_with_http_info', kwargs)

    def get_snmp_agents_mib(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET snmp-agents-mib
        
        List the SNMP MIB text.
        
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('SNMPAgentsApi', 'api217_snmp_agents_mib_get_with_http_info', kwargs)

    def patch_snmp_agents(
        self,
        snmp_agent: 'models.SnmpAgent',
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH snmp-agents
        
        Modify SNMP agent attributes.
        
        :param snmp_agent: (required)
        :type snmp_agent: SnmpAgent
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            snmp_agent=snmp_agent,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('SNMPAgentsApi', 'api217_snmp_agents_patch_with_http_info', kwargs)

    def delete_snmp_managers(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE snmp-managers
        
        Remove an SNMP manager.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SNMPManagersApi', 'api217_snmp_managers_delete_with_http_info', kwargs)

    def get_snmp_managers(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET snmp-managers
        
        List SNMP managers and their attributes.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SNMPManagersApi', 'api217_snmp_managers_get_with_http_info', kwargs)

    def patch_snmp_managers(
        self,
        snmp_manager: 'models.SnmpManager',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH snmp-managers
        
        Modify SNMP manager attributes such as versions.
        
        :param snmp_manager: (required)
        :type snmp_manager: SnmpManager
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            snmp_manager=snmp_manager,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SNMPManagersApi', 'api217_snmp_managers_patch_with_http_info', kwargs)

    def post_snmp_managers(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        snmp_manager: 'models.SnmpManagerPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST snmp-managers
        
        Create an SNMP manager.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param snmp_manager: (required)
        :type snmp_manager: SnmpManagerPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            snmp_manager=snmp_manager,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('SNMPManagersApi', 'api217_snmp_managers_post_with_http_info', kwargs)

    def get_snmp_managers_test(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET snmp-managers/test
        
        Test if the configuration of an SNMP manager is valid.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SNMPManagersApi', 'api217_snmp_managers_test_get_with_http_info', kwargs)

    def delete_servers(
        self,
        cascade_delete: Annotated[conlist(StrictStr), Field(..., description="The resource types to delete when deleting this object. It will fail if the resources are referenced by other objects. Valid values include `directory-services`.")],
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE servers
        
        Delete a server.
        
        :param cascade_delete: The resource types to delete when deleting this object. It will fail if the
                            resources are referenced by other objects. Valid values include `directory-
                            services`. (required)
        :type cascade_delete: List[str]
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            cascade_delete=cascade_delete,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['cascade_delete', 'ids', 'names'], kwargs)
        return self._call_api('ServersApi', 'api217_servers_delete_with_http_info', kwargs)

    def get_servers(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET servers
        
        List servers.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'sort'], kwargs)
        return self._call_api('ServersApi', 'api217_servers_get_with_http_info', kwargs)

    def patch_servers(
        self,
        server: 'models.ServerPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH servers
        
        Modify the server attributes.
        
        :param server: (required)
        :type server: ServerPost
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            server=server,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('ServersApi', 'api217_servers_patch_with_http_info', kwargs)

    def post_servers(
        self,
        create_ds: Annotated[StrictStr, Field(..., description="The name of the directory service object to create used for NFS access to this server. The name must be the server `name` followed by _nfs.")],
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        server: 'models.ServerPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST servers
        
        Add a server.
        
        :param create_ds: The name of the directory service object to create used for NFS access to this
                        server. The name must be the server `name` followed by _nfs. (required)
        :type create_ds: str
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param server: (required)
        :type server: ServerPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            create_ds=create_ds,
            names=names,
            server=server,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('ServersApi', 'api217_servers_post_with_http_info', kwargs)

    def get_sessions(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List session data
        
        Displays session data for user login events performed in the Purity//FB GUI, CLI, and REST API.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SessionsApi', 'api217_sessions_get_with_http_info', kwargs)

    def get_software_check(
        self,
        softwares: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        software_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of software names.")] = None,
        software_versions: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of target software versions.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        total_item_count: Annotated[Optional[StrictBool], Field(description="If set to `true`, the `total_item_count` matching the specified query parameters is calculated and returned in the response. If set to `false`, the `total_item_count` is `null` in the response. This may speed up queries where the `total_item_count` is large. If not specified, defaults to `false`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """List software check tasks
        
        Displays a list of software check tasks.
        
        :param softwares: A list of softwares to query for. Overrides software_names keyword argument.
        :type softwares: ReferenceType or List[ReferenceType], optional
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param software_names: A comma-separated list of software names.
        :type software_names: List[str]
        :param software_versions: A comma-separated list of target software versions.
        :type software_versions: List[str]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param total_item_count: If set to `true`, the `total_item_count` matching the specified query parameters
                                is calculated and returned in the response. If set to `false`, the
                                `total_item_count` is `null` in the response. This may speed up queries
                                where the `total_item_count` is large. If not specified, defaults to
                                `false`.
        :type total_item_count: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            software_names=software_names,
            software_versions=software_versions,
            sort=sort,
            total_item_count=total_item_count,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _process_references(softwares, ['software_names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'software_names', 'software_versions', 'sort'], kwargs)
        return self._call_api('SoftwareApi', 'api217_software_check_get_with_http_info', kwargs)

    def post_software_check(
        self,
        softwares: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        software_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of software names.")] = None,
        software_versions: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of target software versions.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Create a software check task
        
        Creates a software check task. To create a task, use a software name and version. If a task is already running, an error is returned.
        
        :param softwares: A list of softwares to query for. Overrides software_names keyword argument.
        :type softwares: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param software_names: A comma-separated list of software names.
        :type software_names: List[str]
        :param software_versions: A comma-separated list of target software versions.
        :type software_versions: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            software_names=software_names,
            software_versions=software_versions,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(softwares, ['software_names'], kwargs)
        _fixup_list_type_params(['software_names', 'software_versions'], kwargs)
        return self._call_api('SoftwareApi', 'api217_software_check_post_with_http_info', kwargs)

    def delete_subnets(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE subnets
        
        Remove an array subnet.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SubnetsApi', 'api217_subnets_delete_with_http_info', kwargs)

    def get_subnets(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET subnets
        
        List the arrays subnets.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SubnetsApi', 'api217_subnets_get_with_http_info', kwargs)

    def patch_subnets(
        self,
        subnet: 'models.Subnet',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH subnets
        
        Modify array subnet attributes.
        
        :param subnet: (required)
        :type subnet: Subnet
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            subnet=subnet,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SubnetsApi', 'api217_subnets_patch_with_http_info', kwargs)

    def post_subnets(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        subnet: 'models.Subnet',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST subnets
        
        Create an array subnet.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param subnet: (required)
        :type subnet: Subnet
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            subnet=subnet,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('SubnetsApi', 'api217_subnets_post_with_http_info', kwargs)

    def get_support(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET support
        
        List Phone Home and Remote Assistance settings.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SupportApi', 'api217_support_get_with_http_info', kwargs)

    def patch_support(
        self,
        support: 'models.Support',
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH support
        
        Modify Phone Home and Remote Assistance settings.
        
        :param support: (required)
        :type support: Support
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            support=support,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('SupportApi', 'api217_support_patch_with_http_info', kwargs)

    def get_support_test(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        test_type: Annotated[Optional[StrictStr], Field(description="Specify the type of test. Valid values are `all`, `phonehome` and `remote-assist`. If not specified, defaults to `all`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET support-test
        
        Test if the Phone Home and Remote Assistance settings are functioning properly.
        
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param test_type: Specify the type of test. Valid values are `all`, `phonehome` and `remote-
                        assist`. If not specified, defaults to `all`.
        :type test_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            sort=sort,
            test_type=test_type,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('SupportApi', 'api217_support_test_get_with_http_info', kwargs)

    def get_support_diagnostics_details(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET diagnostics details
        
        Lists the diagnostics tasks details.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SupportDiagnosticsApi', 'api217_support_diagnostics_details_get_with_http_info', kwargs)

    def get_support_diagnostics(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET diagnostics list
        
        Lists the support diagnostics tasks.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SupportDiagnosticsApi', 'api217_support_diagnostics_get_with_http_info', kwargs)

    def post_support_diagnostics(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        analysis_period_end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the analysis time window ends (in milliseconds since epoch).")] = None,
        analysis_period_start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the analysis time window starts (in milliseconds since epoch).")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """Start a diagnostic task
        
        Creates a diagnostics task for a given time interval. If `start_time` is not provided, defaults to Current System Time - 1 hour. If `end_time` is not provided, defaults to Current System Time. If a task is already running, an error is returned.
        
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param analysis_period_end_time: When the analysis time window ends (in milliseconds since epoch).
        :type analysis_period_end_time: int
        :param analysis_period_start_time: When the analysis time window starts (in milliseconds since epoch).
        :type analysis_period_start_time: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            analysis_period_end_time=analysis_period_end_time,
            analysis_period_start_time=analysis_period_start_time,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('SupportDiagnosticsApi', 'api217_support_diagnostics_post_with_http_info', kwargs)

    def delete_syslog_servers(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE syslog-servers
        
        Delete a configured syslog server and stop forwarding syslog messages.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SyslogApi', 'api217_syslog_servers_delete_with_http_info', kwargs)

    def get_syslog_servers(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET syslog-servers
        
        Return a list of configured syslog servers.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'sort'], kwargs)
        return self._call_api('SyslogApi', 'api217_syslog_servers_get_with_http_info', kwargs)

    def patch_syslog_servers(
        self,
        syslog_server: 'models.SyslogServerPatch',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH syslog-servers
        
        Modify the URI or services of a configured syslog server.
        
        :param syslog_server: (required)
        :type syslog_server: SyslogServerPatch
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            syslog_server=syslog_server,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SyslogApi', 'api217_syslog_servers_patch_with_http_info', kwargs)

    def post_syslog_servers(
        self,
        syslog_server: 'models.SyslogServerPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique name specified. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST syslog-servers
        
        Configure a new syslog server.
        
        :param syslog_server: (required)
        :type syslog_server: SyslogServerPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param names: Performs the operation on the unique name specified. Enter multiple names in
                    comma-separated format. For example, `name01,name02`.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            syslog_server=syslog_server,
            x_request_id=x_request_id,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('SyslogApi', 'api217_syslog_servers_post_with_http_info', kwargs)

    def get_syslog_servers_settings(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET syslog-servers/settings
        
        List the certificate or certificate group associated with the syslog servers.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('SyslogApi', 'api217_syslog_servers_settings_get_with_http_info', kwargs)

    def patch_syslog_servers_settings(
        self,
        syslog_server_settings: 'models.SyslogServerSettings',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH syslog-servers/settings
        
        Modify the certificate or certificate group associated with the syslog servers.
        
        :param syslog_server_settings: (required)
        :type syslog_server_settings: SyslogServerSettings
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            syslog_server_settings=syslog_server_settings,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('SyslogApi', 'api217_syslog_servers_settings_patch_with_http_info', kwargs)

    def get_syslog_servers_test(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET syslog-servers/test
        
        Send test messages to conifgured remote syslog servers.
        
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('SyslogApi', 'api217_syslog_servers_test_get_with_http_info', kwargs)

    def delete_targets(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """DELETE targets
        
        Delete the connection to the target for replication.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('TargetsApi', 'api217_targets_delete_with_http_info', kwargs)

    def get_targets(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET targets
        
        List targets used for replication.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['context_names', 'ids', 'names', 'sort'], kwargs)
        return self._call_api('TargetsApi', 'api217_targets_get_with_http_info', kwargs)

    def patch_targets(
        self,
        target: 'models.Target',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH targets
        
        Modify the target attributes for replication.
        
        :param target: (required)
        :type target: Target
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            target=target,
            x_request_id=x_request_id,
            ids=ids,
            names=names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names'], kwargs)
        return self._call_api('TargetsApi', 'api217_targets_patch_with_http_info', kwargs)

    def get_targets_performance_replication(
        self,
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        end_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window ends (in milliseconds since epoch).")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource IDs. If after filtering, there is not at least one resource that matches each of the elements of `ids`, then an error is returned. This cannot be provided together with the `name` or `names` query parameters.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of resource names. If there is not at least one resource that matches each of the elements of `names`, then an error is returned.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        resolution: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The desired ms between samples. Available resolutions may depend on data type, `start_time` and `end_time`. In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and `86400000` are possible values.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        start_time: Annotated[Optional[conint(strict=True, ge=0)], Field(description="When the time window starts (in milliseconds since epoch).")] = None,
        total_only: Annotated[Optional[StrictBool], Field(description="Only return the total record for the specified items. The total record will be the total of all items after filtering. The `items` list will be empty.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET targets/performance/replication
        
        List replication performance metrics for targets.
        
        :param references: A list of references to query for. Overrides ids and names keyword arguments.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param end_time: When the time window ends (in milliseconds since epoch).
        :type end_time: int
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param ids: A comma-separated list of resource IDs. If after filtering, there is not at
                    least one resource that matches each of the elements of `ids`, then an error
                    is returned. This cannot be provided together with the `name` or `names`
                    query parameters.
        :type ids: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param names: A comma-separated list of resource names. If there is not at least one resource
                    that matches each of the elements of `names`, then an error is returned.
        :type names: List[str]
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param resolution: The desired ms between samples. Available resolutions may depend on data type,
                        `start_time` and `end_time`. In general `1000`, `30000`, `300000`,
                        `1800000`, `7200000`, and `86400000` are possible values.
        :type resolution: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param start_time: When the time window starts (in milliseconds since epoch).
        :type start_time: int
        :param total_only: Only return the total record for the specified items. The total record will be
                        the total of all items after filtering. The `items` list will be empty.
        :type total_only: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            end_time=end_time,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            ids=ids,
            limit=limit,
            names=names,
            offset=offset,
            resolution=resolution,
            sort=sort,
            start_time=start_time,
            total_only=total_only,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['ids', 'names'], kwargs)
        _fixup_list_type_params(['ids', 'names', 'sort'], kwargs)
        return self._call_api('TargetsApi', 'api217_targets_performance_replication_get_with_http_info', kwargs)

    def post_targets(
        self,
        names: Annotated[conlist(StrictStr), Field(..., description="A comma-separated list of resource names.")],
        target: 'models.TargetPost',
        references: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """POST targets
        
        Add a target for replication.
        
        :param names: A comma-separated list of resource names. (required)
        :type names: List[str]
        :param target: (required)
        :type target: TargetPost
        :param references: A list of references to query for. Overrides names keyword argument.
        :type references: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            names=names,
            target=target,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(references, ['names'], kwargs)
        _fixup_list_type_params(['names'], kwargs)
        return self._call_api('TargetsApi', 'api217_targets_post_with_http_info', kwargs)

    def get_usage_groups(
        self,
        groups: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        gids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of group IDs. If there is not at least one resource that matches each of the elements of `gids`, then an error is returned. This cannot be provided together with `group_names` query parameter.")] = None,
        group_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of group names. If there is not at least one resource that matches each of the elements of `group_names`, then an error is returned. This cannot be provided together with `gids` query parameter.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET usage/groups
        
        List groups with hard limit quotas and their file system usage.
        
        :param groups: A list of groups to query for. Overrides group_names keyword argument.
        :type groups: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param gids: A comma-separated list of group IDs. If there is not at least one resource that
                    matches each of the elements of `gids`, then an error is returned. This
                    cannot be provided together with `group_names` query parameter.
        :type gids: List[int]
        :param group_names: A comma-separated list of group names. If there is not at least one resource
                            that matches each of the elements of `group_names`, then an error is
                            returned. This cannot be provided together with `gids` query parameter.
        :type group_names: List[str]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            gids=gids,
            group_names=group_names,
            limit=limit,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(groups, ['group_names'], kwargs)
        _fixup_list_type_params(['context_names', 'file_system_ids', 'file_system_names', 'gids', 'group_names', 'sort'], kwargs)
        return self._call_api('UsageApi', 'api217_usage_groups_get_with_http_info', kwargs)

    def get_usage_users(
        self,
        users: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        file_systems: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        contexts: Optional[Union[ReferenceType, List[ReferenceType]]] = None,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        allow_errors: Annotated[Optional[StrictBool], Field(description="If set to `true`, the API will allow the operation to continue even if there are errors. Any errors will be returned in the `errors` field of the response. If set to `false`, the operation will fail if there are any errors.")] = None,
        context_names: Annotated[Optional[conlist(StrictStr)], Field(description="Performs the operation on the unique contexts specified. If specified, each context name must be the name of an array in the same fleet. If not specified, the context will default to the array that received this request. Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. Enter multiple names in comma-separated format. For example, `name01,name02`.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        file_system_ids: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system IDs. If after filtering, there is not at least one resource that matches each of the elements of `file_system_ids`, then an error is returned. This cannot be provided together with the `file_system_names` query parameter.")] = None,
        file_system_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of file system names. If there is not at least one resource that matches each of the elements of `file_system_names`, then an error is returned.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        uids: Annotated[Optional[conlist(StrictInt)], Field(description="A comma-separated list of user IDs. If there is not at least one resource that matches each of the elements of `uids`, then an error is returned. This cannot be provided together with `user_names` query parameter.")] = None,
        user_names: Annotated[Optional[conlist(StrictStr)], Field(description="A comma-separated list of user names. If there is not at least one resource that matches each of the elements of `user_names`, then an error is returned. This cannot be provided together with `uids` query parameter.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET usage/users
        
        List users with hard limit quotas and their file system usage.
        
        :param users: A list of users to query for. Overrides user_names keyword argument.
        :type users: ReferenceType or List[ReferenceType], optional
        :param file_systems: A list of file_systems to query for. Overrides file_system_ids and file_system_names keyword arguments.
        :type file_systems: ReferenceType or List[ReferenceType], optional
        :param contexts: A list of contexts to query for. Overrides context_names keyword argument.
        :type contexts: ReferenceType or List[ReferenceType], optional
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param allow_errors: If set to `true`, the API will allow the operation to continue even if there are
                            errors. Any errors will be returned in the `errors` field of the response.
                            If set to `false`, the operation will fail if there are any errors.
        :type allow_errors: bool
        :param context_names: Performs the operation on the unique contexts specified. If specified, each
                            context name must be the name of an array in the same fleet. If not
                            specified, the context will default to the array that received this
                            request. Other parameters provided with the request, such as names of
                            volumes or snapshots, are resolved relative to the provided `context`.
                            Enter multiple names in comma-separated format. For example,
                            `name01,name02`.
        :type context_names: List[str]
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param file_system_ids: A comma-separated list of file system IDs. If after filtering, there is not at
                                least one resource that matches each of the elements of `file_system_ids`,
                                then an error is returned. This cannot be provided together with the
                                `file_system_names` query parameter.
        :type file_system_ids: List[str]
        :param file_system_names: A comma-separated list of file system names. If there is not at least one
                                resource that matches each of the elements of `file_system_names`, then an
                                error is returned.
        :type file_system_names: List[str]
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param uids: A comma-separated list of user IDs. If there is not at least one resource that
                    matches each of the elements of `uids`, then an error is returned. This
                    cannot be provided together with `user_names` query parameter.
        :type uids: List[int]
        :param user_names: A comma-separated list of user names. If there is not at least one resource that
                        matches each of the elements of `user_names`, then an error is returned.
                        This cannot be provided together with `uids` query parameter.
        :type user_names: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            allow_errors=allow_errors,
            context_names=context_names,
            continuation_token=continuation_token,
            file_system_ids=file_system_ids,
            file_system_names=file_system_names,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            offset=offset,
            sort=sort,
            uids=uids,
            user_names=user_names,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _process_references(contexts, ['context_names'], kwargs)
        _process_references(file_systems, ['file_system_ids', 'file_system_names'], kwargs)
        _process_references(users, ['user_names'], kwargs)
        _fixup_list_type_params(['context_names', 'file_system_ids', 'file_system_names', 'sort', 'uids', 'user_names'], kwargs)
        return self._call_api('UsageApi', 'api217_usage_users_get_with_http_info', kwargs)

    def get_support_verification_keys(
        self,
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="An opaque token used to iterate over a collection. The token to use on the next request is returned in the `continuation_token` field of the result.")] = None,
        filter: Annotated[Optional[Union[StrictStr, Filter]], Field(description="Exclude resources that don't match the specified criteria.")] = None,
        limit: Annotated[Optional[conint(strict=True, ge=0)], Field(description="Limit the size of the response to the specified number of resources. A `limit` of `0` can be used to get the number of resources without getting all of the resources. It will be returned in the `total_item_count` field. If a client asks for a page size larger than the available number, the request is still valid. In that case the server just returns the available number of items, disregarding the client's page size request.")] = None,
        offset: Annotated[Optional[conint(strict=True, ge=0)], Field(description="The offset of the first resource to return from a collection.")] = None,
        sort: Annotated[Optional[conlist(constr(strict=True))], Field(description="Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """GET verification-keys
        
        List the key used to verify the signed challenges that are used by Pure Support to access the FlashBlade.
        
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param continuation_token: An opaque token used to iterate over a collection. The token to use on the next
                                request is returned in the `continuation_token` field of the result.
        :type continuation_token: str
        :param filter: Exclude resources that don't match the specified criteria.
        :type filter: Union[str, Filter]
        :param limit: Limit the size of the response to the specified number of resources. A `limit`
                    of `0` can be used to get the number of resources without getting all of the
                    resources. It will be returned in the `total_item_count` field. If a client
                    asks for a page size larger than the available number, the request is still
                    valid. In that case the server just returns the available number of items,
                    disregarding the client's page size request.
        :type limit: int
        :param offset: The offset of the first resource to return from a collection.
        :type offset: int
        :param sort: Sort the response by the specified fields (in descending order if '-' is appended to the field name). NOTE: If you provide a sort you will not get a `continuation_token` in the response.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            x_request_id=x_request_id,
            continuation_token=continuation_token,
            filter=str(filter) if isinstance(filter, Filter) else filter,
            limit=limit,
            offset=offset,
            sort=sort,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params(['sort'], kwargs)
        return self._call_api('VerificationKeysApi', 'api217_support_verification_keys_get_with_http_info', kwargs)

    def patch_support_verification_keys(
        self,
        key: 'models.VerificationKeyPatch',
        x_request_id: Annotated[Optional[StrictStr], Field(description="Supplied by client during request or generated by server.")] = None,
        async_req: Optional[bool] = None,
        _preload_content: bool = True,
        _return_http_data_only: Optional[bool] = None,
        _request_timeout: Optional[Union[float, Tuple[float, float]]] = None
    ) -> Union[ValidResponse, ErrorResponse]:
        """PATCH verification-keys
        
        Update the key used to verify the signed challenges that are used by Pure Support to access the FlashBlade.
        
        :param key: (required)
        :type key: VerificationKeyPatch
        :param x_request_id: Supplied by client during request or generated by server.
        :type x_request_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                 be set to none and raw_data will store the
                 HTTP response body without reading/decoding.
                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                 object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                 number provided, it will be total request
                 timeout. It can also be a pair (tuple) of
                 (connection, read) timeouts.
        :type _request_timeout: int or (float, float), optional
        
        :return: ValidResponse: If the call was successful.
                 ErrorResponse: If the call was not successful.
        :rtype: Union[ValidResponse, ErrorResponse]
        
        :raises: PureError: If calling the API fails.
        :raises: ValueError: If a parameter is of an invalid type.
        :raises: TypeError: If invalid or missing parameters are used.
        """ # noqa: E501

        kwargs = dict(
            key=key,
            x_request_id=x_request_id,
            async_req=async_req,
            _preload_content=_preload_content,
            _return_http_data_only=_return_http_data_only,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None or k == 'x_request_id'}
        _fixup_list_type_params([], kwargs)
        return self._call_api('VerificationKeysApi', 'api217_support_verification_keys_patch_with_http_info', kwargs)

    def get_versions(
        self,
        async_req=False,  # type: bool
        _return_http_data_only=False,  # type: bool
        _preload_content=True,  # type: bool
        _request_timeout=None,  # type: Optional[int]
    ):
        # type: (...) -> dict
        """
        Get available API versions. No authentication is required to access this
        endpoint.  The response will be a ValidResponse with version ids listed as items.

        Args:

            async_req (bool, optional):
                Request runs in separate thread and method returns
                multiprocessing.pool.ApplyResult.
            _return_http_data_only (bool, optional):
                Returns only data field.
            _preload_content (bool, optional):
                Response is converted into objects.
            _request_timeout (int, optional):
                Total request timeout in seconds.

        Returns:
            ValidResponse: If the call was successful.
            ErrorResponse: If the call was not successful.

        Raises:
            PureError: If calling the API fails.
            ValueError: If a parameter is of an invalid type.
            TypeError: If invalid or missing parameters are used.
        """
        kwargs = dict(
            async_req=async_req,
            _return_http_data_only=_return_http_data_only,
            _preload_content=_preload_content,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        return self._call_api('AuthorizationApi', 'api_api_version_get_with_http_info', kwargs, response_creator=self._create_api_versions_response)

    def logout(
        self,
        async_req=False,  # type: bool
        _return_http_data_only=False,  # type: bool
        _preload_content=True,  # type: bool
        _request_timeout=None,  # type: Optional[int]
    ):
        # type: (...) -> None
        """
        Invalidate a REST session token.

        Args:

            async_req (bool, optional):
                Request runs in separate thread and method returns
                multiprocessing.pool.ApplyResult.
            _return_http_data_only (bool, optional):
                Returns only data field.
            _preload_content (bool, optional):
                Response is converted into objects.
            _request_timeout (int, optional):
                Total request timeout in seconds.

        Returns:
            ValidResponse: If the call was successful.
            ErrorResponse: If the call was not successful.

        Raises:
            PureError: If calling the API fails.
            ValueError: If a parameter is of an invalid type.
            TypeError: If invalid or missing parameters are used.
        """
        kwargs = dict(
            async_req=async_req,
            _return_http_data_only=_return_http_data_only,
            _preload_content=_preload_content,
            _request_timeout=_request_timeout,
        )
        kwargs = {k: v for k, v in kwargs.items() if v is not None}
        res = self._call_api('AuthorizationApi', 'api_logout_post_with_http_info', kwargs, response_creator=self._create_logout_response)
        # Note: The normal behavior when a call returns a 401 or 403 authentication error status
        # is to reset the authentication token and retry. This effectively logs the client in again.
        # Setting _retries to 0 prevents this behavior for any future calls with this client.
        self._retries = 0
        return res

    def _set_auth_header(self, refresh=False):
        """
        Set the authorization or x-auth-token header of the internal client with the access
        token.

        Args:
            refresh (bool, optional): Whether to retrieve a new access token.
                Defaults to False.

        Raises:
            PureError: If there was an error retrieving the access token.
        """
        if isinstance(self._token_man, TokenManager):
            self._api_client.set_default_header(Headers.authorization,
                                                self._token_man.get_header(refresh=refresh))
        else:
            self._api_client.set_default_header(Headers.x_auth_token,
                                                self._token_man.get_session_token(refresh=refresh))

    def _call_api(self, api_class_name, api_function_name, kwargs, response_creator=None):
        """
        Call the API function and process the response. May call the API
        repeatedly if the request failed for a reason that may not persist in
        the next call.

        Args:
            api_function (function): Swagger-generated function to call.
            kwargs (dict): kwargs to pass to the function.
            response_creator: optional method to generate a ValidResponse from a non-standard endpoint.
                              If None, use the standard _create_valid_response method.

        Returns:
            ValidResponse: If the call was successful.
            ErrorResponse: If the call was not successful.

        Raises:
            PureError: If calling the API fails.
            ValueError: If a parameter is of an invalid type.
            TypeError: If invalid or missing parameters are used.
        """
        kwargs['_request_timeout'] = self._timeout
        if 'x_request_id' in kwargs and not kwargs['x_request_id']:
            kwargs['x_request_id'] = str(uuid.uuid4())

        if kwargs.get('authorization') is not None:
            warnings.warn("authorization parameter is deprecated, and will be removed soon.", DeprecationWarning)

        retries = self._retries
        api_function = getattr(self.__get_api_instance(api_class_name), api_function_name)
        while True:
            try:
                response = api_function(**kwargs)
                # Call was successful (200)
                if response_creator:
                    return response_creator(response, api_function, kwargs)
                else:
                    return self._create_valid_response(response, api_function, kwargs)
            except ApiException as error:
                # If no chance for retries, return the error
                if retries == 0:
                    return self._create_error_response(error)
                # If bad request or not found, return the error (it will never work)
                elif error.status in [400, 404]:
                    return self._create_error_response(error)
                # If authentication error, reset access token and retry
                elif error.status in [401, 403]:
                    self._set_auth_header(refresh=True)
                # If rate limit error, wait the proper time and try again
                elif error.status == 429:
                    # If the the minute limit hit, wait that long
                    if (int(error.headers.get(Headers.x_ratelimit_remaining_min))
                            == int(error.headers.get(Headers.x_ratelimit_min))):
                        time.sleep(60)
                    # Otherwise it was the second limit and only wait a second
                    time.sleep(1)
                # If some internal server error we know nothing about, return
                elif error.status == 500:
                    return self._create_error_response(error)
                # If internal server errors that has to do with timeouts, try again
                elif error.status > 500:
                    pass
                # If error with the swagger client, raise the error
                else:
                    raise PureError(error)
            retries = retries - 1

    def __get_api_instance(self, api_class):
        """
        Get the API instance for the given class.

        Args:
            api_class (class): Swagger-generated api class.

        Returns:
            class: API instance for the given class.
        """
        if api_class not in self.__apis_instances:
            self.__apis_instances[api_class] = getattr(api, api_class)(self._api_client)
        return self.__apis_instances[api_class]

    def _create_valid_response(self, response: ApiResponse, endpoint, kwargs):
        """
        Create a ValidResponse from a Swagger response.

        Args:
            response ApiResponse:
                Body, status, header tuple as returned from Swagger client.
            endpoint (function):
                The function of the Swagger client that was called.
            kwargs (dict):
                The processed kwargs that were passed to the endpoint function.

        Returns:
            ValidResponse
        """
        if response.headers and "content-type" in response.headers.keys() and response.headers["content-type"] in ["application/octet-stream", "text/plain"]:
            body = self._create_file(response)
        else:
            body = response.data
        headers = response.headers

        continuation_token = getattr(body, "continuation_token", None)
        total_item_count = getattr(body, "total_item_count", None)
        total = getattr(body, "total", None)
        more_items_remaining = getattr(body, "more_items_remaining", None)
        items = None

        if body is not None:
            # if body is a file then should be a singleton list
            body_items = [body] if type(body) == str else body.items
            items = iter(ItemIterator(self, endpoint, kwargs,
                                      continuation_token, total_item_count,
                                      body_items,
                                      headers.get(Headers.x_request_id, None),
                                      more_items_remaining or False))
        return ValidResponse(response.status_code, continuation_token, total_item_count,
                             items, headers, total, more_items_remaining)

    def _create_file(self, response):
        path = tempfile.mkdtemp(dir=self._api_client.configuration.temp_folder_path)

        content_disposition = response.headers["Content-Disposition"]
        if content_disposition:
            filename = re.search(r'filename=[\'"]?([^\'"\s]+)[\'"]?',
                                 content_disposition).group(1)
            path = os.path.join(os.path.dirname(path), filename)

        with open(path, "wb") as f:
            response_data = response.data
            if type(response_data) == str:
                response_data = response_data.encode('utf-8')
            f.write(response_data)

        return path

    def _create_api_versions_response(self, response: ApiResponse, endpoint, kwargs):
        """
        Create a ValidResponse from an ApiVersion Swagger response.

        Args:
            response ApiResponse:
                Body, status, header tuple as returned from Swagger client.
            endpoint (function):
                The function of the Swagger client that was called.
            kwargs (dict):
                The processed kwargs that were passed to the endpoint function.

        Returns:
            ValidResponse
        """
        body = response.data
        headers = response.headers

        continuation_token = None
        total_item_count = None
        total = None
        more_items_remaining = None
        items = None

        if body is not None:
            # if body is a file then should be a singleton list
            body_items = [body] if type(body) == str else body.versions
            items = iter(ItemIterator(self, endpoint, kwargs,
                                      continuation_token, total_item_count,
                                      body_items,
                                      headers.get(Headers.x_request_id, None),
                                      more_items_remaining or False))
        response = ValidResponse(response.status_code, continuation_token, total_item_count,
                                 items, headers, total, more_items_remaining)
        return response


    def _create_logout_response(self, response: ApiResponse, endpoint, kwargs):
        """
           A logout response only contains the status field.
        """
        headers = response.headers

        continuation_token = None
        total_item_count = None
        total = None
        more_items_remaining = None
        items = None
        return ValidResponse(response.status_code, continuation_token, total_item_count,
                             items, headers, total, more_items_remaining)


    def _create_error_response(self, error):
        """
        Create an ErrorResponse from a Swagger error.

        Args:
            error (ApiException):
                Error returned by Swagger client.

        Returns:
            ErrorResponse
        """
        status = error.status
        try:
            body = json.loads(error.body)
        except Exception:
            errors = [ApiError(None, "Response is not a valid JSON")]
            return ErrorResponse(status, errors, headers=error.headers)

        if not isinstance(body, dict):
            errors = [ApiError(None, "Response is not an Error object")]
            return ErrorResponse(status, errors, headers=error.headers)

        if status in [403, 429]:
            # Parse differently if the error message came from kong
            errors = [ApiError(None, body.get(Responses.message, None))]
        else:
            errors = [ApiError(err.get(Responses.context, None),
                               err.get(Responses.message, None))
                      for err in body.get(Responses.errors, [])]
        return ErrorResponse(status, errors, headers=error.headers)


def _process_references(
    references: Optional[Union[ReferenceType, List[ReferenceType]]],
    params: List[str],
    kwargs: Dict[str, Any]
) -> None:

    """Process reference objects into a list of ids or names.
    Removes ids and names arguments.

    :param references: The references from which to extract ids or names.
    :type references: ReferenceType or List[ReferenceType], optional

    :param params: The parameters to be overridden.
    :type params: List[str]

    :param kwargs: The kwargs to process.
    :type kwargs: Dict[str, Any]

    :raise PureError: If a reference does not have an id or name.

    """
    if references is not None:
        if not isinstance(references, list):
            references = [references]
        for param in params:
            kwargs.pop(param, None)
        all_have_id = all(ref.id is not None for ref in references)
        all_have_name = all(ref.name is not None for ref in references)
        id_param = [param for param in params if param.endswith("ids")]
        name_param = [param for param in params if param.endswith("names")]
        if all_have_id and len(id_param) > 0:
            kwargs[id_param[0]] = [ref.id for ref in references]
        elif all_have_name and len(name_param) > 0:
            kwargs[name_param[0]] = [ref.name for ref in references]
        else:
            raise PureError('Invalid reference for {}'.format(", ".join(params)))


def _fixup_list_type_params(
    params: List[str],
    kwargs: Dict[str, Any]
) -> None:

    """Process object into a list if it expected to be list type.

    :param params: The parameters to be overridden.
    :type params: List[str]

    :param kwargs: The kwargs to process.
    :type kwargs: Dict[str, Any]

    """
    for _param in params:
        _value = kwargs.get(_param, None)
        if _value is not None and not isinstance(_value, list):
            _param_type = type(_value).__name__.replace("'", '')
            warnings.warn(f"'{_param}' parameter, invalid type: expected List[{_param_type}] but received {_param_type}, converting to list. Please revisit code.", SyntaxWarning)
            kwargs[_param] = [_value]

